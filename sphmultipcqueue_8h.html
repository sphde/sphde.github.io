<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphmultipcqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphmultipcqueue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, multi producer multi consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses transactional memory operations to implement Lock Free Producer/Consumer queues (SPHMultiPCQueue_t).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sphlfentry_8h_source.html">sphlfentry.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphdirectpcqueue_8h_source.html">sphdirectpcqueue.h</a>&quot;</code><br />
</div>
<p><a href="sphmultipcqueue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4d08a6f74d96b695afefd03854839b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr class="memdesc:a4d08a6f74d96b695afefd03854839b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore this macro behind the curtain <br /></td></tr>
<tr class="separator:a4d08a6f74d96b695afefd03854839b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a279ef7e6dd08856b6baf5538a47de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a279ef7e6dd08856b6baf5538a47de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a09a279ef7e6dd08856b6baf5538a47de">SPHMPMCQ_CIRCULAR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a09a279ef7e6dd08856b6baf5538a47de"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for circular log buffers <br /></td></tr>
<tr class="separator:a09a279ef7e6dd08856b6baf5538a47de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173759bedc6b609fcadbfb9fb353b005"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173759bedc6b609fcadbfb9fb353b005"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a173759bedc6b609fcadbfb9fb353b005">SPHMPMCQ_CIRCULAR_WRAPPED</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:a173759bedc6b609fcadbfb9fb353b005"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped <br /></td></tr>
<tr class="separator:a173759bedc6b609fcadbfb9fb353b005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30798355ad91dbbafeb785d73050e663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30798355ad91dbbafeb785d73050e663"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a30798355ad91dbbafeb785d73050e663">SPHMPMCQ_CIRCULAR_NOTFIRST</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:a30798355ad91dbbafeb785d73050e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped multiple times <br /></td></tr>
<tr class="separator:a30798355ad91dbbafeb785d73050e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec410e1daea70655cc932080c3f5ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec410e1daea70655cc932080c3f5ed9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#adec410e1daea70655cc932080c3f5ed9">SPHMPMCQ_CACHE_PREFETCH0</a>&#160;&#160;&#160;(1&lt;&lt;3)</td></tr>
<tr class="memdesc:adec410e1daea70655cc932080c3f5ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the immediate (0 offset) cache-line <br /></td></tr>
<tr class="separator:adec410e1daea70655cc932080c3f5ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa296d9c21d50a0a1988a43a78ce838a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa296d9c21d50a0a1988a43a78ce838a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#aa296d9c21d50a0a1988a43a78ce838a1">SPHMPMCQ_CACHE_PREFETCH1</a>&#160;&#160;&#160;(1&lt;&lt;4)</td></tr>
<tr class="memdesc:aa296d9c21d50a0a1988a43a78ce838a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the next (line size offset) cache-line <br /></td></tr>
<tr class="separator:aa296d9c21d50a0a1988a43a78ce838a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9527ed34b2322ebf0d3ce75e31a227bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a9527ed34b2322ebf0d3ce75e31a227bb">SPHMPMCQ_CIRCULAR_RESETMASK</a></td></tr>
<tr class="memdesc:a9527ed34b2322ebf0d3ce75e31a227bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options mask flag used the reset circular log buffers  <a href="#a9527ed34b2322ebf0d3ce75e31a227bb">More...</a><br /></td></tr>
<tr class="separator:a9527ed34b2322ebf0d3ce75e31a227bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4172ca7c87134d5369147b8ffafc0ea7"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a></td></tr>
<tr class="memdesc:a4172ca7c87134d5369147b8ffafc0ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an instance of SPH Multi Producer, Multi Consumer Queue.  <a href="#a4172ca7c87134d5369147b8ffafc0ea7">More...</a><br /></td></tr>
<tr class="separator:a4172ca7c87134d5369147b8ffafc0ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a992c5e4030254d7a70b6003f3ebe8de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a992c5e4030254d7a70b6003f3ebe8de2">SPHMPMCQInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr class="memdesc:a992c5e4030254d7a70b6003f3ebe8de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a MPMC Queue.  <a href="#a992c5e4030254d7a70b6003f3ebe8de2">More...</a><br /></td></tr>
<tr class="separator:a992c5e4030254d7a70b6003f3ebe8de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b691ce0cd95311662f3bd4236458af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a04b691ce0cd95311662f3bd4236458af">SPHMPMCQInitWithStride</a> (void *buf_seg, block_size_t buf_size, unsigned short entry_stride, unsigned int options)</td></tr>
<tr class="memdesc:a04b691ce0cd95311662f3bd4236458af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Multi Producer Multi Consumer Queue with a fixed entry stride.  <a href="#a04b691ce0cd95311662f3bd4236458af">More...</a><br /></td></tr>
<tr class="separator:a04b691ce0cd95311662f3bd4236458af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacabe9e77867181a551918900d1c9be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#aacabe9e77867181a551918900d1c9be1">SPHMPMCQCreate</a> (block_size_t buf_size)</td></tr>
<tr class="memdesc:aacabe9e77867181a551918900d1c9be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Multi Producer Multi Consumer Queue.  <a href="#aacabe9e77867181a551918900d1c9be1">More...</a><br /></td></tr>
<tr class="separator:aacabe9e77867181a551918900d1c9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0e3cb15e9b3fae754bf1cb72d69b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#aed0e3cb15e9b3fae754bf1cb72d69b03">SPHMPMCQCreateWithStride</a> (block_size_t buf_size, unsigned short stride)</td></tr>
<tr class="memdesc:aed0e3cb15e9b3fae754bf1cb72d69b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Multi Producer Multi Consumer Queue.  <a href="#aed0e3cb15e9b3fae754bf1cb72d69b03">More...</a><br /></td></tr>
<tr class="separator:aed0e3cb15e9b3fae754bf1cb72d69b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51432f1bad0174c8ddc6edf03867264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#ae51432f1bad0174c8ddc6edf03867264">SPHMPMCQGetStride</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:ae51432f1bad0174c8ddc6edf03867264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry stride for an existing Lock Free Multi Producer Multi Consumer Queue.  <a href="#ae51432f1bad0174c8ddc6edf03867264">More...</a><br /></td></tr>
<tr class="separator:ae51432f1bad0174c8ddc6edf03867264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5b071bcac063b934df7d77bac5724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#adaf5b071bcac063b934df7d77bac5724">SPHMPMCQGetEntries</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:adaf5b071bcac063b934df7d77bac5724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of entries for an existing Lock Free Multi Producer Multi Consumer Queue.  <a href="#adaf5b071bcac063b934df7d77bac5724">More...</a><br /></td></tr>
<tr class="separator:adaf5b071bcac063b934df7d77bac5724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9858410deab71d7aafb7db84764c21ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a9858410deab71d7aafb7db84764c21ad">SPHMPMCQIsEmpty</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a9858410deab71d7aafb7db84764c21ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#a9858410deab71d7aafb7db84764c21ad">More...</a><br /></td></tr>
<tr class="separator:a9858410deab71d7aafb7db84764c21ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2eae552511bf625fb6c627e2ff8449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a3a2eae552511bf625fb6c627e2ff8449">SPHMPMCQIsFull</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a3a2eae552511bf625fb6c627e2ff8449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#a3a2eae552511bf625fb6c627e2ff8449">More...</a><br /></td></tr>
<tr class="separator:a3a2eae552511bf625fb6c627e2ff8449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394befe6a4dc5ec3928dc2c94d88e051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a394befe6a4dc5ec3928dc2c94d88e051">SPHMPMCQFreeSpace</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a394befe6a4dc5ec3928dc2c94d88e051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of free space (in bytes) remaining in the specified queue.  <a href="#a394befe6a4dc5ec3928dc2c94d88e051">More...</a><br /></td></tr>
<tr class="separator:a394befe6a4dc5ec3928dc2c94d88e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c11639a4be89ab27396a5c953dfff12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a9c11639a4be89ab27396a5c953dfff12">SPHMPMCQGetEntryTemplate</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a9c11639a4be89ab27396a5c953dfff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry template for an existing Lock Free Multi Producer Multi Consumer Queue. This template is used later to mark an allocated entry complete.  <a href="#a9c11639a4be89ab27396a5c953dfff12">More...</a><br /></td></tr>
<tr class="separator:a9c11639a4be89ab27396a5c953dfff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9352a7e62093377ef73e455ee52144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#aed9352a7e62093377ef73e455ee52144">SPHMPMCQAllocStrideDirectHTM</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:aed9352a7e62093377ef73e455ee52144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Multi Producer Multi Consumer Queue.  <a href="#aed9352a7e62093377ef73e455ee52144">More...</a><br /></td></tr>
<tr class="separator:aed9352a7e62093377ef73e455ee52144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a929cbc999e92e724be3e479be8c643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a7a929cbc999e92e724be3e479be8c643">SPHSPMCQAllocStrideDirect</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a7a929cbc999e92e724be3e479be8c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Multi Producer Multi Consumer Queue. This function uses no synchronization, so only safe with external synchronization, or for use by a single producer, thus the "SPMC" moniker.  <a href="#a7a929cbc999e92e724be3e479be8c643">More...</a><br /></td></tr>
<tr class="separator:a7a929cbc999e92e724be3e479be8c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf6514f2336b24ce17bd0e0e0b42526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#addf6514f2336b24ce17bd0e0e0b42526">SPHMPMCQGetNextCompleteDirectHTM</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:addf6514f2336b24ce17bd0e0e0b42526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified multi producer multi consumer queue.  <a href="#addf6514f2336b24ce17bd0e0e0b42526">More...</a><br /></td></tr>
<tr class="separator:addf6514f2336b24ce17bd0e0e0b42526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7cad61c8c2598bc297bf3cd2b7181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a3eb7cad61c8c2598bc297bf3cd2b7181">SPHMPSCQGetNextCompleteDirect</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a3eb7cad61c8c2598bc297bf3cd2b7181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified multi producer multi consumer queue. This function uses no synchronization, so only safe with external synchronization, or for use by a single consumer, thus the "MPSC" moniker.  <a href="#a3eb7cad61c8c2598bc297bf3cd2b7181">More...</a><br /></td></tr>
<tr class="separator:a3eb7cad61c8c2598bc297bf3cd2b7181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87d147ff50bd6c288b5a5c0ad145c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#ad87d147ff50bd6c288b5a5c0ad145c87">SPHMPMCQEntryDirectIsComplete</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:ad87d147ff50bd6c288b5a5c0ad145c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#ad87d147ff50bd6c288b5a5c0ad145c87">More...</a><br /></td></tr>
<tr class="separator:ad87d147ff50bd6c288b5a5c0ad145c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5381348123707c09ec8b096c53edec20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a5381348123707c09ec8b096c53edec20">SPHMPMCQFreeEntryDirect</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue, <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> entry)</td></tr>
<tr class="memdesc:a5381348123707c09ec8b096c53edec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to free the queue entry it just processed (using SPHMPMCQGetNextComplete), from the specified multi producer multi consumer queue.  <a href="#a5381348123707c09ec8b096c53edec20">More...</a><br /></td></tr>
<tr class="separator:a5381348123707c09ec8b096c53edec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a75270b3fb322ce0d6452c1d31acd8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a4a75270b3fb322ce0d6452c1d31acd8b">SPHMPMCQGetNextEntry</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a4a75270b3fb322ce0d6452c1d31acd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next allocated queue entry from the specified multi producer multi consumer queue.  <a href="#a4a75270b3fb322ce0d6452c1d31acd8b">More...</a><br /></td></tr>
<tr class="separator:a4a75270b3fb322ce0d6452c1d31acd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248b569d73a9cfc96502d1c2739e9bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a248b569d73a9cfc96502d1c2739e9bfb">SPHMPMCQSetCachePrefetch</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue, int prefetch)</td></tr>
<tr class="memdesc:a248b569d73a9cfc96502d1c2739e9bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache-line prefetch options for entry allocate.  <a href="#a248b569d73a9cfc96502d1c2739e9bfb">More...</a><br /></td></tr>
<tr class="separator:a248b569d73a9cfc96502d1c2739e9bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0edeff9c8a26dc7db4f5a7ed08e468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a7e0edeff9c8a26dc7db4f5a7ed08e468">SPHMPMCQPrefetch</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a7e0edeff9c8a26dc7db4f5a7ed08e468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch pages from the specific queue.  <a href="#a7e0edeff9c8a26dc7db4f5a7ed08e468">More...</a><br /></td></tr>
<tr class="separator:a7e0edeff9c8a26dc7db4f5a7ed08e468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44309ff29d8c989d87beca6ee5841dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphmultipcqueue_8h.html#a44309ff29d8c989d87beca6ee5841dfe">SPHMPMCQDestroy</a> (<a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> queue)</td></tr>
<tr class="memdesc:a44309ff29d8c989d87beca6ee5841dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the queue and frees the SAS storage for reuse.  <a href="#a44309ff29d8c989d87beca6ee5841dfe">More...</a><br /></td></tr>
<tr class="separator:a44309ff29d8c989d87beca6ee5841dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, multi producer multi consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses transactional memory operations to implement Lock Free Producer/Consumer queues (SPHMultiPCQueue_t). </p>
<p>! This API supports atomic allocation of storage for queue entries for zero copy persistence and sharing. Zero copy queues divides the process of producing a queue entry in to three steps:</p><ul>
<li>Allocate the queue entry (and initialize the header)</li>
<li>Use the return entry handle to fill in application specific data.</li>
<li>Marks the entry complete in the header.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html">sphlfentry.h</a>&gt;</span></div>
<div class="line"><a class="code" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {</div>
<div class="line">        <span class="keywordtype">double</span>  field0;</div>
<div class="line">        <span class="keywordtype">int</span>             field1;</div>
<div class="line">        <span class="keywordtype">int</span>             field2;</div>
<div class="line">        <span class="keywordtype">void</span>    *field3;</div>
<div class="line">} data_struct11;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate zero copy queue entry</span></div>
<div class="line">handle = SPHMPMCQMultiAllocStrideDirectHTM (pcqueue);</div>
<div class="line"><span class="keywordflow">if</span> (handle)</div>
<div class="line">{       <span class="comment">// insert data into the allocated queue entry</span></div>
<div class="line">        <a class="code" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> tmpl;</div>
<div class="line">        data_struct11 *struct_ptr;</div>
<div class="line"></div>
<div class="line">        tmpl = <a class="code" href="sphmultipcqueue_8h.html#a9c11639a4be89ab27396a5c953dfff12">SPHMPMCQGetEntryTemplate</a>(pcq);</div>
<div class="line"></div>
<div class="line">        struct_ptr = (data_struct11 *)<a class="code" href="sphdirectpcqueue_8h.html#ad6b2d3b82343ff17bf46401f064b73e0">SPHLFEntryDirectGetFreePtr</a>(handle);</div>
<div class="line">        <span class="keywordflow">if</span> (struct_ptr)</div>
<div class="line">        {       <span class="comment">// store struct fields directly into allocated queue entry</span></div>
<div class="line">                struct_ptr-&gt;field0 = data_double1;</div>
<div class="line">                struct_ptr-&gt;field1 = data_int2;</div>
<div class="line">                struct_ptr-&gt;field2 = data_int3;</div>
<div class="line">                struct_ptr-&gt;field3 = (<span class="keywordtype">void</span>*)sas_data_buff2;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">                printf(<span class="stringliteral">&quot;SPHENTRYALLOCSTRUCT(%p, data_struct11) failed)\n&quot;</span>,</div>
<div class="line">                           handle);</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Mark the entry complete and available to the consumer</span></div>
<div class="line">        <a class="code" href="sphdirectpcqueue_8h.html#a402662292f8ba9f24a0f2fa7828906f7">SPHLFEntryDirectComplete</a>(handle)</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">while</span> (SPHMPMCQMultiIsQueueFull(pcqueue))</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// pacing code</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The consumer can access queue entries once they are marked complete. The consumer:</p><ul>
<li>checks (spins) for the next allocated entry to become complete</li>
<li>uses the returned entry handle to directly access the entry contents</li>
<li>When done processing the queue entry, it marks the entry header invalid and deallocates the entry</li>
<li>This makes the next queue entry available, if any</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html">sphlfentry.h</a>&gt;</span></div>
<div class="line"><a class="code" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {</div>
<div class="line">        <span class="keywordtype">double</span>  field0;</div>
<div class="line">        <span class="keywordtype">int</span>     field1;</div>
<div class="line">        <span class="keywordtype">int</span>     field2;</div>
<div class="line">        <span class="keywordtype">void</span>    *field3;</div>
<div class="line">} data_struct11;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get next queue entry</span></div>
<div class="line">handle = <a class="code" href="sphmultipcqueue_8h.html#addf6514f2336b24ce17bd0e0e0b42526">SPHMPMCQGetNextCompleteDirectHTM</a> (pcqueue);</div>
<div class="line"><span class="keywordflow">if</span> (handle)</div>
<div class="line">{       <span class="comment">// insert data into the allocated queue entry</span></div>
<div class="line">        data_struct11 *struct_ptr;</div>
<div class="line">        struct_ptr  = (data_struct11*)<a class="code" href="sphlfentry_8h.html#add441d7f48e2f00a54b752671fdf69d3">SPHLFEntryGetNextPtr</a> (handle);</div>
<div class="line">        <span class="keywordflow">if</span> (struct_ptr)</div>
<div class="line">        {       <span class="comment">// access struct fields directly from queue entry</span></div>
<div class="line">                data_double1    = struct_ptr-&gt;field0;</div>
<div class="line">                data_int2       = struct_ptr-&gt;field1;</div>
<div class="line">                data_int3       = struct_ptr-&gt;field2;</div>
<div class="line">                sas_data_buff2  = struct_ptr-&gt;field3;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">                printf(<span class="stringliteral">&quot;SPHLFEntryGetNextPtr(%p, data_struct11) failed)\n&quot;</span>,</div>
<div class="line">                           handle);</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Mark the entry free and available for reuse</span></div>
<div class="line">        <a class="code" href="sphmultipcqueue_8h.html#a5381348123707c09ec8b096c53edec20">SPHMPMCQFreeEntryDirect</a>(pcqueue);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">while</span> (SPHMPMCQIsQueueEmpty(pcqueue))</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// pacing code</span></div>
<div class="line">        }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this implementation the allocation of the entry is serialized using Transactional Memory for atomic updates.</p>
<p>As an option the queue entry allocator will fill in a 4 or 16 byte entry header with:</p><ul>
<li>Entry status and length.</li>
<li>Entry identifying Category and SubCategory codes.</li>
<li>Process and Thread Ids.</li>
<li>High resolution timestamp.</li>
</ul>
<p>Any additional storage allocated to the entry (after the header) is available for application specific data. This API also provides several mechanisms to store application data including; direct array or structure overlay, and a streams like mechanism. The API provides a completion function (SPHLFEntryDirectComplete) which provides any memory barriers required by the platform and marks the entry complete.</p>
<p>The API support simple circular queues and requires a constant entry stride. A stride that matches or is multiple of the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple queue entries across cores/sockets.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>Additional work will include automatic pacing with Hysteresis </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9527ed34b2322ebf0d3ce75e31a227bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPHMPMCQ_CIRCULAR_RESETMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(SPHMPCQ_CIRCULAR | \</div>
<div class="line">                SPHMPCQ_CACHE_PREFETCH0 | \</div>
<div class="line">                SPHMPCQ_CACHE_PREFETCH1)</div>
</div><!-- fragment -->
<p>internal options mask flag used the reset circular log buffers </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4172ca7c87134d5369147b8ffafc0ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an instance of SPH Multi Producer, Multi Consumer Queue. </p>
<p>The type is SAS_RUNTIME_PCQUEUE_TM </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aed9352a7e62093377ef73e455ee52144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHMPMCQAllocStrideDirectHTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Multi Producer Multi Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="aacabe9e77867181a551918900d1c9be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> SPHMPMCQCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Multi Producer Multi Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a PC Queue. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aed0e3cb15e9b3fae754bf1cb72d69b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> SPHMPMCQCreateWithStride </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Multi Producer Multi Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a Logger. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a44309ff29d8c989d87beca6ee5841dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the queue and frees the SAS storage for reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ad87d147ff50bd6c288b5a5c0ad145c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQEntryDirectIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHMPMCQEntryComplete has been called for this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a5381348123707c09ec8b096c53edec20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQFreeEntryDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to free the queue entry it just processed (using SPHMPMCQGetNextComplete), from the specified multi producer multi consumer queue. </p>
<p>Mark the provided entry as free (unallocated and invalid) and if this entry is the current queue tail, bump the queue tail pointer to the next unallocated entry. If the specified queue is empty or the current tail entry is not yet completed the Free may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Consumer thread should not touch or modify a queue entry after calling FreeEntry. This is important to both correctness and performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td class="paramname">entry</td><td>queue entry to be marked free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for successful tail free, otherwise indicated failure. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a394befe6a4dc5ec3928dc2c94d88e051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t SPHMPMCQFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of free space (in bytes) remaining in the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of free space remaining in the queue buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="adaf5b071bcac063b934df7d77bac5724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQGetEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of entries for an existing Lock Free Multi Producer Multi Consumer Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of entries of strided queues, 0 if not strided, or -1 is not a valid SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c11639a4be89ab27396a5c953dfff12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> SPHMPMCQGetEntryTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the entry template for an existing Lock Free Multi Producer Multi Consumer Queue. This template is used later to mark an allocated entry complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the entry template for this queue or 0 if not a valid SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="addf6514f2336b24ce17bd0e0e0b42526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHMPMCQGetNextCompleteDirectHTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified multi producer multi consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a75270b3fb322ce0d6452c1d31acd8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHMPMCQGetNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next allocated queue entry from the specified multi producer multi consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the entry allocated by the produced thread. If the specified queue is empty or the next queue is not yet allocated the get may fail. Returning a entry does not mean the the producer has completed the entry and the consumer wait/spin (SPHLFEntryDirectIsComplete) for the entry to become complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="ae51432f1bad0174c8ddc6edf03867264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQGetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the entry stride for an existing Lock Free Multi Producer Multi Consumer Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the entry stride of strided queues, 0 if not strided, or -1 is not a valid SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a992c5e4030254d7a70b6003f3ebe8de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> SPHMPMCQInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a MPMC Queue. </p>
<p>Initialize the specified storage block as MPPC Queue control blocks. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE_TM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a04b691ce0cd95311662f3bd4236458af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a> SPHMPMCQInitWithStride </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>entry_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Multi Producer Multi Consumer Queue with a fixed entry stride. </p>
<p>Initialize the specified storage block as MPMC Queue control blocks. The stride and control flags are also stored. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE_TM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">entry_stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
    <tr><td class="paramname">options</td><td>option bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHMPMCQ_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a9858410deab71d7aafb7db84764c21ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a2eae552511bf625fb6c627e2ff8449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQIsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is currently full. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e0edeff9c8a26dc7db4f5a7ed08e468"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQPrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch pages from the specific queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a248b569d73a9cfc96502d1c2739e9bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHMPMCQSetCachePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefetch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache-line prefetch options for entry allocate. </p>
<p>prefetch == 0; No prefetch issued. <br />
 prefetch == 1; Prefetch the currently allocated cache-line. <br />
 prefetch == 2; Prefetch the cache-line following the allocated entry. <br />
 prefetch == 3; Prefetch the current and next cache-lines. </p><pre class="fragment">@param queue Handle to a queue.
@param prefetch prefetch option code.
@return 0 if successful.</pre> 
</div>
</div>
<a class="anchor" id="a3eb7cad61c8c2598bc297bf3cd2b7181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHMPSCQGetNextCompleteDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified multi producer multi consumer queue. This function uses no synchronization, so only safe with external synchronization, or for use by a single consumer, thus the "MPSC" moniker. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a929cbc999e92e724be3e479be8c643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSPMCQAllocStrideDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphmultipcqueue_8h.html#a4172ca7c87134d5369147b8ffafc0ea7">SPHMPMCQ_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Multi Producer Multi Consumer Queue. This function uses no synchronization, so only safe with external synchronization, or for use by a single producer, thus the "SPMC" moniker. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 03:56:04 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
