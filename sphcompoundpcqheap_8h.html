<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphcompoundpcqheap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphcompoundpcqheap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Address Space Compound Heap, PCQueue extension.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sascompoundheap_8h_source.html">sascompoundheap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphsinglepcqueue_8h_source.html">sphsinglepcqueue.h</a>&quot;</code><br />
</div>
<p><a href="sphcompoundpcqheap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5a89e785029082ea6a0e15d23d007d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#ae5a89e785029082ea6a0e15d23d007d4">SPHCompoundPCQAlloc</a> (<a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a> heap)</td></tr>
<tr class="memdesc:ae5a89e785029082ea6a0e15d23d007d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space.  <a href="#ae5a89e785029082ea6a0e15d23d007d4">More...</a><br /></td></tr>
<tr class="separator:ae5a89e785029082ea6a0e15d23d007d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb09753bdb0d3afa0095336690828c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#aeb09753bdb0d3afa0095336690828c46">SPHCompoundPCQFree</a> (<a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a> heap, <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> free_block)</td></tr>
<tr class="memdesc:aeb09753bdb0d3afa0095336690828c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the allocated SPH PCQueue <em>block</em> in the SAS Compound Heap <em>heap</em>.  <a href="#aeb09753bdb0d3afa0095336690828c46">More...</a><br /></td></tr>
<tr class="separator:aeb09753bdb0d3afa0095336690828c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29812c49ed1cd45068db58dfbbf8621a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#a29812c49ed1cd45068db58dfbbf8621a">SPHCompoundPCQNearAlloc</a> (void *nearObj)</td></tr>
<tr class="memdesc:a29812c49ed1cd45068db58dfbbf8621a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new SPH PCQueue from SAS Compound Heap <em>nearObj</em>.  <a href="#a29812c49ed1cd45068db58dfbbf8621a">More...</a><br /></td></tr>
<tr class="separator:a29812c49ed1cd45068db58dfbbf8621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f4fb5e018533a3d901b93570407a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#af4f4fb5e018533a3d901b93570407a0d">SPHCompoundPCQAllocNoLock</a> (<a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a> heap)</td></tr>
<tr class="memdesc:af4f4fb5e018533a3d901b93570407a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space.  <a href="#af4f4fb5e018533a3d901b93570407a0d">More...</a><br /></td></tr>
<tr class="separator:af4f4fb5e018533a3d901b93570407a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e430e56aa3079d2cb4900f1b7fde66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#a66e430e56aa3079d2cb4900f1b7fde66">SPHCompoundPCQNearAllocNoLock</a> (void *nearObj)</td></tr>
<tr class="memdesc:a66e430e56aa3079d2cb4900f1b7fde66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new SPH PCQueue from SAS Compound Heap <em>nearObj</em>.  <a href="#a66e430e56aa3079d2cb4900f1b7fde66">More...</a><br /></td></tr>
<tr class="separator:a66e430e56aa3079d2cb4900f1b7fde66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d06c9d5c2ea8de080bab65d74def8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphcompoundpcqheap_8h.html#a64d06c9d5c2ea8de080bab65d74def8d">SPHCompoundPCQFreeNoLock</a> (<a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a> heap, <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> free_block)</td></tr>
<tr class="memdesc:a64d06c9d5c2ea8de080bab65d74def8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the allocated SPH PCQueue <em>free_block</em> from SAS Compound Heap <em>heap</em>.  <a href="#a64d06c9d5c2ea8de080bab65d74def8d">More...</a><br /></td></tr>
<tr class="separator:a64d06c9d5c2ea8de080bab65d74def8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Address Space Compound Heap, PCQueue extension. </p>
<p>This API extends the basic heap of heaps (CompoundHeap) concept to allow sub-allocation of collections of other SAS or SPH objects. In this case specifically a SPHSinglePCQueue_t.</p>
<p>The base CompoundHeap allocates SAS blocks to be used as a Heap of other SAS / SPH utility objects, in this case SPHSinglePCQueue_t. This is a useful construct for managing complex data structures while maintaining some storage (cache, page, block segment) affinity. The implementation is based on allocation of sub-heaps and allocating structures "near" an already allocated object (via NearAlloc).</p>
<p>With a Compound Heap it is easy to allocate groups of related SPHSinglePCQueue_t's together from the containing SASCompoundHeap_t using the <a class="el" href="sphcompoundpcqheap_8h.html#ae5a89e785029082ea6a0e15d23d007d4" title="Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space. ">SPHCompoundPCQAlloc()</a> API. This API honors the Load Factor percentage. The Default load factor is 75% (reserving 25% of each block for near allocation) but can be changed via the <a class="el" href="sascompoundheap_8h.html#a86bfc3b27f26529a9d9cf1b91662db4b" title="Set the SAS Compound Heap heap load factor to load. ">SASCompoundHeapSetLoadFactor()</a> API. A load factor of 100% fills each block to capacity.</p>
<dl class="section note"><dt>Note</dt><dd>For 100% load factor, there is no difference between Alloc and NearAlloc.</dd></dl>
<p>Allocatation continues from the current SAS block until the Load Factor is exceeded for that block. The next allocation forces the allocation of a new extended heap block and the PCQueue allocation is satisfied from the new block.</p>
<p>Any remaining space, above the Load Factor, and any subsequence freed heap space is available for near allocation. Subsequent allocations that need good locality to another PCQueue can use the <a class="el" href="sphcompoundpcqheap_8h.html#a29812c49ed1cd45068db58dfbbf8621a" title="Allocate a new SPH PCQueue from SAS Compound Heap nearObj. ">SPHCompoundPCQNearAlloc()</a> API. This API allocates storage from the Compound Heap block nearest that provided (near object) address.</p>
<p>The allocated PCQueues are always a power of two size allocated on a matching power of two boundary. The runtime can always find the containing PCQueue based on the address of any contained structure. The runtime will allocate from the immediate containing Simple heap if free space is available there.</p>
<p>The runtime can also find the containing Compound Heap for any PCQueue allocated from it. This allows a number of extended near allocation schemes. SAS Compound Heaps can be "expanding" or "fixed". Finally the storage associated with entire collection of related data structures allocated from a Compound Heap can be freed for reuse (destroyed) with one call.</p>
<p>If the user needs to manage PCQueues of multiple sizes via this (SPHCompoundPCQ) API then it is necessary to create multiple SASCompoundHeap_t's to allocate from the SASCompoundHeap_t allocating the required PCQueue size.</p>
<p>SASCompoundHeap_t's created via <a class="el" href="sascompoundheap_8h.html#a1a9a8ad76602b7c32ca8e184cdfdaa49" title="Create a new SAS Compound Heap with heap_size size. ">SASCompoundHeapCreate()</a> will allocate the default 4KB (4096 bytes) SPHSinglePCQueue_t. To allocate smaller or larger PCQueues using this (SASCompoundHeap_t) mechanism requires creating CompoundHeaps via <a class="el" href="sascompoundheap_8h.html#ab2f6d7db2770c07eb3e2cc6bd7312398" title="Create a new SAS Compound Heap with heap_size size and page_size page size. ">SASCompoundHeapCreatePageSize()</a>, where the "page_size" parameter will apply to all PCQueues allocated from that specific CompoundHeap. The smallest supported PCQueue size is 512 bytes which is effectively one entry.</p>
<p>The heap_size parameter effects the granularity of extension as the heap expands. A smaller (PCQueue) page_size can be paired with a smaller heap_size while larger page_size should be paired with larger heap_size as appropriate. The heap_size should be a power of 2 multiple of the allocation page_size, between 256 and 4096 times the page_size.</p>
<p>A Compound Heap and the contained complex data structures can be arbitrarily large (up the the limits of the Region size or available disk space). Since SAS blocks are backed by memory mapped files, contained data structures, can be persistent and larger then available system memory.</p>
<p>A new PCQueue can be sub-allocated from a Compound Heap using <a class="el" href="sphcompoundpcqheap_8h.html#ae5a89e785029082ea6a0e15d23d007d4" title="Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space. ">SPHCompoundPCQAlloc</a> or <a class="el" href="sphcompoundpcqheap_8h.html#a29812c49ed1cd45068db58dfbbf8621a" title="Allocate a new SPH PCQueue from SAS Compound Heap nearObj. ">SPHCompoundPCQNearAlloc</a> and freed by using the functions <a class="el" href="sphcompoundpcqheap_8h.html#aeb09753bdb0d3afa0095336690828c46" title="Free the allocated SPH PCQueue block in the SAS Compound Heap heap. ">SPHCompoundPCQFree</a> respectively. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae5a89e785029082ea6a0e15d23d007d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHCompoundPCQAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space. </p>
<p>The sas_type_t of <em>heap</em> must be SAS_RUNTIME_COMPOUNDHEAP. The allocated block is initialized as a SPH PCQueue. The function holds a write lock on the Compound Heap during this operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Handle to the SASCompoundHeap_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created SPHSinglePCQueue_t or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="af4f4fb5e018533a3d901b93570407a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHCompoundPCQAllocNoLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space. </p>
<p>Similar to <a class="el" href="sphcompoundpcqheap_8h.html#ae5a89e785029082ea6a0e15d23d007d4" title="Sub-Allocate a new SPH PCQueue from a SAS Compound Heaps internal space. ">SPHCompoundPCQAlloc</a> but does not take write lock the Compound Heap. This API assumes that the application is holding a write lock on the referenced Compound Heap. This allows an application to batch a group of allocations with less overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Handle to the SASCompoundHeap_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created SPHSinglePCQueue_t or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb09753bdb0d3afa0095336690828c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SPHCompoundPCQFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>free_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the allocated SPH PCQueue <em>block</em> in the SAS Compound Heap <em>heap</em>. </p>
<p>The sas_type_t of <em>heap</em> must be SAS_RUNTIME_COMPOUNDHEAP and the type of <em>free_block</em> must be SAS_RUNTIME_PCQUEUE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Handle to the SASCompoundHeap_t. </td></tr>
    <tr><td class="paramname">free_block</td><td>The created SPHSinglePCQueue_t created from <em>heap</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64d06c9d5c2ea8de080bab65d74def8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SPHCompoundPCQFreeNoLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sascompoundheap_8h.html#a897417a49cbfa744ba641f194e862232">SASCompoundHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>free_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the allocated SPH PCQueue <em>free_block</em> from SAS Compound Heap <em>heap</em>. </p>
<p>Similar to <a class="el" href="sphcompoundpcqheap_8h.html#aeb09753bdb0d3afa0095336690828c46" title="Free the allocated SPH PCQueue block in the SAS Compound Heap heap. ">SPHCompoundPCQFree</a> but does not take write lock the Compound Heap. This API assumes that the application is holding a write lock on the referenced Compound Heap. This allows an application to batch a group of frees with less overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>Handle to the SASCompoundHeap_t. </td></tr>
    <tr><td class="paramname">free_block</td><td>The created SPHSinglePCQueue_t created from <em>heap</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29812c49ed1cd45068db58dfbbf8621a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHCompoundPCQNearAlloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nearObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new SPH PCQueue from SAS Compound Heap <em>nearObj</em>. </p>
<p>The address <em>nearObj</em> is used to find the associated Compound Heap object. The sas_type_t of the heap must be SAS_RUNTIME_COMPOUNDHEAP. The allocated SPH PCQueue is already initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearObj</td><td>Memory address of SASCompoundHeap_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created SPHSinglePCQueue_t or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a66e430e56aa3079d2cb4900f1b7fde66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHCompoundPCQNearAllocNoLock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nearObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new SPH PCQueue from SAS Compound Heap <em>nearObj</em>. </p>
<p>Similar to <a class="el" href="sphcompoundpcqheap_8h.html#a29812c49ed1cd45068db58dfbbf8621a" title="Allocate a new SPH PCQueue from SAS Compound Heap nearObj. ">SPHCompoundPCQNearAlloc</a> but does not take write lock the Compound Heap. This API assumes that the application is holding a write lock on the referenced Compound Heap. This allows an application to batch a group of allocations with less overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearObj</td><td>Memory address within a SASCompoundHeap_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly created SPHSinglePCQueue_t or 0 if an error occurs. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 03:56:04 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
