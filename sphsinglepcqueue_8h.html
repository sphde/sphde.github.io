<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphsinglepcqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphsinglepcqueue.h File Reference</h1>
<p>Shared Persistent Heap, single producer single consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Producer/Consumer queues (SPHSinglePCQueue_t).  
<a href="#_details">More...</a></p>
<code>#include &quot;sastype.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphlfentry_8h_source.html">sphlfentry.h</a>&quot;</code><br/>

<p><a href="sphsinglepcqueue_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a><!-- doxytag: member="sphsinglepcqueue.h::__C__" ref="a4d08a6f74d96b695afefd03854839b83" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ignore this macro behind the curtain <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a781ab21e474af0ea3b860a86429574"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CIRCULAR" ref="a7a781ab21e474af0ea3b860a86429574" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a7a781ab21e474af0ea3b860a86429574">SPHSPCQUEUE_CIRCULAR</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options flag for circular log buffers <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924b07cc571034970d4ea28bbca491d8"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CIRCULAR_WRAPED" ref="a924b07cc571034970d4ea28bbca491d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a924b07cc571034970d4ea28bbca491d8">SPHSPCQUEUE_CIRCULAR_WRAPED</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a2fb397d14405b4b838bb7f3658e2d"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CIRCULAR_NOTFIRST" ref="ad2a2fb397d14405b4b838bb7f3658e2d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ad2a2fb397d14405b4b838bb7f3658e2d">SPHSPCQUEUE_CIRCULAR_NOTFIRST</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped multiple times <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a642cb1d4268c22923d2020f2adc65eca"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CACHE_PREFETCH0" ref="a642cb1d4268c22923d2020f2adc65eca" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca">SPHSPCQUEUE_CACHE_PREFETCH0</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options flag for prefetching the immediate (0 offset) cache-line <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1feb1e9e582e5cff6729b58a5b1b32"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CACHE_PREFETCH1" ref="a0d1feb1e9e582e5cff6729b58a5b1b32" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32">SPHSPCQUEUE_CACHE_PREFETCH1</a>&nbsp;&nbsp;&nbsp;(1&lt;&lt;4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options flag for prefetching the next (line size offset) cache-line <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ae94b033dfdac96391001228e286f678d">SPHSPCQUEUE_CIRCULAR_RESETMASK</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">internal options mask flag used the reset circular log buffers  <a href="#ae94b033dfdac96391001228e286f678d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle to an instance of SPH Lock Free Single Producer, Single Consumer Queue.  <a href="#af9363971fb3b8f26e861ea3259556381"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a71317464ee6566d90229f743fa592bc2">SPHSinglePCQueueInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free PC Queue.  <a href="#a71317464ee6566d90229f743fa592bc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a8964b529f6b623fd69cd70c2a44b4968">SPHSinglePCQueueInitWithStride</a> (void *buf_seg, block_size_t buf_size, unsigned short entry_stride, unsigned int options)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue with a fixed entry stride.  <a href="#a8964b529f6b623fd69cd70c2a44b4968"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a2d61c28b417eba0511afda2118e1c802">SPHSinglePCQueueCreate</a> (block_size_t buf_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue.  <a href="#a2d61c28b417eba0511afda2118e1c802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a0b6f4172f62e63dd1f58fa4b3a40e465">SPHSinglePCQueueCreateWithStride</a> (block_size_t buf_size, unsigned short stride)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue.  <a href="#a0b6f4172f62e63dd1f58fa4b3a40e465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a4a71cbf5aa12760a3345b65c575b6767">SPHSinglePCQueueAllocRaw</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> log)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the Producer thread to return the address of a (raw) queue entry allocated from the specified Single Producer Single Consumer Queue.  <a href="#a4a71cbf5aa12760a3345b65c575b6767"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#af55c66d0458e5d9fbdc2ead764e83066">SPHSinglePCQueueAllocStrideEntry</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int catcode, int subcode, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#af55c66d0458e5d9fbdc2ead764e83066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a5feb920a326d1ef35d7dd385382b1fcb">SPHSinglePCQueueAllocStrideTimeStamped</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int catcode, int subcode, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header, of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#a5feb920a326d1ef35d7dd385382b1fcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ae1b8220b8aeb6e15f56ab020cdaa4c30">SPHSinglePCQueueEntryComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *entryhandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to mark the queue entry, specified by the entry handle, as complete. This makes the queue entry accessible to the consumer thread.  <a href="#ae1b8220b8aeb6e15f56ab020cdaa4c30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ab04df5cfeb1e1e90f19c204d62b05448">SPHSinglePCQueueEntryIsComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *entryhandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#ab04df5cfeb1e1e90f19c204d62b05448"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#afb9f8471b965fb6cec520cd2e8a2bb7b">SPHSinglePCQueueGetNextComplete</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#afb9f8471b965fb6cec520cd2e8a2bb7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a65d897ebd4616565e77826c92d437c28">SPHSinglePCQueueFreeNextEntry</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue.  <a href="#a65d897ebd4616565e77826c92d437c28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a7a2abb7a5793b89944147e62c74b8a72">SPHSinglePCQueueEmpty</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#a7a2abb7a5793b89944147e62c74b8a72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ block_size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a9f0e526616505bea3f157a17084c16cb">SPHSinglePCQueueFreeSpace</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the amount of free space (in bytes) remaining in the specified queue.  <a href="#a9f0e526616505bea3f157a17084c16cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ab91dd528f2120d4c85b030ac023acabf">SPHSinglePCQueueFull</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#ab91dd528f2120d4c85b030ac023acabf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a669dbfbff424877591d8f95acde1109d">SPHSinglePCQueueResetAsync</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the specific queue to empty state asynchronously (without locking or atomic updates).  <a href="#a669dbfbff424877591d8f95acde1109d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a764cdb458d0ca22877d78c848087763b">SPHSinglePCQueuePrefetch</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefetch pages from the specific queue.  <a href="#a764cdb458d0ca22877d78c848087763b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a27cae0ca8e692b2cfeafe28f09ea03f9">SPHSinglePCQueueSetCachePrefetch</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int prefetch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the cache-line prefetch options for entry allocate.  <a href="#a27cae0ca8e692b2cfeafe28f09ea03f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ad56017a9e9ac06fcce3d6056ea895f4c">SPHSinglePCQueueDestroy</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the queue and frees the SAS storage for reuse.  <a href="#ad56017a9e9ac06fcce3d6056ea895f4c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, single producer single consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Producer/Consumer queues (SPHSinglePCQueue_t). </p>
<p>! This API supports atomic allocation of storage for queue entries for zero copy persistence and sharing. Zero copy queues divides the process of producing a queue entry in to three steps:</p>
<ul>
<li>Allocate the queue entry (and initialize the header)</li>
<li>Use the return entry handle to fill in application specific data.</li>
<li>Marks the entry complete in the header.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a>&gt;</span>
<a class="code" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle.">SPHLFEntryHandle_t</a> *handle, handle0;
<span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {
        <span class="keywordtype">double</span>  field0;
        <span class="keywordtype">int</span>             field1;
        <span class="keywordtype">int</span>             field2;
        <span class="keywordtype">void</span>    *field3;
        } data_struct11;

        <span class="comment">// Allocate zero copy queue entry</span>
        handle = <a class="code" href="sphsinglepcqueue_8h.html#af55c66d0458e5d9fbdc2ead764e83066" title="Allows the producer thread to allocate and initialize the header of a queue entry...">SPHSinglePCQueueAllocStrideEntry</a> (pcqueue, CAT_CODE, SUBCAT_CODE, &amp;handle0);
        <span class="keywordflow">if</span> (handle)
        {       <span class="comment">// insert data into the allocated queue entry</span>
                data_struct11 *struct_ptr;
                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#a1afe6913e6b64d4e4a006695b759430b" title="Insert a void* at the next free location within the entry.">SPHLFEntryAddPtr</a> (handle, (<span class="keywordtype">void</span>*) sas_data_buff)
                {
                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddPtr(%p, sas_data_buff) failed)\n&quot;</span>,
                                   handle);
                }
                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#a25bbffc19aa5877863d48298db6bc679" title="Insert a int at the next free location within the entry.">SPHLFEntryAddInt</a> (handle, data_int1))
                {
                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddInt(%p, data_int1) failed)\n&quot;</span>,
                                   handle);
                }
                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#a2ee8d6d639c26ce82aaf09edfbd7cef9" title="Insert a C string at the next free location within the entry.">SPHLFEntryAddString</a> (handle, (<span class="keywordtype">char</span>*)data_string1))
                {
                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddString(%p, data_string1) failed)\n&quot;</span>,
                                   handle);
                }

                struct_ptr  = (data_struct11*)<a class="code" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9" title="Macro for using sizeof/__alignof__ parms with SPHLFEntryAllocStruct function.">SPHENTRYALLOCSTRUCT</a> (handle, data_struct11);
                <span class="keywordflow">if</span> (struct_ptr)
                {       <span class="comment">// store struct fields directly into allocated queue entry</span>
                        struct_ptr-&gt;field0 = data_double1;
                        struct_ptr-&gt;field1 = data_int2;
                        struct_ptr-&gt;field2 = data_int3;
                        struct_ptr-&gt;field3 = (<span class="keywordtype">void</span>*)sas_data_buff2;
                } <span class="keywordflow">else</span> {
                        printf(<span class="stringliteral">&quot;error  SPHENTRYALLOCSTRUCT(%p, data_struct11) failed)\n&quot;</span>,
                                   handle);
                }
                <span class="comment">// Mark the entry complete and available to the consumer</span>
                <a class="code" href="sphsinglepcqueue_8h.html#ae1b8220b8aeb6e15f56ab020cdaa4c30" title="Allows the producer thread to mark the queue entry, specified by the entry handle...">SPHSinglePCQueueEntryComplete</a>(handle)
        } <span class="keywordflow">else</span> {
                <span class="keywordflow">while</span> (<a class="code" href="sphsinglepcqueue_8h.html#ab91dd528f2120d4c85b030ac023acabf" title="Return the status of the specified queue.">SPHSinglePCQueueFull</a>(pcqueue))
                {
                        <span class="comment">// pacing code</span>
                }
        }
</pre></div><p>The consumer can access queue entries once they are marked complete. The consumer:</p>
<ul>
<li>checks (spins) for the next allocated entry to become complete.</li>
<li>uses the returned entry handle to directly access the entry contents.</li>
<li>When done processing the queue entry, it marks the entry header invalid and deallocates the entry.</li>
<li>This makes the next queue entry available, if any.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a>&gt;</span>
<a class="code" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle.">SPHLFEntryHandle_t</a> *handle, handle0;
<span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {
        <span class="keywordtype">double</span>  field0;
        <span class="keywordtype">int</span>             field1;
        <span class="keywordtype">int</span>             field2;
        <span class="keywordtype">void</span>    *field3;
        } data_struct11;

        <span class="comment">// Get next queue entry</span>
        handle = <a class="code" href="sphsinglepcqueue_8h.html#afb9f8471b965fb6cec520cd2e8a2bb7b" title="Allows the consumer to get the next completed queue entry from the specified single...">SPHSinglePCQueueGetNextComplete</a> (pcqueue, &amp;handle0);
        <span class="keywordflow">if</span> (handle)
        {       <span class="comment">// insert data into the allocated queue entry</span>
                data_struct11 *struct_ptr;
                sas_data_buff = <a class="code" href="sphlfentry_8h.html#abf68d084654b4cf85c56d60270064703" title="Return the next void* from the entry via the current next value pointer. Leading...">SPHLFEntryGetNextPtr</a> (handle);
                <span class="keywordflow">if</span> (!sas_data_buff)
                {
                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddPtr(%p, sas_data_buff) failed)\n&quot;</span>,
                                   handle);
                }
                data_int1 = <a class="code" href="sphlfentry_8h.html#ad2605b057742dd9fc907768e195e9b2b" title="Return the next int from the entry via the current next value pointer. Leading bytes...">SPHLFEntryGetNextInt</a> (handle);
                data_string1 = <a class="code" href="sphlfentry_8h.html#a724c3c121f50d0b528161dad1e6db284" title="Return the pointer to the next C string from the logger entry via the current next...">SPHLFEntryGetNextString</a> (handle);
                <span class="keywordflow">if</span> (data_string1)
                {
                        printf(<span class="stringliteral">&quot;error  SPHLFEntryGetNextString(%p, data_string1) failed)\n&quot;</span>,
                                   handle);
                }

                struct_ptr  = (data_struct11*)<a class="code" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9" title="Macro for using sizeof/__alignof__ parms with SPHLFEntryAllocStruct function.">SPHENTRYALLOCSTRUCT</a> (handle, data_struct11);
                <span class="keywordflow">if</span> (struct_ptr)
                {       <span class="comment">// access struct fields directly from queue entry</span>
                        data_double1    = struct_ptr-&gt;field0;
                        data_int2               = struct_ptr-&gt;field1;
                        data_int3               = struct_ptr-&gt;field2;
                        sas_data_buff2  = struct_ptr-&gt;field3;
                } <span class="keywordflow">else</span> {
                        printf(<span class="stringliteral">&quot;error  SPHENTRYALLOCSTRUCT(%p, data_struct11) failed)\n&quot;</span>,
                                   handle);
                }
                <span class="comment">// Mark the entry free and available for reuse</span>
                <a class="code" href="sphsinglepcqueue_8h.html#a65d897ebd4616565e77826c92d437c28" title="Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete...">SPHSinglePCQueueFreeNextEntry</a>(pcqueue)
        } <span class="keywordflow">else</span> {
                <span class="keywordflow">while</span> (<a class="code" href="sphsinglepcqueue_8h.html#a7a2abb7a5793b89944147e62c74b8a72" title="Return the status of the specified queue.">SPHSinglePCQueueEmpty</a>(pcqueue))
                {
                        <span class="comment">// pacing code</span>
                }
        }
</pre></div><p>In this implementation the allocation of the entry is minimally serialized based on the assumption that only one (producer) thread will be allocating queue entries. Likewise the assumption is that there is only one consumer thread per SPHSinglePCQueue_t instance. This allows independent producer/consumer thread pairs to interact with a queue instance with minimum synchronization and overhead.</p>
<p>As an option the queue entry allocator will fill in a 4 or 16 byte entry header with:</p>
<ul>
<li>Entry status and length.</li>
<li>Entry identifying Category and SubCategory codes.</li>
<li>Process and Thread Ids.</li>
<li>High resolution timestamp.</li>
</ul>
<p>Any additional storage allocated to the entry (after the header) is available for application specific data. This API also provides several mechanisms to store application data including; direct array or structure overlay, and a streams like mechanism. The API provides a completion function (SPHSinglePCQueueEntryComplete) which provides any memory barriers required by the platform and marks the entry complete.</p>
<p>The API support simple circular queues and requires a constant entry stride. A stride that matches or is multiple of the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple queue entries across cores/sockets.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>Additional work will include automatic pacing with Hysteresis</dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ae94b033dfdac96391001228e286f678d"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSPCQUEUE_CIRCULAR_RESETMASK" ref="ae94b033dfdac96391001228e286f678d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPHSPCQUEUE_CIRCULAR_RESETMASK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="sphsinglepcqueue_8h.html#a7a781ab21e474af0ea3b860a86429574" title="internal options flag for circular log buffers">SPHSPCQUEUE_CIRCULAR</a> | \
                <a class="code" href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca" title="internal options flag for prefetching the immediate (0 offset) cache-line">SPHSPCQUEUE_CACHE_PREFETCH0</a> | \
                <a class="code" href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32" title="internal options flag for prefetching the next (line size offset) cache-line">SPHSPCQUEUE_CACHE_PREFETCH1</a>)
</pre></div>
<p>internal options mask flag used the reset circular log buffers </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af9363971fb3b8f26e861ea3259556381"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueue_t" ref="af9363971fb3b8f26e861ea3259556381" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle to an instance of SPH Lock Free Single Producer, Single Consumer Queue. </p>
<p>The type is SAS_RUNTIME_PCQUEUE </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4a71cbf5aa12760a3345b65c575b6767"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueAllocRaw" ref="a4a71cbf5aa12760a3345b65c575b6767" args="(SPHSinglePCQueue_t log)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SPHSinglePCQueueAllocRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>log</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the Producer thread to return the address of a (raw) queue entry allocated from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is rounded up to the next quadword boundary. Mostly for internal use and testing. If the specified queue is full the allocation may fail.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function is primarily for internal testing and should not be used by applications.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>log</em>&nbsp;</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the raw queue Entry is returned if successful, or NULL if unsuccessful. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="af55c66d0458e5d9fbdc2ead764e83066"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueAllocStrideEntry" ref="af55c66d0458e5d9fbdc2ead764e83066" args="(SPHSinglePCQueue_t queue, int catcode, int subcode, SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueAllocStrideEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status, Category, Subcategory, and length are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHSinglePCQueueEntryComplete).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catcode</em>&nbsp;</td><td>Category code to the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subcode</em>&nbsp;</td><td>Subcategory code to the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle.">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle of the initialized queue entry handle, from the handlespace parm, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a5feb920a326d1ef35d7dd385382b1fcb"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueAllocStrideTimeStamped" ref="a5feb920a326d1ef35d7dd385382b1fcb" args="(SPHSinglePCQueue_t queue, int catcode, int subcode, SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueAllocStrideTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header, of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Category, Subcategory, PID, TID and high precision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions.">sphlflogentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHSinglePCQueueEntryComplete).</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catcode</em>&nbsp;</td><td>Category code to the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subcode</em>&nbsp;</td><td>subcategory code to the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle.">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d61c28b417eba0511afda2118e1c802"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueCreate" ref="a2d61c28b417eba0511afda2118e1c802" args="(block_size_t buf_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a PC Queue. The storage block must be power of two in size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6f4172f62e63dd1f58fa4b3a40e465"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueCreateWithStride" ref="a0b6f4172f62e63dd1f58fa4b3a40e465" args="(block_size_t buf_size, unsigned short stride)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueCreateWithStride </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>stride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a Logger. The storage block must be power of two in size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stride</em>&nbsp;</td><td>the stride offset is bytes between allocated entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ad56017a9e9ac06fcce3d6056ea895f4c"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueDestroy" ref="ad56017a9e9ac06fcce3d6056ea895f4c" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys the queue and frees the SAS storage for reuse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a2abb7a5793b89944147e62c74b8a72"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueEmpty" ref="a7a2abb7a5793b89944147e62c74b8a72" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the queue is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b8220b8aeb6e15f56ab020cdaa4c30"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueEntryComplete" ref="ae1b8220b8aeb6e15f56ab020cdaa4c30" args="(SPHLFEntryHandle_t *entryhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entryhandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to mark the queue entry, specified by the entry handle, as complete. This makes the queue entry accessible to the consumer thread. </p>
<p>Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The Producer thread should not touch or modify a queue entry after calling EntryComplete. This is important to both correctness and performance.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entryhandle</em>&nbsp;</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ab04df5cfeb1e1e90f19c204d62b05448"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueEntryIsComplete" ref="ab04df5cfeb1e1e90f19c204d62b05448" args="(SPHLFEntryHandle_t *entryhandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entryhandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entryhandle</em>&nbsp;</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was complete (SPHSinglePCQueueEntryComplete has been called for this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a65d897ebd4616565e77826c92d437c28"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueFreeNextEntry" ref="a65d897ebd4616565e77826c92d437c28" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueFreeNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue. </p>
<p>Mark the current queue tail entry as free (unallocated and invalid) and bump the queue tail pointer to the next entry. If the specified queue is empty or the current tail entry is not yet completed the Free may fail.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The Consumer thread should not touch or modify a queue entry after calling FreeEntry. This is important to both correctness and performance.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True for successful tail free, otherwise indicated failure. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f0e526616505bea3f157a17084c16cb"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueFreeSpace" ref="a9f0e526616505bea3f157a17084c16cb" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ block_size_t SPHSinglePCQueueFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the amount of free space (in bytes) remaining in the specified queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes of free space remaining in the queue buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab91dd528f2120d4c85b030ac023acabf"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueFull" ref="ab91dd528f2120d4c85b030ac023acabf" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the queue is currently full. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="afb9f8471b965fb6cec520cd2e8a2bb7b"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueGetNextComplete" ref="afb9f8471b965fb6cec520cd2e8a2bb7b" args="(SPHSinglePCQueue_t queue, SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueGetNextComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle.">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a71317464ee6566d90229f743fa592bc2"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueInit" ref="a71317464ee6566d90229f743fa592bc2" args="(void *buf_seg, block_size_t buf_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueInit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a shared storage block as a Lock Free PC Queue. </p>
<p>Initialize the specified storage block as Lock Free PC Queue control blocks. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_seg</em>&nbsp;</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a8964b529f6b623fd69cd70c2a44b4968"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueInitWithStride" ref="a8964b529f6b623fd69cd70c2a44b4968" args="(void *buf_seg, block_size_t buf_size, unsigned short entry_stride, unsigned int options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueInitWithStride </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>entry_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue with a fixed entry stride. </p>
<p>Initialize the specified storage block as Lock Free PC Queue control blocks. The stride and control flags are also stored. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_seg</em>&nbsp;</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry_stride</em>&nbsp;</td><td>the stride offset is bytes between allocated entries. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>option bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a764cdb458d0ca22877d78c848087763b"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueuePrefetch" ref="a764cdb458d0ca22877d78c848087763b" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueuePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prefetch pages from the specific queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a669dbfbff424877591d8f95acde1109d"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueResetAsync" ref="a669dbfbff424877591d8f95acde1109d" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueResetAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the specific queue to empty state asynchronously (without locking or atomic updates). </p>
<p>Internal use for testing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a27cae0ca8e692b2cfeafe28f09ea03f9"></a><!-- doxytag: member="sphsinglepcqueue.h::SPHSinglePCQueueSetCachePrefetch" ref="a27cae0ca8e692b2cfeafe28f09ea03f9" args="(SPHSinglePCQueue_t queue, int prefetch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueSetCachePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prefetch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the cache-line prefetch options for entry allocate. </p>
<p>prefetch == 0; No prefetch issued. <br/>
 prefetch == 1; Prefetch the currently allocated cache-line. <br/>
 prefetch == 2; Prefetch the cache-line following the allocated entry. <br/>
 prefetch == 3; Prefetch the current and next cache-lines.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle to a queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefetch</em>&nbsp;</td><td>prefetch option code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Jun 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
