<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphsinglepcqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphsinglepcqueue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, single producer single consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Producer/Consumer queues (SPHSinglePCQueue_t).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sphlfentry_8h_source.html">sphlfentry.h</a>&quot;</code><br />
</div>
<p><a href="sphsinglepcqueue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4d08a6f74d96b695afefd03854839b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr class="memdesc:a4d08a6f74d96b695afefd03854839b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore this macro behind the curtain <br /></td></tr>
<tr class="separator:a4d08a6f74d96b695afefd03854839b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a781ab21e474af0ea3b860a86429574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a781ab21e474af0ea3b860a86429574"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a7a781ab21e474af0ea3b860a86429574">SPHSPCQUEUE_CIRCULAR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a7a781ab21e474af0ea3b860a86429574"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for circular log buffers <br /></td></tr>
<tr class="separator:a7a781ab21e474af0ea3b860a86429574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924b07cc571034970d4ea28bbca491d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924b07cc571034970d4ea28bbca491d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a924b07cc571034970d4ea28bbca491d8">SPHSPCQUEUE_CIRCULAR_WRAPED</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:a924b07cc571034970d4ea28bbca491d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped <br /></td></tr>
<tr class="separator:a924b07cc571034970d4ea28bbca491d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2fb397d14405b4b838bb7f3658e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a2fb397d14405b4b838bb7f3658e2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ad2a2fb397d14405b4b838bb7f3658e2d">SPHSPCQUEUE_CIRCULAR_NOTFIRST</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:ad2a2fb397d14405b4b838bb7f3658e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped multiple times <br /></td></tr>
<tr class="separator:ad2a2fb397d14405b4b838bb7f3658e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642cb1d4268c22923d2020f2adc65eca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a642cb1d4268c22923d2020f2adc65eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca">SPHSPCQUEUE_CACHE_PREFETCH0</a>&#160;&#160;&#160;(1&lt;&lt;3)</td></tr>
<tr class="memdesc:a642cb1d4268c22923d2020f2adc65eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the immediate (0 offset) cache-line <br /></td></tr>
<tr class="separator:a642cb1d4268c22923d2020f2adc65eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1feb1e9e582e5cff6729b58a5b1b32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1feb1e9e582e5cff6729b58a5b1b32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32">SPHSPCQUEUE_CACHE_PREFETCH1</a>&#160;&#160;&#160;(1&lt;&lt;4)</td></tr>
<tr class="memdesc:a0d1feb1e9e582e5cff6729b58a5b1b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the next (line size offset) cache-line <br /></td></tr>
<tr class="separator:a0d1feb1e9e582e5cff6729b58a5b1b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94b033dfdac96391001228e286f678d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ae94b033dfdac96391001228e286f678d">SPHSPCQUEUE_CIRCULAR_RESETMASK</a></td></tr>
<tr class="memdesc:ae94b033dfdac96391001228e286f678d"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options mask flag used the reset circular log buffers  <a href="#ae94b033dfdac96391001228e286f678d">More...</a><br /></td></tr>
<tr class="separator:ae94b033dfdac96391001228e286f678d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af9363971fb3b8f26e861ea3259556381"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a></td></tr>
<tr class="memdesc:af9363971fb3b8f26e861ea3259556381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an instance of SPH Lock Free Single Producer, Single Consumer Queue.  <a href="#af9363971fb3b8f26e861ea3259556381">More...</a><br /></td></tr>
<tr class="separator:af9363971fb3b8f26e861ea3259556381"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a71317464ee6566d90229f743fa592bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a71317464ee6566d90229f743fa592bc2">SPHSinglePCQueueInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr class="memdesc:a71317464ee6566d90229f743fa592bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free PC Queue.  <a href="#a71317464ee6566d90229f743fa592bc2">More...</a><br /></td></tr>
<tr class="separator:a71317464ee6566d90229f743fa592bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8964b529f6b623fd69cd70c2a44b4968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a8964b529f6b623fd69cd70c2a44b4968">SPHSinglePCQueueInitWithStride</a> (void *buf_seg, block_size_t buf_size, unsigned short entry_stride, unsigned int options)</td></tr>
<tr class="memdesc:a8964b529f6b623fd69cd70c2a44b4968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue with a fixed entry stride.  <a href="#a8964b529f6b623fd69cd70c2a44b4968">More...</a><br /></td></tr>
<tr class="separator:a8964b529f6b623fd69cd70c2a44b4968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d61c28b417eba0511afda2118e1c802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a2d61c28b417eba0511afda2118e1c802">SPHSinglePCQueueCreate</a> (block_size_t buf_size)</td></tr>
<tr class="memdesc:a2d61c28b417eba0511afda2118e1c802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue.  <a href="#a2d61c28b417eba0511afda2118e1c802">More...</a><br /></td></tr>
<tr class="separator:a2d61c28b417eba0511afda2118e1c802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f4172f62e63dd1f58fa4b3a40e465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a0b6f4172f62e63dd1f58fa4b3a40e465">SPHSinglePCQueueCreateWithStride</a> (block_size_t buf_size, unsigned short stride)</td></tr>
<tr class="memdesc:a0b6f4172f62e63dd1f58fa4b3a40e465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue.  <a href="#a0b6f4172f62e63dd1f58fa4b3a40e465">More...</a><br /></td></tr>
<tr class="separator:a0b6f4172f62e63dd1f58fa4b3a40e465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276a63d13148199d5977937a59473dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ad276a63d13148199d5977937a59473dc">SPHSinglePCQueueGetStride</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:ad276a63d13148199d5977937a59473dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry stride for an existing Lock Free Single Producer Single Consumer Queue.  <a href="#ad276a63d13148199d5977937a59473dc">More...</a><br /></td></tr>
<tr class="separator:ad276a63d13148199d5977937a59473dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f898e177d984050531e04a17d956e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a9f898e177d984050531e04a17d956e11">SPHSinglePCQueueAllocRaw</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a9f898e177d984050531e04a17d956e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the Producer thread to return the address of a (raw) queue entry allocated from the specified Single Producer Single Consumer Queue.  <a href="#a9f898e177d984050531e04a17d956e11">More...</a><br /></td></tr>
<tr class="separator:a9f898e177d984050531e04a17d956e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55c66d0458e5d9fbdc2ead764e83066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#af55c66d0458e5d9fbdc2ead764e83066">SPHSinglePCQueueAllocStrideEntry</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int catcode, int subcode, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:af55c66d0458e5d9fbdc2ead764e83066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#af55c66d0458e5d9fbdc2ead764e83066">More...</a><br /></td></tr>
<tr class="separator:af55c66d0458e5d9fbdc2ead764e83066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feb920a326d1ef35d7dd385382b1fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a5feb920a326d1ef35d7dd385382b1fcb">SPHSinglePCQueueAllocStrideTimeStamped</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int catcode, int subcode, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a5feb920a326d1ef35d7dd385382b1fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header, of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#a5feb920a326d1ef35d7dd385382b1fcb">More...</a><br /></td></tr>
<tr class="separator:a5feb920a326d1ef35d7dd385382b1fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b8220b8aeb6e15f56ab020cdaa4c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ae1b8220b8aeb6e15f56ab020cdaa4c30">SPHSinglePCQueueEntryComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *entryhandle)</td></tr>
<tr class="memdesc:ae1b8220b8aeb6e15f56ab020cdaa4c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to mark the queue entry, specified by the entry handle, as complete. This makes the queue entry accessible to the consumer thread.  <a href="#ae1b8220b8aeb6e15f56ab020cdaa4c30">More...</a><br /></td></tr>
<tr class="separator:ae1b8220b8aeb6e15f56ab020cdaa4c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04df5cfeb1e1e90f19c204d62b05448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ab04df5cfeb1e1e90f19c204d62b05448">SPHSinglePCQueueEntryIsComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *entryhandle)</td></tr>
<tr class="memdesc:ab04df5cfeb1e1e90f19c204d62b05448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#ab04df5cfeb1e1e90f19c204d62b05448">More...</a><br /></td></tr>
<tr class="separator:ab04df5cfeb1e1e90f19c204d62b05448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f8471b965fb6cec520cd2e8a2bb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#afb9f8471b965fb6cec520cd2e8a2bb7b">SPHSinglePCQueueGetNextComplete</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:afb9f8471b965fb6cec520cd2e8a2bb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#afb9f8471b965fb6cec520cd2e8a2bb7b">More...</a><br /></td></tr>
<tr class="separator:afb9f8471b965fb6cec520cd2e8a2bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d897ebd4616565e77826c92d437c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a65d897ebd4616565e77826c92d437c28">SPHSinglePCQueueFreeNextEntry</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a65d897ebd4616565e77826c92d437c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue.  <a href="#a65d897ebd4616565e77826c92d437c28">More...</a><br /></td></tr>
<tr class="separator:a65d897ebd4616565e77826c92d437c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2abb7a5793b89944147e62c74b8a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a7a2abb7a5793b89944147e62c74b8a72">SPHSinglePCQueueEmpty</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a7a2abb7a5793b89944147e62c74b8a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#a7a2abb7a5793b89944147e62c74b8a72">More...</a><br /></td></tr>
<tr class="separator:a7a2abb7a5793b89944147e62c74b8a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0e526616505bea3f157a17084c16cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a9f0e526616505bea3f157a17084c16cb">SPHSinglePCQueueFreeSpace</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a9f0e526616505bea3f157a17084c16cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of free space (in bytes) remaining in the specified queue.  <a href="#a9f0e526616505bea3f157a17084c16cb">More...</a><br /></td></tr>
<tr class="separator:a9f0e526616505bea3f157a17084c16cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91dd528f2120d4c85b030ac023acabf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ab91dd528f2120d4c85b030ac023acabf">SPHSinglePCQueueFull</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:ab91dd528f2120d4c85b030ac023acabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified queue.  <a href="#ab91dd528f2120d4c85b030ac023acabf">More...</a><br /></td></tr>
<tr class="separator:ab91dd528f2120d4c85b030ac023acabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669dbfbff424877591d8f95acde1109d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a669dbfbff424877591d8f95acde1109d">SPHSinglePCQueueResetAsync</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a669dbfbff424877591d8f95acde1109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the specific queue to empty state asynchronously (without locking or atomic updates).  <a href="#a669dbfbff424877591d8f95acde1109d">More...</a><br /></td></tr>
<tr class="separator:a669dbfbff424877591d8f95acde1109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764cdb458d0ca22877d78c848087763b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a764cdb458d0ca22877d78c848087763b">SPHSinglePCQueuePrefetch</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a764cdb458d0ca22877d78c848087763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch pages from the specific queue.  <a href="#a764cdb458d0ca22877d78c848087763b">More...</a><br /></td></tr>
<tr class="separator:a764cdb458d0ca22877d78c848087763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cae0ca8e692b2cfeafe28f09ea03f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#a27cae0ca8e692b2cfeafe28f09ea03f9">SPHSinglePCQueueSetCachePrefetch</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, int prefetch)</td></tr>
<tr class="memdesc:a27cae0ca8e692b2cfeafe28f09ea03f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache-line prefetch options for entry allocate.  <a href="#a27cae0ca8e692b2cfeafe28f09ea03f9">More...</a><br /></td></tr>
<tr class="separator:a27cae0ca8e692b2cfeafe28f09ea03f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56017a9e9ac06fcce3d6056ea895f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphsinglepcqueue_8h.html#ad56017a9e9ac06fcce3d6056ea895f4c">SPHSinglePCQueueDestroy</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:ad56017a9e9ac06fcce3d6056ea895f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the queue and frees the SAS storage for reuse.  <a href="#ad56017a9e9ac06fcce3d6056ea895f4c">More...</a><br /></td></tr>
<tr class="separator:ad56017a9e9ac06fcce3d6056ea895f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, single producer single consumer queue. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Producer/Consumer queues (SPHSinglePCQueue_t). </p>
<p>! This API supports atomic allocation of storage for queue entries for zero copy persistence and sharing. Zero copy queues divides the process of producing a queue entry in to three steps:</p><ul>
<li>Allocate the queue entry (and initialize the header)</li>
<li>Use the return entry handle to fill in application specific data.</li>
<li>Marks the entry complete in the header.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html">sphlfentry.h</a>&gt;</span></div>
<div class="line"><a class="code" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, handle0;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {</div>
<div class="line">        <span class="keywordtype">double</span>  field0;</div>
<div class="line">        <span class="keywordtype">int</span>             field1;</div>
<div class="line">        <span class="keywordtype">int</span>             field2;</div>
<div class="line">        <span class="keywordtype">void</span>    *field3;</div>
<div class="line">        } data_struct11;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate zero copy queue entry</span></div>
<div class="line">        handle = <a class="code" href="sphsinglepcqueue_8h.html#af55c66d0458e5d9fbdc2ead764e83066">SPHSinglePCQueueAllocStrideEntry</a> (pcqueue, CAT_CODE, SUBCAT_CODE, &amp;handle0);</div>
<div class="line">        <span class="keywordflow">if</span> (handle)</div>
<div class="line">        {       <span class="comment">// insert data into the allocated queue entry</span></div>
<div class="line">                data_struct11 *struct_ptr;</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#ae56d8ea3f911b29b878ab18dad4b8394">SPHLFEntryAddPtr</a> (handle, (<span class="keywordtype">void</span>*) sas_data_buff)</div>
<div class="line">                {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddPtr(%p, sas_data_buff) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#aa2a87a1a328074acf50e9ff2bf68f691">SPHLFEntryAddInt</a> (handle, data_int1))</div>
<div class="line">                {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddInt(%p, data_int1) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code" href="sphlfentry_8h.html#a73d6d71e1b5ef577abe13ac630fdb186">SPHLFEntryAddString</a> (handle, (<span class="keywordtype">char</span>*)data_string1))</div>
<div class="line">                {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddString(%p, data_string1) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                struct_ptr  = (data_struct11*)<a class="code" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9">SPHENTRYALLOCSTRUCT</a> (handle, data_struct11);</div>
<div class="line">                <span class="keywordflow">if</span> (struct_ptr)</div>
<div class="line">                {       <span class="comment">// store struct fields directly into allocated queue entry</span></div>
<div class="line">                        struct_ptr-&gt;field0 = data_double1;</div>
<div class="line">                        struct_ptr-&gt;field1 = data_int2;</div>
<div class="line">                        struct_ptr-&gt;field2 = data_int3;</div>
<div class="line">                        struct_ptr-&gt;field3 = (<span class="keywordtype">void</span>*)sas_data_buff2;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHENTRYALLOCSTRUCT(%p, data_struct11) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Mark the entry complete and available to the consumer</span></div>
<div class="line">                <a class="code" href="sphsinglepcqueue_8h.html#ae1b8220b8aeb6e15f56ab020cdaa4c30">SPHSinglePCQueueEntryComplete</a>(handle)</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">while</span> (<a class="code" href="sphsinglepcqueue_8h.html#ab91dd528f2120d4c85b030ac023acabf">SPHSinglePCQueueFull</a>(pcqueue))</div>
<div class="line">                {</div>
<div class="line">                        <span class="comment">// pacing code</span></div>
<div class="line">                }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>The consumer can access queue entries once they are marked complete. The consumer:</p><ul>
<li>checks (spins) for the next allocated entry to become complete.</li>
<li>uses the returned entry handle to directly access the entry contents.</li>
<li>When done processing the queue entry, it marks the entry header invalid and deallocates the entry.</li>
<li>This makes the next queue entry available, if any.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphlfentry_8h.html">sphlfentry.h</a>&gt;</span></div>
<div class="line"><a class="code" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, handle0;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>data_struct11 {</div>
<div class="line">        <span class="keywordtype">double</span>  field0;</div>
<div class="line">        <span class="keywordtype">int</span>             field1;</div>
<div class="line">        <span class="keywordtype">int</span>             field2;</div>
<div class="line">        <span class="keywordtype">void</span>    *field3;</div>
<div class="line">        } data_struct11;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get next queue entry</span></div>
<div class="line">        handle = <a class="code" href="sphsinglepcqueue_8h.html#afb9f8471b965fb6cec520cd2e8a2bb7b">SPHSinglePCQueueGetNextComplete</a> (pcqueue, &amp;handle0);</div>
<div class="line">        <span class="keywordflow">if</span> (handle)</div>
<div class="line">        {       <span class="comment">// insert data into the allocated queue entry</span></div>
<div class="line">                data_struct11 *struct_ptr;</div>
<div class="line">                sas_data_buff = <a class="code" href="sphlfentry_8h.html#add441d7f48e2f00a54b752671fdf69d3">SPHLFEntryGetNextPtr</a> (handle);</div>
<div class="line">                <span class="keywordflow">if</span> (!sas_data_buff)</div>
<div class="line">                {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHLFEntryAddPtr(%p, sas_data_buff) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line">                data_int1 = <a class="code" href="sphlfentry_8h.html#a07cbb1ba2cb5b655b7528e178c7acbaa">SPHLFEntryGetNextInt</a> (handle);</div>
<div class="line">                data_string1 = <a class="code" href="sphlfentry_8h.html#a3206a649e7562df0e25830eae258080f">SPHLFEntryGetNextString</a> (handle);</div>
<div class="line">                <span class="keywordflow">if</span> (data_string1)</div>
<div class="line">                {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHLFEntryGetNextString(%p, data_string1) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                struct_ptr  = (data_struct11*)<a class="code" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9">SPHENTRYALLOCSTRUCT</a> (handle, data_struct11);</div>
<div class="line">                <span class="keywordflow">if</span> (struct_ptr)</div>
<div class="line">                {       <span class="comment">// access struct fields directly from queue entry</span></div>
<div class="line">                        data_double1    = struct_ptr-&gt;field0;</div>
<div class="line">                        data_int2               = struct_ptr-&gt;field1;</div>
<div class="line">                        data_int3               = struct_ptr-&gt;field2;</div>
<div class="line">                        sas_data_buff2  = struct_ptr-&gt;field3;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                        printf(<span class="stringliteral">&quot;error  SPHENTRYALLOCSTRUCT(%p, data_struct11) failed)\n&quot;</span>,</div>
<div class="line">                                   handle);</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Mark the entry free and available for reuse</span></div>
<div class="line">                <a class="code" href="sphsinglepcqueue_8h.html#a65d897ebd4616565e77826c92d437c28">SPHSinglePCQueueFreeNextEntry</a>(pcqueue)</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">while</span> (<a class="code" href="sphsinglepcqueue_8h.html#a7a2abb7a5793b89944147e62c74b8a72">SPHSinglePCQueueEmpty</a>(pcqueue))</div>
<div class="line">                {</div>
<div class="line">                        <span class="comment">// pacing code</span></div>
<div class="line">                }</div>
<div class="line">        }</div>
</div><!-- fragment --><p>In this implementation the allocation of the entry is minimally serialized based on the assumption that only one (producer) thread will be allocating queue entries. Likewise the assumption is that there is only one consumer thread per SPHSinglePCQueue_t instance. This allows independent producer/consumer thread pairs to interact with a queue instance with minimum synchronization and overhead.</p>
<p>As an option the queue entry allocator will fill in a 4 or 16 byte entry header with:</p><ul>
<li>Entry status and length.</li>
<li>Entry identifying Category and SubCategory codes.</li>
<li>Process and Thread Ids.</li>
<li>High resolution timestamp.</li>
</ul>
<p>Any additional storage allocated to the entry (after the header) is available for application specific data. This API also provides several mechanisms to store application data including; direct array or structure overlay, and a streams like mechanism. The API provides a completion function (SPHSinglePCQueueEntryComplete) which provides any memory barriers required by the platform and marks the entry complete.</p>
<p>The API support simple circular queues and requires a constant entry stride. A stride that matches or is multiple of the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple queue entries across cores/sockets.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>Additional work will include automatic pacing with Hysteresis</dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae94b033dfdac96391001228e286f678d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPHSPCQUEUE_CIRCULAR_RESETMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="sphsinglepcqueue_8h.html#a7a781ab21e474af0ea3b860a86429574">SPHSPCQUEUE_CIRCULAR</a> | <a class="code" href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca">\</a></div>
<div class="line"><a class="code" href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca">		SPHSPCQUEUE_CACHE_PREFETCH0</a> | <a class="code" href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32">\</a></div>
<div class="line"><a class="code" href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32">		SPHSPCQUEUE_CACHE_PREFETCH1</a>)</div>
<div class="ttc" id="sphsinglepcqueue_8h_html_a0d1feb1e9e582e5cff6729b58a5b1b32"><div class="ttname"><a href="sphsinglepcqueue_8h.html#a0d1feb1e9e582e5cff6729b58a5b1b32">SPHSPCQUEUE_CACHE_PREFETCH1</a></div><div class="ttdeci">#define SPHSPCQUEUE_CACHE_PREFETCH1</div><div class="ttdoc">internal options flag for prefetching the next (line size offset) cache-line </div><div class="ttdef"><b>Definition:</b> sphsinglepcqueue.h:201</div></div>
<div class="ttc" id="sphsinglepcqueue_8h_html_a642cb1d4268c22923d2020f2adc65eca"><div class="ttname"><a href="sphsinglepcqueue_8h.html#a642cb1d4268c22923d2020f2adc65eca">SPHSPCQUEUE_CACHE_PREFETCH0</a></div><div class="ttdeci">#define SPHSPCQUEUE_CACHE_PREFETCH0</div><div class="ttdoc">internal options flag for prefetching the immediate (0 offset) cache-line </div><div class="ttdef"><b>Definition:</b> sphsinglepcqueue.h:199</div></div>
<div class="ttc" id="sphsinglepcqueue_8h_html_a7a781ab21e474af0ea3b860a86429574"><div class="ttname"><a href="sphsinglepcqueue_8h.html#a7a781ab21e474af0ea3b860a86429574">SPHSPCQUEUE_CIRCULAR</a></div><div class="ttdeci">#define SPHSPCQUEUE_CIRCULAR</div><div class="ttdoc">internal options flag for circular log buffers </div><div class="ttdef"><b>Definition:</b> sphsinglepcqueue.h:193</div></div>
</div><!-- fragment -->
<p>internal options mask flag used the reset circular log buffers </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af9363971fb3b8f26e861ea3259556381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an instance of SPH Lock Free Single Producer, Single Consumer Queue. </p>
<p>The type is SAS_RUNTIME_PCQUEUE </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9f898e177d984050531e04a17d956e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHSinglePCQueueAllocRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the Producer thread to return the address of a (raw) queue entry allocated from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is rounded up to the next quadword boundary. Mostly for internal use and testing. If the specified queue is full the allocation may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is primarily for internal testing and should not be used by applications.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the raw entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="af55c66d0458e5d9fbdc2ead764e83066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueAllocStrideEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status, Category, Subcategory, and length are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHSinglePCQueueEntryComplete).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>Subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle. ">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized queue entry handle, from the handlespace parm, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a5feb920a326d1ef35d7dd385382b1fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueAllocStrideTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header, of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Category, Subcategory, PID, TID and high precision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHSinglePCQueueEntryComplete).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle. ">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d61c28b417eba0511afda2118e1c802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a PC Queue. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6f4172f62e63dd1f58fa4b3a40e465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueCreateWithStride </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue. </p>
<p>Allocate a block from SAS storage and initialize that block block as a Logger. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ad56017a9e9ac06fcce3d6056ea895f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the queue and frees the SAS storage for reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a2abb7a5793b89944147e62c74b8a72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b8220b8aeb6e15f56ab020cdaa4c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>entryhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to mark the queue entry, specified by the entry handle, as complete. This makes the queue entry accessible to the consumer thread. </p>
<p>Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Producer thread should not touch or modify a queue entry after calling EntryComplete. This is important to both correctness and performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryhandle</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ab04df5cfeb1e1e90f19c204d62b05448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>entryhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryhandle</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHSinglePCQueueEntryComplete has been called for this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a65d897ebd4616565e77826c92d437c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueFreeNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue. </p>
<p>Mark the current queue tail entry as free (unallocated and invalid) and bump the queue tail pointer to the next entry. If the specified queue is empty or the current tail entry is not yet completed the Free may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Consumer thread should not touch or modify a queue entry after calling FreeEntry. This is important to both correctness and performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for successful tail free, otherwise indicated failure. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f0e526616505bea3f157a17084c16cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t SPHSinglePCQueueFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of free space (in bytes) remaining in the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of free space remaining in the queue buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab91dd528f2120d4c85b030ac023acabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is currently full. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="afb9f8471b965fb6cec520cd2e8a2bb7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a>* SPHSinglePCQueueGetNextComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialized as a <a class="el" href="structSPHLFEntryHandle__t.html" title="Instance of a Lock Free event data Entry Handle. ">SPHLFEntryHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad276a63d13148199d5977937a59473dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueGetStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the entry stride for an existing Lock Free Single Producer Single Consumer Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the entry stride of strided queues, 0 if not strided, or -1 is not a valid SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a71317464ee6566d90229f743fa592bc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Lock Free PC Queue. </p>
<p>Initialize the specified storage block as Lock Free PC Queue control blocks. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a8964b529f6b623fd69cd70c2a44b4968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> SPHSinglePCQueueInitWithStride </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>entry_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Lock Free Single Producer Single Consumer Queue with a fixed entry stride. </p>
<p>Initialize the specified storage block as Lock Free PC Queue control blocks. The stride and control flags are also stored. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_PCQUEUE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">entry_stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
    <tr><td class="paramname">options</td><td>option bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a764cdb458d0ca22877d78c848087763b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueuePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch pages from the specific queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a669dbfbff424877591d8f95acde1109d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueResetAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the specific queue to empty state asynchronously (without locking or atomic updates). </p>
<p>Internal use for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle to a queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a27cae0ca8e692b2cfeafe28f09ea03f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueSetCachePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefetch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache-line prefetch options for entry allocate. </p>
<p>prefetch == 0; No prefetch issued. <br />
 prefetch == 1; Prefetch the currently allocated cache-line. <br />
 prefetch == 2; Prefetch the cache-line following the allocated entry. <br />
 prefetch == 3; Prefetch the current and next cache-lines. </p><pre class="fragment">@param queue Handle to a queue.
@param prefetch prefetch option code.
@return 0 if successful.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 30 2016 07:46:25 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
