<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlfentry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphlfentry.h File Reference</h1>
<p>Shared Persistent Heap, logger/queue etc event entry status, update, and access functions.  
<a href="#_details">More...</a></p>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;sastype.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphtimer_8h_source.html">sphtimer.h</a>&quot;</code><br/>

<p><a href="sphlfentry_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsphLFEntryLayout__t.html">sphLFEntryLayout_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fields defining the entry header details word.  <a href="structsphLFEntryLayout__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsphLFEntry__t.html">sphLFEntry_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of Entry details with 32-bit word for atomic update.  <a href="unionsphLFEntry__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of a Lock Free Entry Header.  <a href="structSPHLFEntryHeader__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of a Lock Free event data Entry Handle.  <a href="structSPHLFEntryHandle__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c9d1c70de776ad386550278bab8cea"></a><!-- doxytag: member="sphlfentry.h::SPHENTRYGETSTRUCTPTR" ref="af5c9d1c70de776ad386550278bab8cea" args="(__handle, __struct)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#af5c9d1c70de776ad386550278bab8cea">SPHENTRYGETSTRUCTPTR</a>(__handle, __struct)&nbsp;&nbsp;&nbsp;SPHLFEntryGetStructPtr(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFEntryGetStructPtr function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa10065e2068f0eec2183db350bdedfc9"></a><!-- doxytag: member="sphlfentry.h::SPHENTRYALLOCSTRUCT" ref="aa10065e2068f0eec2183db350bdedfc9" args="(__handle, __struct)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9">SPHENTRYALLOCSTRUCT</a>(__handle, __struct)&nbsp;&nbsp;&nbsp;SPHLFEntryAllocStruct(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFEntryAllocStruct function. <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e89948a0b6d5380f0dd2a41b945dc26"></a><!-- doxytag: member="sphlfentry.h::longPtr_t" ref="a9e89948a0b6d5380f0dd2a41b945dc26" args="" -->
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unsigned int type, consistent with the size of a pointer and used for pointer calculations <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68e60b0ae114451f6f34dde2f0a2a94e"></a><!-- doxytag: member="sphlfentry.h::sphLFEntryID_t" ref="a68e60b0ae114451f6f34dde2f0a2a94e" args="" -->
typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aggregate type for handling <a class="el" href="structsphLogEntryLayout__t.html" title="sphLogEntry_t. Fields defining the entry details word.">sphLogEntryLayout_t</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85dc2178807f9e94405281afc0acdff6"></a><!-- doxytag: member="sphlfentry.h::sphpid16_t" ref="a85dc2178807f9e94405281afc0acdff6" args="" -->
typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common type for PID/TID values stored in event entries. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#afb9a4e93945f9dbe86b280bb46c684ca">SPHLFEntryStrongComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.  <a href="#afb9a4e93945f9dbe86b280bb46c684ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a3052fc2a29adc1f2399b639d64b6dc3e">SPHLFEntryWeakComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads.  <a href="#a3052fc2a29adc1f2399b639d64b6dc3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ab4f0490fd573268981e663376dea9dab">SPHLFEntryComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads.  <a href="#ab4f0490fd573268981e663376dea9dab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a825c822dfc17bfe82f266050f0260550">SPHLFEntryIsComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#a825c822dfc17bfe82f266050f0260550"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ae90b6a7e1e217e2e7daf51871f82ec79">SPHLFEntryIsTimestamped</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#ae90b6a7e1e217e2e7daf51871f82ec79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a14b18eb5098a5aaebcde8e813d54294e">SPHLFEntryTimeStamp</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the time stamp value for the entry specified by the entry handle.  <a href="#a14b18eb5098a5aaebcde8e813d54294e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a1d19f8c1a10306fe0a0e2854f639ff87">SPHLFEntryPID</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the process ID for the entry specified by the entry handle.  <a href="#a1d19f8c1a10306fe0a0e2854f639ff87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a8ee7a3384a497c571ec939595b81361c">SPHLFEntryTID</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the thread ID for the entry specified by the entry handle.  <a href="#a8ee7a3384a497c571ec939595b81361c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a8288be37352da5c6806ffa96460a05ae">SPHLFEntryHeader</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address for the entry header specified by the entry handle.  <a href="#a8288be37352da5c6806ffa96460a05ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa90a152505640030fcc2c31944b7561c">SPHLFEntryCategory</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry category for the entry specified by the entry handle.  <a href="#aa90a152505640030fcc2c31944b7561c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa6f8e328cc3e33d48f65c43dcc330e5c">SPHLFEntrySubcat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the entry handle.  <a href="#aa6f8e328cc3e33d48f65c43dcc330e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a9fc0c1889e144b8685a0d29fb2e0ce2b">SPHLFEntryGetFreePtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address first free byte for the entry specified by the entry handle.  <a href="#a9fc0c1889e144b8685a0d29fb2e0ce2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#acdc805c726caece2e847454ca1f0ca71">SPHLFEntryGetStructPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the correctly aligned pointer for a struct or array starting at the next free location within the entry.  <a href="#acdc805c726caece2e847454ca1f0ca71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ac480455014963810f46dee07cddf6231">SPHLFEntryAllocStruct</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for struct starting at the next free location within the entry.  <a href="#ac480455014963810f46dee07cddf6231"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a2ee8d6d639c26ce82aaf09edfbd7cef9">SPHLFEntryAddString</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, char *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a C string at the next free location within the entry.  <a href="#a2ee8d6d639c26ce82aaf09edfbd7cef9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a2be2e6beb81bf6cba034195e92876623">SPHLFEntryAddChar</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, char value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a character at the next free location within the entry.  <a href="#a2be2e6beb81bf6cba034195e92876623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#af863ebdb0d63192a4e4a8be24215d32a">SPHLFEntryAddShort</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, short int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a short int at the next free location within the entry.  <a href="#af863ebdb0d63192a4e4a8be24215d32a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a25bbffc19aa5877863d48298db6bc679">SPHLFEntryAddInt</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a int at the next free location within the entry.  <a href="#a25bbffc19aa5877863d48298db6bc679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a4fed55a9089edb02fd73cc45cef02e7a">SPHLFEntryAddLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a long int at the next free location within the entry.  <a href="#a4fed55a9089edb02fd73cc45cef02e7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a1afe6913e6b64d4e4a006695b759430b">SPHLFEntryAddPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a void* at the next free location within the entry.  <a href="#a1afe6913e6b64d4e4a006695b759430b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aeb4fe2e34d205dca20c16e2d9ebf3f4c">SPHLFEntryAddLongLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, long long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a long long int at the next free location within the entry.  <a href="#aeb4fe2e34d205dca20c16e2d9ebf3f4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a3573f5c595b75aba3a4a894598c50491">SPHLFEntryAddFloat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, float value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a float at the next free location within the entry.  <a href="#a3573f5c595b75aba3a4a894598c50491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a38da51e8728e9636339ae2b893f3c7e2">SPHLFEntryAddDouble</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, double value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a double at the next free location within the entry.  <a href="#a38da51e8728e9636339ae2b893f3c7e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a29ecc28fc9d392487d52d116ef7120e4">SPHLFEntryGetNextChar</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next char from the entry via the current next value pointer. The internal next value pointer is advanced to the next location.  <a href="#a29ecc28fc9d392487d52d116ef7120e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a724c3c121f50d0b528161dad1e6db284">SPHLFEntryGetNextString</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char.  <a href="#a724c3c121f50d0b528161dad1e6db284"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a08663247c141ca17cb95058bd0425cc2">SPHLFEntryGetNextShort</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next short int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a08663247c141ca17cb95058bd0425cc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ad2605b057742dd9fc907768e195e9b2b">SPHLFEntryGetNextInt</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ad2605b057742dd9fc907768e195e9b2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a0340c0eed5e076fa0134e58b8c040283">SPHLFEntryGetNextLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a0340c0eed5e076fa0134e58b8c040283"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#abf68d084654b4cf85c56d60270064703">SPHLFEntryGetNextPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next void* from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#abf68d084654b4cf85c56d60270064703"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aacc4083c94ebf904182d4c65ac76c48d">SPHLFEntryGetNextLongLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next long long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#aacc4083c94ebf904182d4c65ac76c48d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ab11ed7fbb5f925fb20521bff6a694733">SPHLFEntryGetNextFloat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next float from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ab11ed7fbb5f925fb20521bff6a694733"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a04219861987ca337b3d2ced23f90a375">SPHLFEntryGetNextDouble</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next double from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a04219861987ca337b3d2ced23f90a375"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Steven Munroe - initial API and implementation</dd></dl>
<p>For shared memory multi-thread/multi-core applications. Once the Logger or Queue functions have atomically allocated an entry, the "entry" APIs supports adding additional data to the entry and retrieving that date later.</p>
<p>Supported functions include: storing category specific event data, atomic completion of an entry, Getting entry status (complete and timestamped) Getting entry header elements (timestamp, PID, TID, Category, and Sub-category), Retrieving category specific event data entries, and direct pointer access the header and data of the entry.</p>
<p>This Entry access API supports read out of the 16 byte entry header including: Entry status and length. Entry Category and SubCategory codes. Process and Thread Ids. High resolution timestamp.</p>
<p>Any additional storage allocated to the entry is available for application specific data. This API also provides several mechanisms to store application data including; direct array or structure overlay, and a streams like mechanism. Finally the API provides a completion functions (SPHLFEntryComplete) which provides and memory barriers required by the platform and marks the entry complete. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2be2e6beb81bf6cba034195e92876623"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddChar" ref="a2be2e6beb81bf6cba034195e92876623" args="(SPHLFEntryHandle_t *handle, char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a character at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a char. </dd></dl>

</div>
</div>
<a class="anchor" id="a38da51e8728e9636339ae2b893f3c7e2"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddDouble" ref="a38da51e8728e9636339ae2b893f3c7e2" args="(SPHLFEntryHandle_t *handle, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a double at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a double plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a3573f5c595b75aba3a4a894598c50491"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddFloat" ref="a3573f5c595b75aba3a4a894598c50491" args="(SPHLFEntryHandle_t *handle, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a float at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a float plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a25bbffc19aa5877863d48298db6bc679"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddInt" ref="a25bbffc19aa5877863d48298db6bc679" args="(SPHLFEntryHandle_t *handle, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a int at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fed55a9089edb02fd73cc45cef02e7a"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddLong" ref="a4fed55a9089edb02fd73cc45cef02e7a" args="(SPHLFEntryHandle_t *handle, long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a long int at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb4fe2e34d205dca20c16e2d9ebf3f4c"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddLongLong" ref="aeb4fe2e34d205dca20c16e2d9ebf3f4c" args="(SPHLFEntryHandle_t *handle, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a long long int at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a long long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a1afe6913e6b64d4e4a006695b759430b"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddPtr" ref="a1afe6913e6b64d4e4a006695b759430b" args="(SPHLFEntryHandle_t *handle, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a void* at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a void* (C pointer) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a void* plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="af863ebdb0d63192a4e4a8be24215d32a"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddShort" ref="af863ebdb0d63192a4e4a8be24215d32a" args="(SPHLFEntryHandle_t *handle, short int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a short int at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a short int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a short int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ee8d6d639c26ce82aaf09edfbd7cef9"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAddString" ref="a2ee8d6d639c26ce82aaf09edfbd7cef9" args="(SPHLFEntryHandle_t *handle, char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryAddString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a C string at the next free location within the entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>pointer to a C string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if the string is too large for the remain entry free space. </dd></dl>

</div>
</div>
<a class="anchor" id="ac480455014963810f46dee07cddf6231"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryAllocStruct" ref="ac480455014963810f46dee07cddf6231" args="(SPHLFEntryHandle_t *handle, unsigned long __size, unsigned long __align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryAllocStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__align</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate space for struct starting at the next free location within the entry. </p>
<p>Allocate space in the log entry for a multi-field structure or an array. The returned pointer can then be used to directly store data into struct fields or array entries. The SPHENTRYALLOCSTRUCT can be used to insure the correct usage sizeof and __alignof__ to provide values for the __size and __align parameters.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be used instead of SPHLFEntryGetFreePtr if additional data may be added later to the same entry.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__size</em>&nbsp;</td><td>of the struct/array to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__align</em>&nbsp;</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="aa90a152505640030fcc2c31944b7561c"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryCategory" ref="aa90a152505640030fcc2c31944b7561c" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry category for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4f0490fd573268981e663376dea9dab"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryComplete" ref="ab4f0490fd573268981e663376dea9dab" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fc0c1889e144b8685a0d29fb2e0ce2b"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetFreePtr" ref="a9fc0c1889e144b8685a0d29fb2e0ce2b" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address first free byte for the entry specified by the entry handle. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function should be used carefully. It is not safe to use if other application functions may need to update the same entry. It is also not safe to use for software that needs to cross platform because it does not handle platform specific size and alignment requirements.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The SPHLOGENTRYALLOCSTRUCT/SPHLFlogEntryAllocStruct API is recommended for code that needs to operate cross platform.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ecc28fc9d392487d52d116ef7120e4"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextChar" ref="a29ecc28fc9d392487d52d116ef7120e4" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char SPHLFEntryGetNextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next char from the entry via the current next value pointer. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char value if successful, 0 (NUL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a04219861987ca337b3d2ced23f90a375"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextDouble" ref="a04219861987ca337b3d2ced23f90a375" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SPHLFEntryGetNextDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next double from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the double value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab11ed7fbb5f925fb20521bff6a694733"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextFloat" ref="ab11ed7fbb5f925fb20521bff6a694733" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SPHLFEntryGetNextFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next float from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the float value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2605b057742dd9fc907768e195e9b2b"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextInt" ref="ad2605b057742dd9fc907768e195e9b2b" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryGetNextInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a0340c0eed5e076fa0134e58b8c040283"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextLong" ref="a0340c0eed5e076fa0134e58b8c040283" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long SPHLFEntryGetNextLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aacc4083c94ebf904182d4c65ac76c48d"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextLongLong" ref="aacc4083c94ebf904182d4c65ac76c48d" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SPHLFEntryGetNextLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next long long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long long int value if successful,0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="abf68d084654b4cf85c56d60270064703"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextPtr" ref="abf68d084654b4cf85c56d60270064703" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next void* from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the void* value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a08663247c141ca17cb95058bd0425cc2"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextShort" ref="a08663247c141ca17cb95058bd0425cc2" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short int SPHLFEntryGetNextShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next short int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the short int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a724c3c121f50d0b528161dad1e6db284"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetNextString" ref="a724c3c121f50d0b528161dad1e6db284" args="(SPHLFEntryHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* SPHLFEntryGetNextString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the C string pointer value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="acdc805c726caece2e847454ca1f0ca71"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryGetStructPtr" ref="acdc805c726caece2e847454ca1f0ca71" args="(SPHLFEntryHandle_t *handle, unsigned long __size, unsigned long __align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryGetStructPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__align</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the correctly aligned pointer for a struct or array starting at the next free location within the entry. </p>
<p>The entries next pointer is adjusted for alignment and returned. The entries next pointer and remaining fields are updated for the next field following the struct/array.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The SPHENTRYGETSTRUCTPTR can be used to insure the correct usage sizeof and __alignof__ to provide values for the __size and __align parameters.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__size</em>&nbsp;</td><td>of the struct/array to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__align</em>&nbsp;</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a8288be37352da5c6806ffa96460a05ae"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryHeader" ref="a8288be37352da5c6806ffa96460a05ae" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a>* SPHLFEntryHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address for the entry header specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address from the entry header, if the entry was valid. Otherwise return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a825c822dfc17bfe82f266050f0260550"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryIsComplete" ref="a825c822dfc17bfe82f266050f0260550" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="ae90b6a7e1e217e2e7daf51871f82ec79"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryIsTimestamped" ref="ae90b6a7e1e217e2e7daf51871f82ec79" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d19f8c1a10306fe0a0e2854f639ff87"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryPID" ref="a1d19f8c1a10306fe0a0e2854f639ff87" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFEntryPID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the process ID for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the PID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="afb9a4e93945f9dbe86b280bb46c684ca"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryStrongComplete" ref="afb9a4e93945f9dbe86b280bb46c684ca" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryStrongComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6f8e328cc3e33d48f65c43dcc330e5c"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntrySubcat" ref="aa6f8e328cc3e33d48f65c43dcc330e5c" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntrySubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry sub-category for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee7a3384a497c571ec939595b81361c"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryTID" ref="a8ee7a3384a497c571ec939595b81361c" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFEntryTID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the thread ID for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the TID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a14b18eb5098a5aaebcde8e813d54294e"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryTimeStamp" ref="a14b18eb5098a5aaebcde8e813d54294e" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a> SPHLFEntryTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the time stamp value for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time stamp value from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a3052fc2a29adc1f2399b639d64b6dc3e"></a><!-- doxytag: member="sphlfentry.h::SPHLFEntryWeakComplete" ref="a3052fc2a29adc1f2399b639d64b6dc3e" args="(SPHLFEntryHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryWeakComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Jan 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
