<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlfentry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphlfentry.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, logger/queue etc event entry status, update, and access functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphtimer_8h_source.html">sphtimer.h</a>&quot;</code><br />
</div>
<p><a href="sphlfentry_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsphLFEntryLayout__t.html">sphLFEntryLayout_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fields defining the entry header details word.  <a href="structsphLFEntryLayout__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsphLFEntry__t.html">sphLFEntry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of Entry details with 32-bit word for atomic update.  <a href="unionsphLFEntry__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free Entry Header.  <a href="structSPHLFEntryHeader__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free event data Entry Handle.  <a href="structSPHLFEntryHandle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af5c9d1c70de776ad386550278bab8cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c9d1c70de776ad386550278bab8cea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#af5c9d1c70de776ad386550278bab8cea">SPHENTRYGETSTRUCTPTR</a>(__handle,  __struct)&#160;&#160;&#160;<a class="el" href="sphlfentry_8h.html#ab9428e7b31affd90dfb6427d1c4d9163">SPHLFEntryGetStructPtr</a>(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr class="memdesc:af5c9d1c70de776ad386550278bab8cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFEntryGetStructPtr function. <br /></td></tr>
<tr class="separator:af5c9d1c70de776ad386550278bab8cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10065e2068f0eec2183db350bdedfc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa10065e2068f0eec2183db350bdedfc9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa10065e2068f0eec2183db350bdedfc9">SPHENTRYALLOCSTRUCT</a>(__handle,  __struct)&#160;&#160;&#160;<a class="el" href="sphlfentry_8h.html#a604e0d44ba8cfc31df646e9240a51e5a">SPHLFEntryAllocStruct</a>(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr class="memdesc:aa10065e2068f0eec2183db350bdedfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFEntryAllocStruct function. <br /></td></tr>
<tr class="separator:aa10065e2068f0eec2183db350bdedfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e89948a0b6d5380f0dd2a41b945dc26"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a></td></tr>
<tr class="memdesc:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned int type, consistent with the size of a pointer and used for pointer calculations <br /></td></tr>
<tr class="separator:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e60b0ae114451f6f34dde2f0a2a94e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68e60b0ae114451f6f34dde2f0a2a94e"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a></td></tr>
<tr class="memdesc:a68e60b0ae114451f6f34dde2f0a2a94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate type for handling <a class="el" href="structsphLogEntryLayout__t.html" title="sphLogEntry_t. Fields defining the entry details word. ">sphLogEntryLayout_t</a>. <br /></td></tr>
<tr class="separator:a68e60b0ae114451f6f34dde2f0a2a94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dc2178807f9e94405281afc0acdff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85dc2178807f9e94405281afc0acdff6"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a></td></tr>
<tr class="memdesc:a85dc2178807f9e94405281afc0acdff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common type for PID/TID values stored in event entries. <br /></td></tr>
<tr class="separator:a85dc2178807f9e94405281afc0acdff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2e3092975de97065389e76ed6d7f8d54"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a2e3092975de97065389e76ed6d7f8d54">SPHLFEntryStrongComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a2e3092975de97065389e76ed6d7f8d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.  <a href="#a2e3092975de97065389e76ed6d7f8d54">More...</a><br /></td></tr>
<tr class="separator:a2e3092975de97065389e76ed6d7f8d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23406573bee24c305326e8179e77ea2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ae23406573bee24c305326e8179e77ea2">SPHLFEntryWeakComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:ae23406573bee24c305326e8179e77ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads.  <a href="#ae23406573bee24c305326e8179e77ea2">More...</a><br /></td></tr>
<tr class="separator:ae23406573bee24c305326e8179e77ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6da469b71c6eb116a0fcb4bfc30bba0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa6da469b71c6eb116a0fcb4bfc30bba0">SPHLFEntryComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:aa6da469b71c6eb116a0fcb4bfc30bba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete.  <a href="#aa6da469b71c6eb116a0fcb4bfc30bba0">More...</a><br /></td></tr>
<tr class="separator:aa6da469b71c6eb116a0fcb4bfc30bba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32221a27c10a8462bc5d9f94be5e5e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#abd32221a27c10a8462bc5d9f94be5e5e">SPHLFEntryIsComplete</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:abd32221a27c10a8462bc5d9f94be5e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#abd32221a27c10a8462bc5d9f94be5e5e">More...</a><br /></td></tr>
<tr class="separator:abd32221a27c10a8462bc5d9f94be5e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff8878d2788fd235f5cd2bd56cd6b1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a91ff8878d2788fd235f5cd2bd56cd6b1">SPHLFEntryIsTimestamped</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a91ff8878d2788fd235f5cd2bd56cd6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#a91ff8878d2788fd235f5cd2bd56cd6b1">More...</a><br /></td></tr>
<tr class="separator:a91ff8878d2788fd235f5cd2bd56cd6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c53b3ed6d0b30a6fabe56bb7d71974b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a9c53b3ed6d0b30a6fabe56bb7d71974b">SPHLFEntryTimeStamp</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a9c53b3ed6d0b30a6fabe56bb7d71974b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time stamp value for the entry specified by the entry handle.  <a href="#a9c53b3ed6d0b30a6fabe56bb7d71974b">More...</a><br /></td></tr>
<tr class="separator:a9c53b3ed6d0b30a6fabe56bb7d71974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dedd1b11549464132d616a826db8709"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a0dedd1b11549464132d616a826db8709">SPHLFEntryPID</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a0dedd1b11549464132d616a826db8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the process ID for the entry specified by the entry handle.  <a href="#a0dedd1b11549464132d616a826db8709">More...</a><br /></td></tr>
<tr class="separator:a0dedd1b11549464132d616a826db8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3db3ada0aaf1d5bd47b7dee53a46a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aeb3db3ada0aaf1d5bd47b7dee53a46a2">SPHLFEntryTID</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:aeb3db3ada0aaf1d5bd47b7dee53a46a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread ID for the entry specified by the entry handle.  <a href="#aeb3db3ada0aaf1d5bd47b7dee53a46a2">More...</a><br /></td></tr>
<tr class="separator:aeb3db3ada0aaf1d5bd47b7dee53a46a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a42c865c20cc74deaa6c323ed03057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ae9a42c865c20cc74deaa6c323ed03057">SPHLFEntryHeader</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:ae9a42c865c20cc74deaa6c323ed03057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address for the entry header specified by the entry handle.  <a href="#ae9a42c865c20cc74deaa6c323ed03057">More...</a><br /></td></tr>
<tr class="separator:ae9a42c865c20cc74deaa6c323ed03057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc303dd8d7f1ee41e79e7478c97a32a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#afc303dd8d7f1ee41e79e7478c97a32a1">SPHLFEntryCategory</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:afc303dd8d7f1ee41e79e7478c97a32a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry category for the entry specified by the entry handle.  <a href="#afc303dd8d7f1ee41e79e7478c97a32a1">More...</a><br /></td></tr>
<tr class="separator:afc303dd8d7f1ee41e79e7478c97a32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720a576b05a7819844a9346c1aef3225"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a720a576b05a7819844a9346c1aef3225">SPHLFEntrySubcat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a720a576b05a7819844a9346c1aef3225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the entry handle.  <a href="#a720a576b05a7819844a9346c1aef3225">More...</a><br /></td></tr>
<tr class="separator:a720a576b05a7819844a9346c1aef3225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909897cbbf4ebb491f7c9beca7787059"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a909897cbbf4ebb491f7c9beca7787059">SPHLFEntryGetFreePtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a909897cbbf4ebb491f7c9beca7787059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first free byte address for the entry specified by the entry handle.  <a href="#a909897cbbf4ebb491f7c9beca7787059">More...</a><br /></td></tr>
<tr class="separator:a909897cbbf4ebb491f7c9beca7787059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9428e7b31affd90dfb6427d1c4d9163"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ab9428e7b31affd90dfb6427d1c4d9163">SPHLFEntryGetStructPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr class="memdesc:ab9428e7b31affd90dfb6427d1c4d9163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correctly aligned pointer for a struct or array starting at the next free location within the entry.  <a href="#ab9428e7b31affd90dfb6427d1c4d9163">More...</a><br /></td></tr>
<tr class="separator:ab9428e7b31affd90dfb6427d1c4d9163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604e0d44ba8cfc31df646e9240a51e5a"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a604e0d44ba8cfc31df646e9240a51e5a">SPHLFEntryAllocStruct</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr class="memdesc:a604e0d44ba8cfc31df646e9240a51e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for struct starting at the next free location within the entry.  <a href="#a604e0d44ba8cfc31df646e9240a51e5a">More...</a><br /></td></tr>
<tr class="separator:a604e0d44ba8cfc31df646e9240a51e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d6d71e1b5ef577abe13ac630fdb186"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a73d6d71e1b5ef577abe13ac630fdb186">SPHLFEntryAddString</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, char *value)</td></tr>
<tr class="memdesc:a73d6d71e1b5ef577abe13ac630fdb186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a C string at the next free location within the entry.  <a href="#a73d6d71e1b5ef577abe13ac630fdb186">More...</a><br /></td></tr>
<tr class="separator:a73d6d71e1b5ef577abe13ac630fdb186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50363e24927398050045404712d3789"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ac50363e24927398050045404712d3789">SPHLFEntryAddChar</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, char value)</td></tr>
<tr class="memdesc:ac50363e24927398050045404712d3789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a character at the next free location within the entry.  <a href="#ac50363e24927398050045404712d3789">More...</a><br /></td></tr>
<tr class="separator:ac50363e24927398050045404712d3789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c06bb12b19e12a4ce14b639231bfa1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a32c06bb12b19e12a4ce14b639231bfa1">SPHLFEntryAddShort</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, short int value)</td></tr>
<tr class="memdesc:a32c06bb12b19e12a4ce14b639231bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a short int at the next free location within the entry.  <a href="#a32c06bb12b19e12a4ce14b639231bfa1">More...</a><br /></td></tr>
<tr class="separator:a32c06bb12b19e12a4ce14b639231bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a87a1a328074acf50e9ff2bf68f691"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aa2a87a1a328074acf50e9ff2bf68f691">SPHLFEntryAddInt</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, int value)</td></tr>
<tr class="memdesc:aa2a87a1a328074acf50e9ff2bf68f691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a int at the next free location within the entry.  <a href="#aa2a87a1a328074acf50e9ff2bf68f691">More...</a><br /></td></tr>
<tr class="separator:aa2a87a1a328074acf50e9ff2bf68f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2241d121fbe88427a00c91e757d60ca1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a2241d121fbe88427a00c91e757d60ca1">SPHLFEntryAddLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, long value)</td></tr>
<tr class="memdesc:a2241d121fbe88427a00c91e757d60ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a long int at the next free location within the entry.  <a href="#a2241d121fbe88427a00c91e757d60ca1">More...</a><br /></td></tr>
<tr class="separator:a2241d121fbe88427a00c91e757d60ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56d8ea3f911b29b878ab18dad4b8394"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ae56d8ea3f911b29b878ab18dad4b8394">SPHLFEntryAddPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, void *value)</td></tr>
<tr class="memdesc:ae56d8ea3f911b29b878ab18dad4b8394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a void* at the next free location within the entry.  <a href="#ae56d8ea3f911b29b878ab18dad4b8394">More...</a><br /></td></tr>
<tr class="separator:ae56d8ea3f911b29b878ab18dad4b8394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0533703a54ac3ca2492f3e7a4d8a62cf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a0533703a54ac3ca2492f3e7a4d8a62cf">SPHLFEntryAddLongLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, long long value)</td></tr>
<tr class="memdesc:a0533703a54ac3ca2492f3e7a4d8a62cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a long long int at the next free location within the entry.  <a href="#a0533703a54ac3ca2492f3e7a4d8a62cf">More...</a><br /></td></tr>
<tr class="separator:a0533703a54ac3ca2492f3e7a4d8a62cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2cd42a00c8180aad9e905d57915fe"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a4dc2cd42a00c8180aad9e905d57915fe">SPHLFEntryAddFloat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, float value)</td></tr>
<tr class="memdesc:a4dc2cd42a00c8180aad9e905d57915fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a float at the next free location within the entry.  <a href="#a4dc2cd42a00c8180aad9e905d57915fe">More...</a><br /></td></tr>
<tr class="separator:a4dc2cd42a00c8180aad9e905d57915fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbf3ad2bbc9b03d374c06146bb97f44"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#aacbf3ad2bbc9b03d374c06146bb97f44">SPHLFEntryAddDouble</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle, double value)</td></tr>
<tr class="memdesc:aacbf3ad2bbc9b03d374c06146bb97f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a double at the next free location within the entry.  <a href="#aacbf3ad2bbc9b03d374c06146bb97f44">More...</a><br /></td></tr>
<tr class="separator:aacbf3ad2bbc9b03d374c06146bb97f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a01717fddf59760eac6e67e0cace99"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ae2a01717fddf59760eac6e67e0cace99">SPHLFEntryGetNextChar</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:ae2a01717fddf59760eac6e67e0cace99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next char from the entry via the current next value pointer. The internal next value pointer is advanced to the next location.  <a href="#ae2a01717fddf59760eac6e67e0cace99">More...</a><br /></td></tr>
<tr class="separator:ae2a01717fddf59760eac6e67e0cace99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3206a649e7562df0e25830eae258080f"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a3206a649e7562df0e25830eae258080f">SPHLFEntryGetNextString</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a3206a649e7562df0e25830eae258080f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char.  <a href="#a3206a649e7562df0e25830eae258080f">More...</a><br /></td></tr>
<tr class="separator:a3206a649e7562df0e25830eae258080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d643985fef2bef8b9ccb34f2cecfdbb"><td class="memItemLeft" align="right" valign="top">static short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a1d643985fef2bef8b9ccb34f2cecfdbb">SPHLFEntryGetNextShort</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a1d643985fef2bef8b9ccb34f2cecfdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next short int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a1d643985fef2bef8b9ccb34f2cecfdbb">More...</a><br /></td></tr>
<tr class="separator:a1d643985fef2bef8b9ccb34f2cecfdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cbb1ba2cb5b655b7528e178c7acbaa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a07cbb1ba2cb5b655b7528e178c7acbaa">SPHLFEntryGetNextInt</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a07cbb1ba2cb5b655b7528e178c7acbaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a07cbb1ba2cb5b655b7528e178c7acbaa">More...</a><br /></td></tr>
<tr class="separator:a07cbb1ba2cb5b655b7528e178c7acbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3000e6e4a8a1129493c1e03326df4ad5"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a3000e6e4a8a1129493c1e03326df4ad5">SPHLFEntryGetNextLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a3000e6e4a8a1129493c1e03326df4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a3000e6e4a8a1129493c1e03326df4ad5">More...</a><br /></td></tr>
<tr class="separator:a3000e6e4a8a1129493c1e03326df4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add441d7f48e2f00a54b752671fdf69d3"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#add441d7f48e2f00a54b752671fdf69d3">SPHLFEntryGetNextPtr</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:add441d7f48e2f00a54b752671fdf69d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next void* from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#add441d7f48e2f00a54b752671fdf69d3">More...</a><br /></td></tr>
<tr class="separator:add441d7f48e2f00a54b752671fdf69d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab674cf5b1a358d7dd7897a9a5aa9d355"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#ab674cf5b1a358d7dd7897a9a5aa9d355">SPHLFEntryGetNextLongLong</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:ab674cf5b1a358d7dd7897a9a5aa9d355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next long long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ab674cf5b1a358d7dd7897a9a5aa9d355">More...</a><br /></td></tr>
<tr class="separator:ab674cf5b1a358d7dd7897a9a5aa9d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf6014926b3365ac75e80dba30e3717"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a9bf6014926b3365ac75e80dba30e3717">SPHLFEntryGetNextFloat</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a9bf6014926b3365ac75e80dba30e3717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next float from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a9bf6014926b3365ac75e80dba30e3717">More...</a><br /></td></tr>
<tr class="separator:a9bf6014926b3365ac75e80dba30e3717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832a71091898d199775d8d5ce3cd4d35"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlfentry_8h.html#a832a71091898d199775d8d5ce3cd4d35">SPHLFEntryGetNextDouble</a> (<a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a832a71091898d199775d8d5ce3cd4d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next double from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a832a71091898d199775d8d5ce3cd4d35">More...</a><br /></td></tr>
<tr class="separator:a832a71091898d199775d8d5ce3cd4d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. </p>
<dl class="section author"><dt>Author</dt><dd>Steven Munroe - initial API and implementation <pre class="fragment"> For shared memory multi-thread/multi-core applications. Once the
 Logger or Queue functions have atomically allocated an entry,
 the "entry" APIs supports adding additional data to the entry and
 retrieving that date later.

 Supported functions include:
 storing category specific event data,
 atomic completion of an entry,
 Getting entry status (complete and timestamped)
 Getting entry header elements (timestamp, PID, TID, Category, and Sub-category),
 Retrieving category specific event data entries,
 and direct pointer access the header and data of the entry.

 This Entry access API supports read out of the 16 byte
 entry header including: Entry status and length.  Entry
 Category and SubCategory codes. Process and Thread Ids.  High
 resolution timestamp.

 Any additional storage allocated to the entry
 is available for application specific data.  This API also provides
 several mechanisms to store application data including; direct
 array or structure overlay, and a streams like mechanism.  Finally
 the API provides a completion functions (SPHLFEntryComplete)
 which provides and memory barriers required by the platform and
 marks the entry complete.</pre></dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac50363e24927398050045404712d3789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a character at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a char. </dd></dl>

</div>
</div>
<a class="anchor" id="aacbf3ad2bbc9b03d374c06146bb97f44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a double at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a double plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc2cd42a00c8180aad9e905d57915fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a float at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a float plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2a87a1a328074acf50e9ff2bf68f691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a int at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a2241d121fbe88427a00c91e757d60ca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a long int at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a0533703a54ac3ca2492f3e7a4d8a62cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a long long int at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a long long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="ae56d8ea3f911b29b878ab18dad4b8394"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a void* at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a void* (C pointer) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a void* plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a32c06bb12b19e12a4ce14b639231bfa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a short int at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a short int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a short int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a73d6d71e1b5ef577abe13ac630fdb186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryAddString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a C string at the next free location within the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>pointer to a C string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if the string is too large for the remain entry free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a604e0d44ba8cfc31df646e9240a51e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryAllocStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for struct starting at the next free location within the entry. </p>
<p>Allocate space in the log entry for a multi-field structure or an array. The returned pointer can then be used to directly store data into struct fields or array entries. The SPHENTRYALLOCSTRUCT can be used to insure the correct usage sizeof and <b>alignof</b> to provide values for the __size and __align parameters.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used instead of SPHLFEntryGetFreePtr if additional data may be added later to the same entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">__size</td><td>of the struct/array to allocate. </td></tr>
    <tr><td class="paramname">__align</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="afc303dd8d7f1ee41e79e7478c97a32a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry category for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6da469b71c6eb116a0fcb4bfc30bba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="a909897cbbf4ebb491f7c9beca7787059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first free byte address for the entry specified by the entry handle. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function should be used carefully. It is not safe to use if other application functions may need to update the same entry. It is also not safe to use for software that needs to cross platform because it does not handle platform specific size and alignment requirements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The SPHLOGENTRYALLOCSTRUCT/SPHLFlogEntryAllocStruct API is recommended for code that needs to operate cross platform.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2a01717fddf59760eac6e67e0cace99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char SPHLFEntryGetNextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next char from the entry via the current next value pointer. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char value if successful, 0 (NUL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a832a71091898d199775d8d5ce3cd4d35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double SPHLFEntryGetNextDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next double from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bf6014926b3365ac75e80dba30e3717"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float SPHLFEntryGetNextFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next float from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a07cbb1ba2cb5b655b7528e178c7acbaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryGetNextInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a3000e6e4a8a1129493c1e03326df4ad5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long SPHLFEntryGetNextLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab674cf5b1a358d7dd7897a9a5aa9d355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long long SPHLFEntryGetNextLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next long long int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long long int value if successful,0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="add441d7f48e2f00a54b752671fdf69d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next void* from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the void* value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d643985fef2bef8b9ccb34f2cecfdbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static short int SPHLFEntryGetNextShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next short int from the entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the short int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a3206a649e7562df0e25830eae258080f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* SPHLFEntryGetNextString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the C string pointer value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9428e7b31affd90dfb6427d1c4d9163"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryGetStructPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the correctly aligned pointer for a struct or array starting at the next free location within the entry. </p>
<p>The entries next pointer is adjusted for alignment and returned. The entries next pointer and remaining fields are updated for the next field following the struct/array.</p>
<dl class="section note"><dt>Note</dt><dd>The SPHENTRYGETSTRUCTPTR can be used to insure the correct usage sizeof and <b>alignof</b> to provide values for the __size and __align parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">__size</td><td>of the struct/array to allocate. </td></tr>
    <tr><td class="paramname">__align</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a42c865c20cc74deaa6c323ed03057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSPHLFEntryHeader__t.html">SPHLFEntryHeader_t</a>* SPHLFEntryHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address for the entry header specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address from the entry header, if the entry was valid. Otherwise return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="abd32221a27c10a8462bc5d9f94be5e5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a91ff8878d2788fd235f5cd2bd56cd6b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dedd1b11549464132d616a826db8709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFEntryPID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the process ID for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e3092975de97065389e76ed6d7f8d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryStrongComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="a720a576b05a7819844a9346c1aef3225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntrySubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry sub-category for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb3db3ada0aaf1d5bd47b7dee53a46a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFEntryTID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the thread ID for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the TID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c53b3ed6d0b30a6fabe56bb7d71974b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a> SPHLFEntryTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the time stamp value for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time stamp value from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae23406573bee24c305326e8179e77ea2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryWeakComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFEntryHandle__t.html">SPHLFEntryHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 03:14:09 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
