<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: Shared Persistent Heap Data Environment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Shared Persistent Heap Data Environment</h1><h3>0.9.0 </h3><p>SPHDE is composed of two major software layers: The Shared Address Space (SAS) layer provides the basic services for a shared address space and transparent, persistent storage. The Shared Persistent Heap (SPH) layer organizes blocks of SAS storage into useful functions for storing and retrieving data. </p>
<dl class="author"><dt><b>Authors:</b></dt><dd>Steven Munroe, Ryan S. Arnold, et al.</dd></dl>
<h2><a class="anchor" id="Rationale">
Rationale</a></h2>
<p>The I/O subsystems, memory subsystems, and supporting APIs of current operating systems were designed for an environment of scarcity (limited real memory and virtual address spaces). Modern applications have to deal with increasingly complex data structures whose data needs to be shared among process instances and persist to storage while still being constrained by these APIs and subsystems.</p>
<p>Scarcity forces trade-offs between simplicity and efficiency and complicates programming tasks. This is especially true if these data structures contain internal references (pointers). Traditional file systems and relational databases simply don't handle internal reference persistence well. Data persistence to storage in these systems is not transparent and requires additional layers of software to capture the relationships represented by these references. This adds even more overhead and complexity to programming tasks.</p>
<p>The availability of 64-bit commodity processors, cheap high-density DRAM, and commodity operating systems effectively eliminate the original scarcity. The standard POSIX shared memory APIs (e.g., shmat, shmdt,shmctl, et al.) enable the exploitation of abundant memory, but are still not simple to use. A (relatively thin) API layer is needed to manage shared memory access across a large shared address space in a simple and coherent way.</p>
<p>Creating such an API is the goal of this project. The primary function is to manage backing files and memory map them into the application. For Linux, this allows data to be shared directly in the real pages of the kernel's file cache. Since the files are always mapped at the same virtual address, internal C pointers can be maintained for both inter-process sharing and transparent persistent storage. This easily supports zero-copy sharing and operate-in-place persistence.</p>
<h2><a class="anchor" id="sasSection">
SAS Overview</a></h2>
<p>The SAS layer manages a region of process address space to provide: </p>
<ul>
<li>Sharing and transparent storage persistence of data within that region by providing and managing backing file space and memory mapping the backing files for the process. </li>
<li>Sharing of data within that region between cooperating processes. </li>
<li>Locking primitives to provide synchronization of use/update between cooperating processes and threads. </li>
<li>APIs for allocating/deallocating blocks of shared/persistent data. </li>
<li>Further tools for managing blocks as data structures (heaps, stacks, indexes, etc.).</li>
</ul>
<p>Some additional SAS definitions:</p>
<p>For now, the size and virtual address range of the region is fixed for each platform (somewhere beyond TASK_UNMAPPED_BASE and below the main stack). Blocks are allocated in power-of-2 size and alignment from within the region.</p>
<p>Backing storage (files) are allocated in power-of-2 sizes called segments. Segments must be smaller in size than the region and usually larger than blocks. Segments don't necessarily have anything to do with any notion of hardware segmentation, but it may be useful if the size/alignment of SAS segments match the underlying hardware.</p>
<p>A simple example of using SPHDE: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sassim_8h.html" title="Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core...">sassim.h</a>&gt;</span> <span class="keywordtype">int</span> main () { <span class="keywordtype">int</span> rc;

  rc = <a class="code" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd" title="Join this process to a SAS Region.">SASJoinRegion</a>();
  <span class="keywordflow">if</span> (rc)
    <span class="keywordflow">return</span> 1;

  <span class="keywordtype">char</span> *block;

  <span class="comment">// allocation a block of SPHDE data ...</span>
  block = (<span class="keywordtype">char</span>*)<a class="code" href="sassim_8h.html#a6b55fd13bce1d0dbbf704604d7d8147c" title="Allocate a block of memory within SAS Storage.">SASBlockAlloc</a> (4096);

  <span class="comment">// code accessing data in SPHDE region goes here.</span>

  <a class="code" href="sassim_8h.html#a1855791a85725dad0cc2d3e216f90b06" title="Process wide cleanup for the SAS runtime. +* +*.">SASCleanUp</a>();
  <span class="keywordflow">return</span> 0;
}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>The application must first "join" a region before allocating or accessing any blocks. If the region does not exist (has no backing files), a "join" will create the initial segment (backing file) and initialize the anchor block.</dd></dl>
<p>By default the region's path name is either "." or the current directory. The region name can be overridden by setting the "SASSTOREPATH" environment variable, or using the <a class="el" href="sassim_8h.html#a2b000ff09648bb379c63cdcb85613010" title="Join this process to a named SAS Region.">SASJoinRegionByName()</a> function. The "region" name is the path to a directory where the SAS/SPH backing files will be created.</p>
<p>Processes that join with the same region name will share the region and all of its (allocated) storage. All processes that share a region can allocate, deallocate, reference and update blocks (normal C pointer semantics) within the region.</p>
<p>Processes that use a different region name are independent from any other region and only see the region that they have joined. There is no limit to the number of independent regions per process other than those imposed by the file system. Normal file access rules apply. Any process that does not have read/write authority to the region's directory or files can not join the region or access the data.</p>
<p>Once a block is allocated it is backed with file storage, and implicitly mmaped for transparent storage persistence and sharing between processes. The block will always be mapped at the same virtual address each time it is loaded and for each sharing process. This allows complex pointer based data structures to be stored, persisted, and shared without additional effort (the pointers are context independent).</p>
<h3><a class="anchor" id="lockSection">
Lock Manager Overview</a></h3>
<p>A lock manager is provides so utilities and cooperating processes can synchronize their activities. Locks are "keyed" by virtual addresses which are normally the address of some interesting shared data structure or "  utility" object.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sassim_8h.html" title="Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core...">sassim.h</a>&gt;</span>
<span class="preprocessor">#include &lt;sasalloc.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="saslock_8h.html" title="Shared Address Space User Locks. Address based locking for shared address space blocks...">saslock.h</a>&gt;</span>
<span class="keywordtype">int</span> main ()
{
  <span class="keywordtype">int</span> rc;

  rc = <a class="code" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd" title="Join this process to a SAS Region.">SASJoinRegion</a>();

  <span class="keywordflow">if</span> (rc)
    <span class="keywordflow">return</span> 1;

  <span class="keywordtype">char</span> *block;
  <span class="comment">// primitive way to remember the root ptr</span>
  block = <a class="code" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62" title="Get the SAS finder address.">getSASFinder</a>();

  <span class="keywordflow">while</span> (...)
  {
      <a class="code" href="saslock_8h.html#a554c10c18c84297ce7a2ef91b1c4af42" title="Lock a SAS Address.">SASLock</a>(block, SasUserLock__WRITE);
      <span class="comment">// synchronized access to &quot;block&quot;</span>
      <a class="code" href="saslock_8h.html#a33b8c7a9a5f493c42c8d4619e24a46d2" title="UnLock a SAS Address.">SASUnlock</a>(block);
  }

  <a class="code" href="sassim_8h.html#a1855791a85725dad0cc2d3e216f90b06" title="Process wide cleanup for the SAS runtime. +* +*.">SASCleanUp</a>();
  <span class="keywordflow">return</span> 0;
}
</pre></div><p>Currently the lock manager supports (shared) SasUserLock__READ and (exclusive) SasUserLock__WRITE locks. The intent is to add other lock types as needed. For example, the index utility could use an "INTENT" lock (which allows multiple READ locks but is exclusive with other INTENT and WRITE lock) which is upgradeable to a WRITE lock.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Notice the function <a class="el" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62" title="Get the SAS finder address.">getSASFinder()</a>; The SAS runtime starts with a special "anchor" block at a fixed location. The anchor block contains the indexes used to track free space and allocations. It also contains the "finder" pointer. The <a class="el" href="sassim_8h.html#a18dd30e5346f63f060cb0374c05921a2" title="Sets the SAS finder pointer to a SAS block or utility object.">setSASFinder()</a> allows t application to save a pointer to any structure of its choice. The next time that the application starts, it can use <a class="el" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62" title="Get the SAS finder address.">getSASFinder()</a> to obtain the original pointer and navigation from there.</dd></dl>
<h2><a class="anchor" id="sphsection">
SPH Utility Objects Overview</a></h2>
<p>A simple pointer is sufficient to anchor a linked list or quad­tree etc., but not very user friendly. SPHDE provides a number of utility objects. Utility objects use blocks of storage to provide higher level functions. An application could create a SASStringBTree_t or SPHContext_t and store its pointer in the finder as in the following example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sassim_8h.html" title="Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core...">sassim.h</a>&gt;</span>
<span class="preprocessor">#include &lt;sasalloc.h&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="sphcontext_8h.html" title="Shared Persistent Heap, name/address context for shared memory multi-thread/multi-core...">sphcontext.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="saslock_8h.html" title="Shared Address Space User Locks. Address based locking for shared address space blocks...">saslock.h</a>&gt;</span>
<span class="keywordtype">int</span> main ()
{
  <span class="keywordtype">int</span> rc;
  <a class="code" href="sphcontext_8h.html#ad8728eed25450b6111b1c01d39fa8a3d" title="Handle to an instance of SPH Context.">SPHContext_t</a> finderContext;

  rc = <a class="code" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd" title="Join this process to a SAS Region.">SASJoinRegion</a>();
  <span class="keywordflow">if</span> (rc)
    <span class="keywordflow">return</span> 1;

  <span class="keywordtype">char</span> *block;

  block = <a class="code" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62" title="Get the SAS finder address.">getSASFinder</a>();
  <span class="keywordflow">if</span> (block)
    finderContext = (<a class="code" href="sphcontext_8h.html#ad8728eed25450b6111b1c01d39fa8a3d" title="Handle to an instance of SPH Context.">SPHContext_t</a>)block;
  <span class="keywordflow">else</span>
    { <span class="comment">// first time logic, only executes once.</span>
      finderContext = <a class="code" href="sphcontext_8h.html#aea867cf118f3d38a0f275e67b407ba6b" title="Create a name/address mapping context..">SPHContextCreate</a>(block__Size16M);
      <a class="code" href="sassim_8h.html#a18dd30e5346f63f060cb0374c05921a2" title="Sets the SAS finder pointer to a SAS block or utility object.">setSASFinder</a>(finderContext);
    }
  <span class="comment">// create and provide a &quot;name&quot; for a new image</span>
  block = (<span class="keywordtype">char</span>*)<a class="code" href="sassim_8h.html#a6b55fd13bce1d0dbbf704604d7d8147c" title="Allocate a block of memory within SAS Storage.">SASBlockAlloc</a> (block__Size4M);

  <a class="code" href="sphcontext_8h.html#a633bf063f164e3d6808d62fa6c1bacf7" title="Add a name/address mapping to this context.">SPHContextAddName</a>(finderContext, <span class="stringliteral">&quot;my_image_buffer&quot;</span>, block);

  <a class="code" href="saslock_8h.html#a554c10c18c84297ce7a2ef91b1c4af42" title="Lock a SAS Address.">SASLock</a>(block, SasUserLock__WRITE);
  <span class="comment">// should lock the new block because is now visible to others</span>
     ...
  <a class="code" href="saslock_8h.html#a33b8c7a9a5f493c42c8d4619e24a46d2" title="UnLock a SAS Address.">SASUnlock</a>(block);
  ...
  <span class="comment">// look up an old image by &quot;name&quot;</span>
  block = <a class="code" href="sphcontext_8h.html#a4ed11d44fa79cc18cc95418c6b114be1" title="Find the address value associated with a name within a specific context.">SPHContextFindByName</a>(finderContext, <span class="stringliteral">&quot;my_old_image&quot;</span>);
  <span class="keywordflow">if</span>(block)
    {
      <a class="code" href="saslock_8h.html#a554c10c18c84297ce7a2ef91b1c4af42" title="Lock a SAS Address.">SASLock</a>(block, SasUserLock__WRITE);
      ...
      <a class="code" href="saslock_8h.html#a33b8c7a9a5f493c42c8d4619e24a46d2" title="UnLock a SAS Address.">SASUnlock</a>(block);
    }

  <a class="code" href="sassim_8h.html#a1855791a85725dad0cc2d3e216f90b06" title="Process wide cleanup for the SAS runtime. +* +*.">SASCleanUp</a>();
  <span class="keywordflow">return</span> 0;

}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>A general purpose solution is provided by the SPHSetupProjectContext API defined in <a class="el" href="sphcontext_8h.html" title="Shared Persistent Heap, name/address context for shared memory multi-thread/multi-core...">sphcontext.h</a>.</dd></dl>
<p>Utility objects like Context, Index, and StringBTree can be used to create directories or index large arrays of data structures for search. The Context is a combination of a StringBTree and a Index. It allows any object (address) to have a symbolic name (or names). It also provides the reverse mapping, from address to name(s).</p>
<h3><a class="anchor" id="SASRuntime">
Shared Address Space Runtime</a></h3>
<ul>
<li><a class="el" href="sassim_8h.html" title="Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core...">sassim.h</a> SAS base Runtime</li>
<li><a class="el" href="saslock_8h.html" title="Shared Address Space User Locks. Address based locking for shared address space blocks...">saslock.h</a> SAS Shared Address Locks</li>
<li><a class="el" href="sasatom_8h.html" title="Type and functions for SAS atomic operations.">sasatom.h</a> SAS Atomic operation</li>
<li><a class="el" href="sasmsync_8h.html" title="API to manage the resources of the Shared Address Space.">sasmsync.h</a> SAS Memory Advice API</li>
</ul>
<h3><a class="anchor" id="SASUtility">
General Utility Objects</a></h3>
<ul>
<li><a class="el" href="sassimplespace_8h.html" title="Shared Address Space Simple Space. Allocate a SAS block as one contiguous space.">sassimplespace.h</a> SAS Simple Space</li>
<li><a class="el" href="sassimplestack_8h.html" title="Shared Address Space Simple Stack. Allocate a SAS block as stack.">sassimplestack.h</a> SAS Simple Stack</li>
<li><a class="el" href="sassimpleheap_8h.html" title="Shared Address Space Simple Heap.">sassimpleheap.h</a> SAS Simple Heap</li>
<li><a class="el" href="sascompoundheap_8h.html" title="Shared Address Space Compound Heap.">sascompoundheap.h</a> SAS Compound Heap; expanding heap of Simple Heaps</li>
</ul>
<h3><a class="anchor" id="SASIndex">
Maps, indexes and Contexts</a></h3>
<ul>
<li><a class="el" href="sphcontext_8h.html" title="Shared Persistent Heap, name/address context for shared memory multi-thread/multi-core...">sphcontext.h</a> SPH Context</li>
<li><a class="el" href="sasstringbtree_8h.html" title="Shared Address Space B-tree.">sasstringbtree.h</a> SAS String BTree</li>
<li><a class="el" href="sasstringbtreeenum_8h.html" title="An enumeration over a Shared Address Space, C String BTree index for shared memory...">sasstringbtreeenum.h</a> String BTree Enum for accessing Contexts and String BTrees</li>
<li><a class="el" href="sasindex_8h.html" title="Shared Address Space B-tree based on binary values including virtual addresses.">sasindex.h</a> Binary Index BTree</li>
<li><a class="el" href="sasindexenum_8h.html" title="Enumeration API for iteration over Shared Address Space binary B-tree index defined...">sasindexenum.h</a> Binary BTree Index Enum for accessing Index BTrees</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>These (Context, Index, and StringBTree) utility objects are implemented on (as a subclass of) the SASCompoundHeap_t utility object. A SASCompoundHeap_t is a heap of SASSimpleHeap_t heaps. The Btree nodes are SASSimpleHeap_t, which are normally page size allocations. This framework implicitly manages locality of reference, minimizing the number of pages/cache-lines touched during any specific search.</dd></dl>
<h3><a class="anchor" id="SPHMultiCore">
Shared Persistent Heap, Multi-core Optimized Utilities</a></h3>
<ul>
<li><a class="el" href="sphlockfreeheap_8h.html" title="Shared Persistent Heap, lock free heap allocator for shared memory multi-thread/multi-core...">sphlockfreeheap.h</a> Lock Free Heap</li>
<li><a class="el" href="sphlflogger_8h.html" title="Shared Persistent Heap, logger. For shared memory multi-thread/multi-core applications...">sphlflogger.h</a> Lock Free Logger</li>
<li><a class="el" href="sphlogportal_8h.html" title="Shared Persistent Heap, log Portal. For shared memory multi-thread/multi-core applications...">sphlogportal.h</a> Lock Free Portal/Multiplexer for Loggers</li>
<li><a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions.">sphlflogentry.h</a> Logger Entry access API</li>
<li><a class="el" href="sphsinglepcqueue_8h.html" title="Shared Persistent Heap, single producer single consumer queue. For shared memory...">sphsinglepcqueue.h</a> Lock Free Single Producer / Single Consumer Queue</li>
<li><a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> SPH Entry access API</li>
</ul>
<h3><a class="anchor" id="SPH">
MultiCore Utilitary functions</a></h3>
<ul>
<li><a class="el" href="sphtimer_8h.html" title="Functions to access the Time Base register (PPC) or clock_gettime(CLOCK_MONOTONIC)...">sphtimer.h</a> APIs to access the high resolution timer and timer frequency</li>
<li><a class="el" href="sphthread_8h.html" title="Thread utility functions.">sphthread.h</a> APIs to identify processes and threads </li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Jan 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
