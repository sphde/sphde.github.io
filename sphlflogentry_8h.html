<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlflogentry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphlflogentry.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, logger entry status, update and access functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphlflogger_8h_source.html">sphlflogger.h</a>&quot;</code><br />
</div>
<p><a href="sphlflogentry_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6fcb37ba3e1708d561968e340b26786f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fcb37ba3e1708d561968e340b26786f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a6fcb37ba3e1708d561968e340b26786f">SPHLOGENTRYGETSTRUCTPTR</a>(__handle,  __struct)&#160;&#160;&#160;<a class="el" href="sphlflogentry_8h.html#a36603864a36feb93a87b668962c6b226">SPHLFlogEntryGetStructPtr</a>(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr class="memdesc:a6fcb37ba3e1708d561968e340b26786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFlogEntryGetStructPtr function. <br /></td></tr>
<tr class="separator:a6fcb37ba3e1708d561968e340b26786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5df91ee1672c556a09bdbbd62e99d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada5df91ee1672c556a09bdbbd62e99d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ada5df91ee1672c556a09bdbbd62e99d6">SPHLOGENTRYALLOCSTRUCT</a>(__handle,  __struct)&#160;&#160;&#160;<a class="el" href="sphlflogentry_8h.html#a840a489d9e27cf643e921409680dbb3e">SPHLFlogEntryAllocStruct</a>(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr class="memdesc:ada5df91ee1672c556a09bdbbd62e99d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFlogEntryAllocStruct function. <br /></td></tr>
<tr class="separator:ada5df91ee1672c556a09bdbbd62e99d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a24e2f37c84a9dd05d2e98fd21a12c36a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a24e2f37c84a9dd05d2e98fd21a12c36a">SPHLFLogEntryStrongComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a24e2f37c84a9dd05d2e98fd21a12c36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.  <a href="#a24e2f37c84a9dd05d2e98fd21a12c36a">More...</a><br /></td></tr>
<tr class="separator:a24e2f37c84a9dd05d2e98fd21a12c36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d19cda09ecda87c2677bd16d250f71"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a71d19cda09ecda87c2677bd16d250f71">SPHLFLogEntryWeakComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a71d19cda09ecda87c2677bd16d250f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads.  <a href="#a71d19cda09ecda87c2677bd16d250f71">More...</a><br /></td></tr>
<tr class="separator:a71d19cda09ecda87c2677bd16d250f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02b38ca9d77f83da11c28bb9c094f87"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ab02b38ca9d77f83da11c28bb9c094f87">SPHLFLogEntryComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:ab02b38ca9d77f83da11c28bb9c094f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads.  <a href="#ab02b38ca9d77f83da11c28bb9c094f87">More...</a><br /></td></tr>
<tr class="separator:ab02b38ca9d77f83da11c28bb9c094f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca76a4f3a58173f0ca13713adef3a2bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aca76a4f3a58173f0ca13713adef3a2bb">SPHLFLogEntryIsComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:aca76a4f3a58173f0ca13713adef3a2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#aca76a4f3a58173f0ca13713adef3a2bb">More...</a><br /></td></tr>
<tr class="separator:aca76a4f3a58173f0ca13713adef3a2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c06400c08debfddc028849381b4d569"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a3c06400c08debfddc028849381b4d569">SPHLFLogEntryIsTimestamped</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a3c06400c08debfddc028849381b4d569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#a3c06400c08debfddc028849381b4d569">More...</a><br /></td></tr>
<tr class="separator:a3c06400c08debfddc028849381b4d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a75a87871d4bdb483a92d8a8ffdd8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a91a75a87871d4bdb483a92d8a8ffdd8a">SPHLFLogEntryTimeStamp</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a91a75a87871d4bdb483a92d8a8ffdd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time stamp value for the entry specified by the entry handle.  <a href="#a91a75a87871d4bdb483a92d8a8ffdd8a">More...</a><br /></td></tr>
<tr class="separator:a91a75a87871d4bdb483a92d8a8ffdd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c21c76b0b2acf23be72967d7f585d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#af3c21c76b0b2acf23be72967d7f585d3">SPHLFLogEntryPID</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:af3c21c76b0b2acf23be72967d7f585d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the process ID for the entry specified by the entry handle.  <a href="#af3c21c76b0b2acf23be72967d7f585d3">More...</a><br /></td></tr>
<tr class="separator:af3c21c76b0b2acf23be72967d7f585d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1c5f4478f0c957577658ef90e6e315"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#abc1c5f4478f0c957577658ef90e6e315">SPHLFLogEntryTID</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:abc1c5f4478f0c957577658ef90e6e315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread ID for the entry specified by the entry handle.  <a href="#abc1c5f4478f0c957577658ef90e6e315">More...</a><br /></td></tr>
<tr class="separator:abc1c5f4478f0c957577658ef90e6e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5155ba079c49c2cb5baf20bf330e87c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSPHLFLogHeader__t.html">SPHLFLogHeader_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a5155ba079c49c2cb5baf20bf330e87c1">SPHLFLogEntryHeader</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a5155ba079c49c2cb5baf20bf330e87c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address for the entry header specified by the entry handle.  <a href="#a5155ba079c49c2cb5baf20bf330e87c1">More...</a><br /></td></tr>
<tr class="separator:a5155ba079c49c2cb5baf20bf330e87c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc871e0a3c447918582f9facd2390b09"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#adc871e0a3c447918582f9facd2390b09">SPHLFLogEntryCategory</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:adc871e0a3c447918582f9facd2390b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry category for the entry specified by the entry handle.  <a href="#adc871e0a3c447918582f9facd2390b09">More...</a><br /></td></tr>
<tr class="separator:adc871e0a3c447918582f9facd2390b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8099ead0eff9b3f124e1ab30e8c840c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ac8099ead0eff9b3f124e1ab30e8c840c">SPHLFLogEntrySubcat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:ac8099ead0eff9b3f124e1ab30e8c840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the entry handle.  <a href="#ac8099ead0eff9b3f124e1ab30e8c840c">More...</a><br /></td></tr>
<tr class="separator:ac8099ead0eff9b3f124e1ab30e8c840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ac1c9fa0603f87245007906d164e9"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a9f4ac1c9fa0603f87245007906d164e9">SPHLFLogEntryGetFreePtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a9f4ac1c9fa0603f87245007906d164e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address first free byte for the entry specified by the entry handle.  <a href="#a9f4ac1c9fa0603f87245007906d164e9">More...</a><br /></td></tr>
<tr class="separator:a9f4ac1c9fa0603f87245007906d164e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36603864a36feb93a87b668962c6b226"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a36603864a36feb93a87b668962c6b226">SPHLFlogEntryGetStructPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr class="memdesc:a36603864a36feb93a87b668962c6b226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correctly aligned pointer for a struct or array starting at the next free location within the logger entry.  <a href="#a36603864a36feb93a87b668962c6b226">More...</a><br /></td></tr>
<tr class="separator:a36603864a36feb93a87b668962c6b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840a489d9e27cf643e921409680dbb3e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a840a489d9e27cf643e921409680dbb3e">SPHLFlogEntryAllocStruct</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr class="memdesc:a840a489d9e27cf643e921409680dbb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for struct starting at the next free location within the logger entry.  <a href="#a840a489d9e27cf643e921409680dbb3e">More...</a><br /></td></tr>
<tr class="separator:a840a489d9e27cf643e921409680dbb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8098f71e35ca903ec49488d6d0bdc06"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ab8098f71e35ca903ec49488d6d0bdc06">SPHLFlogEntryAddString</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, char *value)</td></tr>
<tr class="memdesc:ab8098f71e35ca903ec49488d6d0bdc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a C string at the next free location within the logger entry.  <a href="#ab8098f71e35ca903ec49488d6d0bdc06">More...</a><br /></td></tr>
<tr class="separator:ab8098f71e35ca903ec49488d6d0bdc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe1711694442ff01440c8e636bdfb44"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#adfe1711694442ff01440c8e636bdfb44">SPHLFlogEntryAddChar</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, char value)</td></tr>
<tr class="memdesc:adfe1711694442ff01440c8e636bdfb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a character at the next free location within the logger entry.  <a href="#adfe1711694442ff01440c8e636bdfb44">More...</a><br /></td></tr>
<tr class="separator:adfe1711694442ff01440c8e636bdfb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d137e605c2bbfbe2e300be4d0ce253b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a6d137e605c2bbfbe2e300be4d0ce253b">SPHLFlogEntryAddShort</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, short int value)</td></tr>
<tr class="memdesc:a6d137e605c2bbfbe2e300be4d0ce253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a short int at the next free location within the logger entry.  <a href="#a6d137e605c2bbfbe2e300be4d0ce253b">More...</a><br /></td></tr>
<tr class="separator:a6d137e605c2bbfbe2e300be4d0ce253b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf8acf72b23b373e7131545386617ec"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#abdf8acf72b23b373e7131545386617ec">SPHLFlogEntryAddInt</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, int value)</td></tr>
<tr class="memdesc:abdf8acf72b23b373e7131545386617ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a int at the next free location within the logger entry.  <a href="#abdf8acf72b23b373e7131545386617ec">More...</a><br /></td></tr>
<tr class="separator:abdf8acf72b23b373e7131545386617ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53b7aa19814d95b8b8c7115ed4ff44a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#af53b7aa19814d95b8b8c7115ed4ff44a">SPHLFlogEntryAddLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, long value)</td></tr>
<tr class="memdesc:af53b7aa19814d95b8b8c7115ed4ff44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a long int at the next free location within the logger entry.  <a href="#af53b7aa19814d95b8b8c7115ed4ff44a">More...</a><br /></td></tr>
<tr class="separator:af53b7aa19814d95b8b8c7115ed4ff44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f9088cce556fbeface6136c63ab88d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a50f9088cce556fbeface6136c63ab88d">SPHLFlogEntryAddPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, void *value)</td></tr>
<tr class="memdesc:a50f9088cce556fbeface6136c63ab88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a void* at the next free location within the logger entry.  <a href="#a50f9088cce556fbeface6136c63ab88d">More...</a><br /></td></tr>
<tr class="separator:a50f9088cce556fbeface6136c63ab88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea52f07ce181cea011a1e124c5f88c6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a3ea52f07ce181cea011a1e124c5f88c6">SPHLFlogEntryAddLongLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, long long value)</td></tr>
<tr class="memdesc:a3ea52f07ce181cea011a1e124c5f88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a long long int at the next free location within the logger entry.  <a href="#a3ea52f07ce181cea011a1e124c5f88c6">More...</a><br /></td></tr>
<tr class="separator:a3ea52f07ce181cea011a1e124c5f88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd3226f621ffa7ff72a5f0b90be70e2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a6bd3226f621ffa7ff72a5f0b90be70e2">SPHLFlogEntryAddFloat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, float value)</td></tr>
<tr class="memdesc:a6bd3226f621ffa7ff72a5f0b90be70e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a float at the next free location within the logger entry.  <a href="#a6bd3226f621ffa7ff72a5f0b90be70e2">More...</a><br /></td></tr>
<tr class="separator:a6bd3226f621ffa7ff72a5f0b90be70e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f65e43c919592b79f2cbf5df2219bb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ae1f65e43c919592b79f2cbf5df2219bb">SPHLFlogEntryAddDouble</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, double value)</td></tr>
<tr class="memdesc:ae1f65e43c919592b79f2cbf5df2219bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a double at the next free location within the logger entry.  <a href="#ae1f65e43c919592b79f2cbf5df2219bb">More...</a><br /></td></tr>
<tr class="separator:ae1f65e43c919592b79f2cbf5df2219bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94919bf913bc48e5dfbee6dd6193e0e"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#af94919bf913bc48e5dfbee6dd6193e0e">SPHLFlogEntryGetNextChar</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:af94919bf913bc48e5dfbee6dd6193e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next char from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location.  <a href="#af94919bf913bc48e5dfbee6dd6193e0e">More...</a><br /></td></tr>
<tr class="separator:af94919bf913bc48e5dfbee6dd6193e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea839cb7ac26ba826d411d6d2cdd96ab"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aea839cb7ac26ba826d411d6d2cdd96ab">SPHLFlogEntryGetNextString</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:aea839cb7ac26ba826d411d6d2cdd96ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char.  <a href="#aea839cb7ac26ba826d411d6d2cdd96ab">More...</a><br /></td></tr>
<tr class="separator:aea839cb7ac26ba826d411d6d2cdd96ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f270eeef426642499b505b24cf79a0"><td class="memItemLeft" align="right" valign="top">static short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a73f270eeef426642499b505b24cf79a0">SPHLFlogEntryGetNextShort</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a73f270eeef426642499b505b24cf79a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next short int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a73f270eeef426642499b505b24cf79a0">More...</a><br /></td></tr>
<tr class="separator:a73f270eeef426642499b505b24cf79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae95fa324064134fa689203808815261"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aae95fa324064134fa689203808815261">SPHLFlogEntryGetNextInt</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:aae95fa324064134fa689203808815261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#aae95fa324064134fa689203808815261">More...</a><br /></td></tr>
<tr class="separator:aae95fa324064134fa689203808815261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792eb45fea8a31c2f4f8737cebeb659"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a1792eb45fea8a31c2f4f8737cebeb659">SPHLFlogEntryGetNextLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:a1792eb45fea8a31c2f4f8737cebeb659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a1792eb45fea8a31c2f4f8737cebeb659">More...</a><br /></td></tr>
<tr class="separator:a1792eb45fea8a31c2f4f8737cebeb659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605112416999b046dcd91c04e03e76d"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ab605112416999b046dcd91c04e03e76d">SPHLFlogEntryGetNextPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:ab605112416999b046dcd91c04e03e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next void* from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ab605112416999b046dcd91c04e03e76d">More...</a><br /></td></tr>
<tr class="separator:ab605112416999b046dcd91c04e03e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35c5f050ffa3810941a34cc80b9aadf"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aa35c5f050ffa3810941a34cc80b9aadf">SPHLFlogEntryGetNextLongLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:aa35c5f050ffa3810941a34cc80b9aadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next long long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#aa35c5f050ffa3810941a34cc80b9aadf">More...</a><br /></td></tr>
<tr class="separator:aa35c5f050ffa3810941a34cc80b9aadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecc3146c23e04294532b80a573e294e"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#afecc3146c23e04294532b80a573e294e">SPHLFlogEntryGetNextFloat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:afecc3146c23e04294532b80a573e294e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next float from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#afecc3146c23e04294532b80a573e294e">More...</a><br /></td></tr>
<tr class="separator:afecc3146c23e04294532b80a573e294e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e5c5b6dcd4fe1e89ae1985b68f315"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ad80e5c5b6dcd4fe1e89ae1985b68f315">SPHLFlogEntryGetNextDouble</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr class="memdesc:ad80e5c5b6dcd4fe1e89ae1985b68f315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next double from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ad80e5c5b6dcd4fe1e89ae1985b68f315">More...</a><br /></td></tr>
<tr class="separator:ad80e5c5b6dcd4fe1e89ae1985b68f315"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, logger entry status, update and access functions. </p>
<p>! </p><dl class="section author"><dt>Author</dt><dd>Steven Munroe - initial API and implementation <pre class="fragment"> For shared memory multi-thread/multi-core applications. Once the
 SPHLFLogger_t functions have atomically allocated a Logger entry,
 the "entry" APIs supports adding additional data to the entry and
 retrieving that date later.

 Supported functions include:
 storing category specific event data,
 atomic completion of an entry,
 Getting entry status (complete and timestamped)
 Getting entry header elements (timestamp, PID, TID, Category, and Sub-category),
 Retrieving category specific event data entries,
 and direct pointer access the header and data of the entry.

 This Logger Entry access API supports read out of the 16 byte
 entry header including: Entry status and length.  Entry
 Category and SubCategory codes. Process and Thread Ids.  High
 resolution timestamp.

 Any additional storage allocated to the entry
 is available for application specific data.  This API also provides
 several mechanisms to store application data including; direct
 array or structure overlay, and a streams like mechanism.  Finally
 the API provides a completion functions (SPHLFLogEntryComplete)
 which provides and memory barriers required by the platform and
 marks the entry complete.
</pre></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>This API should be migrated to use the common <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adfe1711694442ff01440c8e636bdfb44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a character at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a char. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f65e43c919592b79f2cbf5df2219bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a double at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a double plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bd3226f621ffa7ff72a5f0b90be70e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a float at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a float plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="abdf8acf72b23b373e7131545386617ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a int at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="af53b7aa19814d95b8b8c7115ed4ff44a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a long int at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea52f07ce181cea011a1e124c5f88c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a long long int at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a long long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a50f9088cce556fbeface6136c63ab88d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a void* at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a void* (C pointer) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a void* plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d137e605c2bbfbe2e300be4d0ce253b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a short int at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>a short int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a short int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8098f71e35ca903ec49488d6d0bdc06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryAddString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a C string at the next free location within the logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">value</td><td>pointer to a C string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if the insert fails. For example if the string is too large for the remain entry free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a840a489d9e27cf643e921409680dbb3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFlogEntryAllocStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate space for struct starting at the next free location within the logger entry. </p>
<p>Allocate space in the log entry for a multi-field structure or an array. The returned pointer can then be used to directly store data into struct fields or array entries. The SPHLOGENTRYALLOCSTRUCT can be used to insure the correct usage sizeof and <b>alignof</b> to provide values for the __size and __align parameters.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used instead of SPHLFLogEntryGetFreePtr if additional data may be added later to the same entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">__size</td><td>of the struct/array to allocate. </td></tr>
    <tr><td class="paramname">__align</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="adc871e0a3c447918582f9facd2390b09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry category for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab02b38ca9d77f83da11c28bb9c094f87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f4ac1c9fa0603f87245007906d164e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFLogEntryGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address first free byte for the entry specified by the entry handle. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function should be used carefully. It is not safe to use if other application functions may need to update the same entry. It is also not safe to use for software that needs to cross platform because it does not handle platform specific size and alignment requirements.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The SPHLOGENTRYALLOCSTRUCT/SPHLFlogEntryAllocStruct API is recommended for code that needs to operate cross platform.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="af94919bf913bc48e5dfbee6dd6193e0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char SPHLFlogEntryGetNextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next char from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the char value if successful, 0 (NUL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ad80e5c5b6dcd4fe1e89ae1985b68f315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double SPHLFlogEntryGetNextDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next double from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="afecc3146c23e04294532b80a573e294e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float SPHLFlogEntryGetNextFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next float from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aae95fa324064134fa689203808815261"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFlogEntryGetNextInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a1792eb45fea8a31c2f4f8737cebeb659"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long SPHLFlogEntryGetNextLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aa35c5f050ffa3810941a34cc80b9aadf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long long SPHLFlogEntryGetNextLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next long long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long long int value if successful,0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab605112416999b046dcd91c04e03e76d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFlogEntryGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next void* from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the void* value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a73f270eeef426642499b505b24cf79a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static short int SPHLFlogEntryGetNextShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next short int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the short int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aea839cb7ac26ba826d411d6d2cdd96ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* SPHLFlogEntryGetNextString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the C string pointer value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a36603864a36feb93a87b668962c6b226"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFlogEntryGetStructPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>__align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the correctly aligned pointer for a struct or array starting at the next free location within the logger entry. </p>
<p>The entries next pointer is adjusted for alignment and returned. The entries next pointer and remaining fields are updated for the next field following the struct/array.</p>
<dl class="section note"><dt>Note</dt><dd>The SPHLOGENTRYGETSTRUCTPTR can be used to insure the correct usage sizeof and <b>alignof</b> to provide values for the __size and __align parameters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">__size</td><td>of the struct/array to allocate. </td></tr>
    <tr><td class="paramname">__align</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a5155ba079c49c2cb5baf20bf330e87c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSPHLFLogHeader__t.html">SPHLFLogHeader_t</a>* SPHLFLogEntryHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the address for the entry header specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address from the entry header, if the entry was valid. Otherwise return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aca76a4f3a58173f0ca13713adef3a2bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c06400c08debfddc028849381b4d569"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="af3c21c76b0b2acf23be72967d7f585d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFLogEntryPID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the process ID for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a24e2f37c84a9dd05d2e98fd21a12c36a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryStrongComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8099ead0eff9b3f124e1ab30e8c840c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntrySubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry sub-category for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="abc1c5f4478f0c957577658ef90e6e315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFLogEntryTID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the thread ID for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the TID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a91a75a87871d4bdb483a92d8a8ffdd8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a> SPHLFLogEntryTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the time stamp value for the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time stamp value from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a71d19cda09ecda87c2677bd16d250f71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFLogEntryWeakComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlespace</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 11 2016 05:16:51 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
