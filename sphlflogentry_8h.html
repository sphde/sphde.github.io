<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlflogentry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphlflogentry.h File Reference</h1>
<p>Shared Persistent Heap, logger entry status, update and access functions.  
<a href="#_details">More...</a></p>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphlflogger_8h_source.html">sphlflogger.h</a>&quot;</code><br/>

<p><a href="sphlflogentry_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fcb37ba3e1708d561968e340b26786f"></a><!-- doxytag: member="sphlflogentry.h::SPHLOGENTRYGETSTRUCTPTR" ref="a6fcb37ba3e1708d561968e340b26786f" args="(__handle, __struct)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a6fcb37ba3e1708d561968e340b26786f">SPHLOGENTRYGETSTRUCTPTR</a>(__handle, __struct)&nbsp;&nbsp;&nbsp;SPHLFlogEntryGetStructPtr(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFlogEntryGetStructPtr function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada5df91ee1672c556a09bdbbd62e99d6"></a><!-- doxytag: member="sphlflogentry.h::SPHLOGENTRYALLOCSTRUCT" ref="ada5df91ee1672c556a09bdbbd62e99d6" args="(__handle, __struct)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ada5df91ee1672c556a09bdbbd62e99d6">SPHLOGENTRYALLOCSTRUCT</a>(__handle, __struct)&nbsp;&nbsp;&nbsp;SPHLFlogEntryAllocStruct(__handle, sizeof(__struct), __alignof__(__struct))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro for using sizeof/__alignof__ parms with SPHLFlogEntryAllocStruct function. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a242ad8d63fd2bb13b23a5e2665545d25">SPHLFLogEntryStrongComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.  <a href="#a242ad8d63fd2bb13b23a5e2665545d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a56b54482f6d8acaff0d4ef3fb9b1afe8">SPHLFLogEntryWeakComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads.  <a href="#a56b54482f6d8acaff0d4ef3fb9b1afe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a2c48e0285bce4b8bb43e91f1a75e0582">SPHLFLogEntryComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads.  <a href="#a2c48e0285bce4b8bb43e91f1a75e0582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a24b5c418e935b72ee0c7fe5c803e0cf0">SPHLFLogEntryIsComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#a24b5c418e935b72ee0c7fe5c803e0cf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a8d07e65a75a3b139982167edaf910696">SPHLFLogEntryIsTimestamped</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#a8d07e65a75a3b139982167edaf910696"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a18b9105fb237a06271031c7aaa6fc96b">SPHLFLogEntryTimeStamp</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the time stamp value for the entry specified by the entry handle.  <a href="#a18b9105fb237a06271031c7aaa6fc96b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a8664b111329ebc341e57e4c79ae2e5ab">SPHLFLogEntryPID</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the process ID for the entry specified by the entry handle.  <a href="#a8664b111329ebc341e57e4c79ae2e5ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ab175a33b9473897159133b2deb67ea47">SPHLFLogEntryTID</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the thread ID for the entry specified by the entry handle.  <a href="#ab175a33b9473897159133b2deb67ea47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSPHLFLogHeader__t.html">SPHLFLogHeader_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aee6f50aa6c65f7862071066588efeaad">SPHLFLogEntryHeader</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address for the entry header specified by the entry handle.  <a href="#aee6f50aa6c65f7862071066588efeaad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a5cce137b9fc8602499ed399ec08f5ccf">SPHLFLogEntryCategory</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry category for the entry specified by the entry handle.  <a href="#a5cce137b9fc8602499ed399ec08f5ccf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aa31c35c29c2aa7ff9744190687f8b3d5">SPHLFLogEntrySubcat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the entry handle.  <a href="#aa31c35c29c2aa7ff9744190687f8b3d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ae13346f87e1ce85543fe11deba58f5f1">SPHLFLogEntryGetFreePtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address first free byte for the entry specified by the entry handle.  <a href="#ae13346f87e1ce85543fe11deba58f5f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ab1d5f149afbb63a90d2bf2a461936a06">SPHLFlogEntryGetStructPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the correctly aligned pointer for a struct or array starting at the next free location within the logger entry.  <a href="#ab1d5f149afbb63a90d2bf2a461936a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a7652c49a66c32701f1cc6c00d34e7552">SPHLFlogEntryAllocStruct</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, unsigned long __size, unsigned long __align)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for struct starting at the next free location within the logger entry.  <a href="#a7652c49a66c32701f1cc6c00d34e7552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a645598dc1663b0f894a8ded3ddf48360">SPHLFlogEntryAddString</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, char *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a C string at the next free location within the logger entry.  <a href="#a645598dc1663b0f894a8ded3ddf48360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ae0d2e43bf4178c6cad7d2cf9a06a0830">SPHLFlogEntryAddChar</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, char value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a character at the next free location within the logger entry.  <a href="#ae0d2e43bf4178c6cad7d2cf9a06a0830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a515792e8e34afb8adef031270554b2ca">SPHLFlogEntryAddShort</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, short int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a short int at the next free location within the logger entry.  <a href="#a515792e8e34afb8adef031270554b2ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a4efbdf0e3f7382506b41c77b05a6707e">SPHLFlogEntryAddInt</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a int at the next free location within the logger entry.  <a href="#a4efbdf0e3f7382506b41c77b05a6707e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#abf68eac639cf19de0f976d8d62a64324">SPHLFlogEntryAddLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a long int at the next free location within the logger entry.  <a href="#abf68eac639cf19de0f976d8d62a64324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a38c30e6025b0bbff727baf588bbb2e1e">SPHLFlogEntryAddPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a void* at the next free location within the logger entry.  <a href="#a38c30e6025b0bbff727baf588bbb2e1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a1ae40701df169200627462edf85da7fd">SPHLFlogEntryAddLongLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, long long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a long long int at the next free location within the logger entry.  <a href="#a1ae40701df169200627462edf85da7fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a0da1364adade000f1b2e7da24048a855">SPHLFlogEntryAddFloat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, float value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a float at the next free location within the logger entry.  <a href="#a0da1364adade000f1b2e7da24048a855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a8810e4f12395a9b6a80f3cc6ab86bba1">SPHLFlogEntryAddDouble</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle, double value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a double at the next free location within the logger entry.  <a href="#a8810e4f12395a9b6a80f3cc6ab86bba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a4506e4cabd88e840bcd1eb6c21db5fb3">SPHLFlogEntryGetNextChar</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next char from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location.  <a href="#a4506e4cabd88e840bcd1eb6c21db5fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a88f037eecc7692424c3b4ca7f10ea96f">SPHLFlogEntryGetNextString</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char.  <a href="#a88f037eecc7692424c3b4ca7f10ea96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#aec8fef3ab978abab9d817226a26b8ca5">SPHLFlogEntryGetNextShort</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next short int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#aec8fef3ab978abab9d817226a26b8ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a12dfbeb9a0018c51e2505aa873fcd0be">SPHLFlogEntryGetNextInt</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a12dfbeb9a0018c51e2505aa873fcd0be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a463e1622565d7283bf6d703b70dc29bd">SPHLFlogEntryGetNextLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a463e1622565d7283bf6d703b70dc29bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#afe1e9561a8fdff0a138bdc94b2059423">SPHLFlogEntryGetNextPtr</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next void* from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#afe1e9561a8fdff0a138bdc94b2059423"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a32cc210c045df8a4045ad0daa244b085">SPHLFlogEntryGetNextLongLong</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next long long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a32cc210c045df8a4045ad0daa244b085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#ac57da95ad89d288785aca05a47a10e1a">SPHLFlogEntryGetNextFloat</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next float from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#ac57da95ad89d288785aca05a47a10e1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogentry_8h.html#a32aebb1f0bf1ca9e23da04a75e0e0f4b">SPHLFlogEntryGetNextDouble</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next double from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location.  <a href="#a32aebb1f0bf1ca9e23da04a75e0e0f4b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, logger entry status, update and access functions. </p>
<p>! </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Steven Munroe - initial API and implementation</dd></dl>
<p>For shared memory multi-thread/multi-core applications. Once the SPHLFLogger_t functions have atomically allocated a Logger entry, the "entry" APIs supports adding additional data to the entry and retrieving that date later.</p>
<p>Supported functions include: storing category specific event data, atomic completion of an entry, Getting entry status (complete and timestamped) Getting entry header elements (timestamp, PID, TID, Category, and Sub-category), Retrieving category specific event data entries, and direct pointer access the header and data of the entry.</p>
<p>This Logger Entry access API supports read out of the 16 byte entry header including: Entry status and length. Entry Category and SubCategory codes. Process and Thread Ids. High resolution timestamp.</p>
<p>Any additional storage allocated to the entry is available for application specific data. This API also provides several mechanisms to store application data including; direct array or structure overlay, and a streams like mechanism. Finally the API provides a completion functions (SPHLFLogEntryComplete) which provides and memory barriers required by the platform and marks the entry complete.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>This API should be migrated to use the common <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> API. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae0d2e43bf4178c6cad7d2cf9a06a0830"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddChar" ref="ae0d2e43bf4178c6cad7d2cf9a06a0830" args="(SPHLFLoggerHandle_t *handle, char value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a character at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a char value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a char. </dd></dl>

</div>
</div>
<a class="anchor" id="a8810e4f12395a9b6a80f3cc6ab86bba1"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddDouble" ref="a8810e4f12395a9b6a80f3cc6ab86bba1" args="(SPHLFLoggerHandle_t *handle, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a double at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a double plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a0da1364adade000f1b2e7da24048a855"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddFloat" ref="a0da1364adade000f1b2e7da24048a855" args="(SPHLFLoggerHandle_t *handle, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a float at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a float value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a float plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a4efbdf0e3f7382506b41c77b05a6707e"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddInt" ref="a4efbdf0e3f7382506b41c77b05a6707e" args="(SPHLFLoggerHandle_t *handle, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a int at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="abf68eac639cf19de0f976d8d62a64324"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddLong" ref="abf68eac639cf19de0f976d8d62a64324" args="(SPHLFLoggerHandle_t *handle, long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a long int at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae40701df169200627462edf85da7fd"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddLongLong" ref="a1ae40701df169200627462edf85da7fd" args="(SPHLFLoggerHandle_t *handle, long long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a long long int at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a long long int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a long long int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a38c30e6025b0bbff727baf588bbb2e1e"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddPtr" ref="a38c30e6025b0bbff727baf588bbb2e1e" args="(SPHLFLoggerHandle_t *handle, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a void* at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a void* (C pointer) value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a void* plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a515792e8e34afb8adef031270554b2ca"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddShort" ref="a515792e8e34afb8adef031270554b2ca" args="(SPHLFLoggerHandle_t *handle, short int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a short int at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>a short int value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if remaining entry space is insufficient to hold a short int plus any required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a645598dc1663b0f894a8ded3ddf48360"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAddString" ref="a645598dc1663b0f894a8ded3ddf48360" args="(SPHLFLoggerHandle_t *handle, char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryAddString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a C string at the next free location within the logger entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>pointer to a C string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 if the insert fails. For example if the string is too large for the remain entry free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a7652c49a66c32701f1cc6c00d34e7552"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryAllocStruct" ref="a7652c49a66c32701f1cc6c00d34e7552" args="(SPHLFLoggerHandle_t *handle, unsigned long __size, unsigned long __align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFlogEntryAllocStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__align</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate space for struct starting at the next free location within the logger entry. </p>
<p>Allocate space in the log entry for a multi-field structure or an array. The returned pointer can then be used to directly store data into struct fields or array entries. The SPHLOGENTRYALLOCSTRUCT can be used to insure the correct usage sizeof and __alignof__ to provide values for the __size and __align parameters.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be used instead of SPHLFLogEntryGetFreePtr if additional data may be added later to the same entry.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__size</em>&nbsp;</td><td>of the struct/array to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__align</em>&nbsp;</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cce137b9fc8602499ed399ec08f5ccf"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryCategory" ref="a5cce137b9fc8602499ed399ec08f5ccf" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry category for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c48e0285bce4b8bb43e91f1a75e0582"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryComplete" ref="a2c48e0285bce4b8bb43e91f1a75e0582" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. On out-of-order machines this barrier does not guarantee that all previous stores by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="ae13346f87e1ce85543fe11deba58f5f1"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryGetFreePtr" ref="ae13346f87e1ce85543fe11deba58f5f1" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFLogEntryGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address first free byte for the entry specified by the entry handle. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function should be used carefully. It is not safe to use if other application functions may need to update the same entry. It is also not safe to use for software that needs to cross platform because it does not handle platform specific size and alignment requirements.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The SPHLOGENTRYALLOCSTRUCT/SPHLFlogEntryAllocStruct API is recommended for code that needs to operate cross platform.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a4506e4cabd88e840bcd1eb6c21db5fb3"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextChar" ref="a4506e4cabd88e840bcd1eb6c21db5fb3" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char SPHLFlogEntryGetNextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next char from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the char value if successful, 0 (NUL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a32aebb1f0bf1ca9e23da04a75e0e0f4b"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextDouble" ref="a32aebb1f0bf1ca9e23da04a75e0e0f4b" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SPHLFlogEntryGetNextDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next double from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the double value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ac57da95ad89d288785aca05a47a10e1a"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextFloat" ref="ac57da95ad89d288785aca05a47a10e1a" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SPHLFlogEntryGetNextFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next float from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the float value if successful, 0.0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a12dfbeb9a0018c51e2505aa873fcd0be"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextInt" ref="a12dfbeb9a0018c51e2505aa873fcd0be" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFlogEntryGetNextInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a463e1622565d7283bf6d703b70dc29bd"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextLong" ref="a463e1622565d7283bf6d703b70dc29bd" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long SPHLFlogEntryGetNextLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a32cc210c045df8a4045ad0daa244b085"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextLongLong" ref="a32cc210c045df8a4045ad0daa244b085" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SPHLFlogEntryGetNextLongLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next long long int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the long long int value if successful,0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="afe1e9561a8fdff0a138bdc94b2059423"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextPtr" ref="afe1e9561a8fdff0a138bdc94b2059423" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFlogEntryGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next void* from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the void* value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="aec8fef3ab978abab9d817226a26b8ca5"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextShort" ref="aec8fef3ab978abab9d817226a26b8ca5" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short int SPHLFlogEntryGetNextShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next short int from the logger entry via the current next value pointer. Leading bytes may be skipped to get the required alignment. The internal next value pointer is advanced to the next location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the short int value if successful, 0 if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="a88f037eecc7692424c3b4ca7f10ea96f"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetNextString" ref="a88f037eecc7692424c3b4ca7f10ea96f" args="(SPHLFLoggerHandle_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* SPHLFlogEntryGetNextString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the pointer to the next C string from the logger entry via the current next value pointer. The internal next value pointer is advanced to the next location after the string NUL char. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the C string pointer value if successful, 0 (NULL) if the get fails. For example if the next is at the end of the Logger entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1d5f149afbb63a90d2bf2a461936a06"></a><!-- doxytag: member="sphlflogentry.h::SPHLFlogEntryGetStructPtr" ref="ab1d5f149afbb63a90d2bf2a461936a06" args="(SPHLFLoggerHandle_t *handle, unsigned long __size, unsigned long __align)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFlogEntryGetStructPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>__align</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the correctly aligned pointer for a struct or array starting at the next free location within the logger entry. </p>
<p>The entries next pointer is adjusted for alignment and returned. The entries next pointer and remaining fields are updated for the next field following the struct/array.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The SPHLOGENTRYGETSTRUCTPTR can be used to insure the correct usage sizeof and __alignof__ to provide values for the __size and __align parameters.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__size</em>&nbsp;</td><td>of the struct/array to allocate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>__align</em>&nbsp;</td><td>alignment requirement of the struct/array space to allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of the allocated free space. NULL indicates failure. For example if remaining entry space is insufficient to hold the struct at the required alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6f50aa6c65f7862071066588efeaad"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryHeader" ref="aee6f50aa6c65f7862071066588efeaad" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSPHLFLogHeader__t.html">SPHLFLogHeader_t</a>* SPHLFLogEntryHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address for the entry header specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address from the entry header, if the entry was valid. Otherwise return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a24b5c418e935b72ee0c7fe5c803e0cf0"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryIsComplete" ref="a24b5c418e935b72ee0c7fe5c803e0cf0" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d07e65a75a3b139982167edaf910696"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryIsTimestamped" ref="a8d07e65a75a3b139982167edaf910696" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a8664b111329ebc341e57e4c79ae2e5ab"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryPID" ref="a8664b111329ebc341e57e4c79ae2e5ab" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFLogEntryPID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the process ID for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the PID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a242ad8d63fd2bb13b23a5e2665545d25"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryStrongComplete" ref="a242ad8d63fd2bb13b23a5e2665545d25" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryStrongComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="aa31c35c29c2aa7ff9744190687f8b3d5"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntrySubcat" ref="aa31c35c29c2aa7ff9744190687f8b3d5" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntrySubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry sub-category for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ab175a33b9473897159133b2deb67ea47"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryTID" ref="ab175a33b9473897159133b2deb67ea47" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphlfentry_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a> SPHLFLogEntryTID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the thread ID for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the TID from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a18b9105fb237a06271031c7aaa6fc96b"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryTimeStamp" ref="a18b9105fb237a06271031c7aaa6fc96b" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a> SPHLFLogEntryTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the time stamp value for the entry specified by the entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the time stamp value from the entry, if the entry was valid and time stamped. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a56b54482f6d8acaff0d4ef3fb9b1afe8"></a><!-- doxytag: member="sphlflogentry.h::SPHLFLogEntryWeakComplete" ref="a56b54482f6d8acaff0d4ef3fb9b1afe8" args="(SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFLogEntryWeakComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. No memory barriers are performance. On out-of-order machines there are no guarantee that all previous stores by this thread are visible to other threads. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Logger Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 10 Mar 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
