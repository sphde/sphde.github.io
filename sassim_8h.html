<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sassim.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sassim.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core applications.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
</div>
<p><a href="sassim_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6fe774501e33d06b7dcee51d6b54bd22"><td class="memItemLeft" align="right" valign="top">typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6fe774501e33d06b7dcee51d6b54bd22">sasseg_t</a></td></tr>
<tr class="memdesc:a6fe774501e33d06b7dcee51d6b54bd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAS segment ID.  <a href="#a6fe774501e33d06b7dcee51d6b54bd22">More...</a><br /></td></tr>
<tr class="separator:a6fe774501e33d06b7dcee51d6b54bd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ee7be9d68e029d74d6c710c6693bdbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a9ee7be9d68e029d74d6c710c6693bdbb">getMemLow</a> ()</td></tr>
<tr class="memdesc:a9ee7be9d68e029d74d6c710c6693bdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Region's lowest memory address.  <a href="#a9ee7be9d68e029d74d6c710c6693bdbb">More...</a><br /></td></tr>
<tr class="separator:a9ee7be9d68e029d74d6c710c6693bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2371a5b9bb2b4e7acf2fc7385359e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6a2371a5b9bb2b4e7acf2fc7385359e4">getMemHigh</a> ()</td></tr>
<tr class="memdesc:a6a2371a5b9bb2b4e7acf2fc7385359e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Region's highest memory address.  <a href="#a6a2371a5b9bb2b4e7acf2fc7385359e4">More...</a><br /></td></tr>
<tr class="separator:a6a2371a5b9bb2b4e7acf2fc7385359e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db2f431926798a96ec7f96ecaa1c7da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0db2f431926798a96ec7f96ecaa1c7da">setSASmemrange</a> (unsigned long low, unsigned long high)</td></tr>
<tr class="memdesc:a0db2f431926798a96ec7f96ecaa1c7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Region's low/high memory address for testing.  <a href="#a0db2f431926798a96ec7f96ecaa1c7da">More...</a><br /></td></tr>
<tr class="separator:a0db2f431926798a96ec7f96ecaa1c7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2261a12b0eab211c7674873cf90ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd">SASJoinRegion</a> ()</td></tr>
<tr class="memdesc:afe2261a12b0eab211c7674873cf90ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join this process to a SAS Region.  <a href="#afe2261a12b0eab211c7674873cf90ebd">More...</a><br /></td></tr>
<tr class="separator:afe2261a12b0eab211c7674873cf90ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b000ff09648bb379c63cdcb85613010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a2b000ff09648bb379c63cdcb85613010">SASJoinRegionByName</a> (const char *store_name)</td></tr>
<tr class="memdesc:a2b000ff09648bb379c63cdcb85613010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join this process to a named SAS Region.  <a href="#a2b000ff09648bb379c63cdcb85613010">More...</a><br /></td></tr>
<tr class="separator:a2b000ff09648bb379c63cdcb85613010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55fd13bce1d0dbbf704604d7d8147c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6b55fd13bce1d0dbbf704604d7d8147c">SASBlockAlloc</a> (unsigned long blockSize)</td></tr>
<tr class="memdesc:a6b55fd13bce1d0dbbf704604d7d8147c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory within SAS Storage.  <a href="#a6b55fd13bce1d0dbbf704604d7d8147c">More...</a><br /></td></tr>
<tr class="separator:a6b55fd13bce1d0dbbf704604d7d8147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0978a3cd41a54163c376853dcdd399db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0978a3cd41a54163c376853dcdd399db">SASBlockDealloc</a> (void *blockAddr, unsigned long blockSize)</td></tr>
<tr class="memdesc:a0978a3cd41a54163c376853dcdd399db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate a block of memory within SAS Storage.  <a href="#a0978a3cd41a54163c376853dcdd399db">More...</a><br /></td></tr>
<tr class="separator:a0978a3cd41a54163c376853dcdd399db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c3107b41b3cfc0a276de960d181248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a99c3107b41b3cfc0a276de960d181248">SASListFreeRegion</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr class="memdesc:a99c3107b41b3cfc0a276de960d181248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lists of currently free segment block addresses and sizes.  <a href="#a99c3107b41b3cfc0a276de960d181248">More...</a><br /></td></tr>
<tr class="separator:a99c3107b41b3cfc0a276de960d181248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92db8198695dfcb62977c64be3a8c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ac92db8198695dfcb62977c64be3a8c28">SASListAllocatedRegion</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr class="memdesc:ac92db8198695dfcb62977c64be3a8c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lists of currently allocated segment block addresses and sizes.  <a href="#ac92db8198695dfcb62977c64be3a8c28">More...</a><br /></td></tr>
<tr class="separator:ac92db8198695dfcb62977c64be3a8c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b65a4d3e7a4cd8233dee60b99f74dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a3b65a4d3e7a4cd8233dee60b99f74dc6">SASListInUseMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr class="memdesc:a3b65a4d3e7a4cd8233dee60b99f74dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lists of currently allocated block addresses and sizes.  <a href="#a3b65a4d3e7a4cd8233dee60b99f74dc6">More...</a><br /></td></tr>
<tr class="separator:a3b65a4d3e7a4cd8233dee60b99f74dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942ed7470f957706261b8914799419f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a942ed7470f957706261b8914799419f7">SASListFreeMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr class="memdesc:a942ed7470f957706261b8914799419f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lists of freed block addresses and sizes.  <a href="#a942ed7470f957706261b8914799419f7">More...</a><br /></td></tr>
<tr class="separator:a942ed7470f957706261b8914799419f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d2ace2092f1ed71b5524ce91fa4787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a62d2ace2092f1ed71b5524ce91fa4787">SASListUncommittedMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr class="memdesc:a62d2ace2092f1ed71b5524ce91fa4787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lists of currently uncommitted block addresses and sizes.  <a href="#a62d2ace2092f1ed71b5524ce91fa4787">More...</a><br /></td></tr>
<tr class="separator:a62d2ace2092f1ed71b5524ce91fa4787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14184c12f7d30c45ecd74086521d7f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a14184c12f7d30c45ecd74086521d7f2d">SASAnchorFreeSpace</a> ()</td></tr>
<tr class="memdesc:a14184c12f7d30c45ecd74086521d7f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current number of free bytes within the Anchor blocks internal heap.  <a href="#a14184c12f7d30c45ecd74086521d7f2d">More...</a><br /></td></tr>
<tr class="separator:a14184c12f7d30c45ecd74086521d7f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598e1c54c419984be9c2bd6f60acb828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a598e1c54c419984be9c2bd6f60acb828">SASReset</a> ()</td></tr>
<tr class="memdesc:a598e1c54c419984be9c2bd6f60acb828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the SAS Region back to initial state.  <a href="#a598e1c54c419984be9c2bd6f60acb828">More...</a><br /></td></tr>
<tr class="separator:a598e1c54c419984be9c2bd6f60acb828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28c54a2a8ab8222e7b99cbd847b3369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ac28c54a2a8ab8222e7b99cbd847b3369">SASSeize</a> ()</td></tr>
<tr class="memdesc:ac28c54a2a8ab8222e7b99cbd847b3369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seize the anchor block master lock.  <a href="#ac28c54a2a8ab8222e7b99cbd847b3369">More...</a><br /></td></tr>
<tr class="separator:ac28c54a2a8ab8222e7b99cbd847b3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c6649d9069e7f0416f4b0909034f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a888c6649d9069e7f0416f4b0909034f0">SASRelease</a> ()</td></tr>
<tr class="memdesc:a888c6649d9069e7f0416f4b0909034f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the anchor block master lock.  <a href="#a888c6649d9069e7f0416f4b0909034f0">More...</a><br /></td></tr>
<tr class="separator:a888c6649d9069e7f0416f4b0909034f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f38ff92742def0e64b69a12475119c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a5f38ff92742def0e64b69a12475119c9">SASResetSem</a> ()</td></tr>
<tr class="memdesc:a5f38ff92742def0e64b69a12475119c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal Semaphores used by Seize/Release the SAS lock manager.  <a href="#a5f38ff92742def0e64b69a12475119c9">More...</a><br /></td></tr>
<tr class="separator:a5f38ff92742def0e64b69a12475119c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1855791a85725dad0cc2d3e216f90b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a1855791a85725dad0cc2d3e216f90b06">SASCleanUp</a> ()</td></tr>
<tr class="memdesc:a1855791a85725dad0cc2d3e216f90b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process wide cleanup for the SAS runtime. +* +*.  <a href="#a1855791a85725dad0cc2d3e216f90b06">More...</a><br /></td></tr>
<tr class="separator:a1855791a85725dad0cc2d3e216f90b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0832006705c5db69269310611dfc9a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ab0832006705c5db69269310611dfc9a6">SASThreadSetUp</a> ()</td></tr>
<tr class="memdesc:ab0832006705c5db69269310611dfc9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread specific setup for secondary thread accessing the SAS region.  <a href="#ab0832006705c5db69269310611dfc9a6">More...</a><br /></td></tr>
<tr class="separator:ab0832006705c5db69269310611dfc9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705cba3e65bf9db35a520400abbbc71f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a705cba3e65bf9db35a520400abbbc71f">SASThreadCleanUp</a> ()</td></tr>
<tr class="memdesc:a705cba3e65bf9db35a520400abbbc71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread specific cleanup for secondary thread accessing the SAS region.  <a href="#a705cba3e65bf9db35a520400abbbc71f">More...</a><br /></td></tr>
<tr class="separator:a705cba3e65bf9db35a520400abbbc71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b1a8a03cb51378317f81c44627f882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a44b1a8a03cb51378317f81c44627f882">SASRemove</a> ()</td></tr>
<tr class="memdesc:a44b1a8a03cb51378317f81c44627f882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the SAS Region.  <a href="#a44b1a8a03cb51378317f81c44627f882">More...</a><br /></td></tr>
<tr class="separator:a44b1a8a03cb51378317f81c44627f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dd30e5346f63f060cb0374c05921a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a18dd30e5346f63f060cb0374c05921a2">setSASFinder</a> (void *)</td></tr>
<tr class="memdesc:a18dd30e5346f63f060cb0374c05921a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the SAS finder pointer to a SAS block or utility object.  <a href="#a18dd30e5346f63f060cb0374c05921a2">More...</a><br /></td></tr>
<tr class="separator:a18dd30e5346f63f060cb0374c05921a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a35fae01cf9ca050fc9009c66d33c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62">getSASFinder</a> ()</td></tr>
<tr class="memdesc:a0a35fae01cf9ca050fc9009c66d33c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SAS finder address.  <a href="#a0a35fae01cf9ca050fc9009c66d33c62">More...</a><br /></td></tr>
<tr class="separator:a0a35fae01cf9ca050fc9009c66d33c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aea3f2fe03f4b74be814ce6bc59d54e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#aea3f2fe03f4b74be814ce6bc59d54e4c">sasClearOnDealloc</a></td></tr>
<tr class="memdesc:aea3f2fe03f4b74be814ce6bc59d54e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAS clear on block deallocate flag.  <a href="#aea3f2fe03f4b74be814ce6bc59d54e4c">More...</a><br /></td></tr>
<tr class="separator:aea3f2fe03f4b74be814ce6bc59d54e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core applications. </p>
<p>! Provides APIs to manage (setup and take-down) the SAS Region and backing store for cooperating processes. The region is a contiguous subrange of the process address space. The exact range varies based on the platform on the platform (as defined in sasconf.h).</p>
<p>Associated with an active SAS region is SAS Store which is a directory contain backing files which are memory mapped for the active portions of the region. A region is fully qualified by its SAS Store (directory) path. Processes joined to the same SAS story are accessing the same data at the same virtual address.</p>
<dl class="section note"><dt>Note</dt><dd>: For Linux this means memory mapping the pages from the kernel's file cache, and so we are sharing the same real pages across all partipating processes. This enables zero copy sharing and persistence.</dd></dl>
<p>Processes using different SAS Store paths are accessing logically different and disjoint regions. A process can only access one SAS region but there is no limit (other than files system capacity) to the number different SAS regions accessed by different groups of cooperating processes.</p>
<p>The SAS region address range and backing file store are managed via a power of 2 buddy system. Logically the region is divided into segments and blocks. Segment are a fixed power of 2 size (defined for the platform by sasconf.h) and alignment within the region. Blocks are a variable power of 2 size and have an alignment matching their size or better. Logically blocks are sub-allocated from allocated segments (have a backing file and can be mmaped) which are sub-allocated from the region.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>The current runtime restricts blocks to segment size or smaller. Creating larger blocks would require creating (power of 2) multiple segments (and backing files which have to memory mapped) while holding the global anchor block lock. Future releases may remove this restriction.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Segments and blocks inherit their virtual address (within the process) from the region. The region has a fixed starting address and segments always have a unique offset (and file index) within the region. The segment's file index is used to generate the unique file name within the SAS store directory. Obviously blocks inherit their virtual address from the containing segment which inherits from the region.</dd></dl>
<p>The segment is the granule of backing file allocation and memory mapping. Segment backing files are always extended to the full segment size at creation. This minimizes OS overhead by minimizing file system and memory mapping operations at runtime. Segments are not allocated (and backing files created) until additional block space is needed (when free block space, of the required size and alignment, in currently allocated segments, is depleted). This is done implicitly under the block allocate call.</p>
<dl class="section note"><dt>Note</dt><dd>SASJoinRegion and related functions (SASTHreadSetUp) establish a sigaction handler for signal SIGSEGV. This handles the case when one process, sharing a named Region allocates a new segment and backing. Other processes (sharing the same Region) are not immediately aware of this and need not perform any specific actions until or unless that process references data in that segment. This will generate a SIGSEGV and the SAS sigaction handler will attach this segment by mmapping the associated backing file into the faulting process at the assigned address.</dd>
<dd>
Applications that set their own signal to sigaction handlers for SIGSEGV should be aware of this and plan for proper nesting. Applications should establish their SIGSEGV handlers before joining. The SASJoinRegion will preserve the the "old action" as part of setting it own SIGSEGV handler.</dd>
<dd>
When the SPHDE runtime handler gets control it will verify that the faulting address is within the SAS Region. If it is not, it is likely a error or something that the application should handle itself. The SPHDE runtime handler will check if the "old action" was SIG_DFL or has it own signal or sigaction handler. If the application defined it own handler SPHDE will attempt to call that handler. Otherwise SPHDE runtime handler will print a back trace and exit the effected process (or thread).</dd></dl>
<p>The runtime also sets up shared memory segments (shmat) for SAS locks. SAS locks need to be shared but should not persist across reboot (like memory mapped files do). Different SAS stores must have independent locks (different lock segments). So lock segments are allocated/attached via shmget/shmat using a key generated (ftok) from the SAS Store path. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a6fe774501e33d06b7dcee51d6b54bd22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="sassim_8h.html#a6fe774501e33d06b7dcee51d6b54bd22">sasseg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAS segment ID. </p>
<p>Internal typedef that identifies a segment (process address range and backing file name) within the SAS Store (directory). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6a2371a5b9bb2b4e7acf2fc7385359e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned long getMemHigh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Region's highest memory address. </p>
<p>With <a class="el" href="sassim_8h.html#a9ee7be9d68e029d74d6c710c6693bdbb" title="Get the Region&#39;s lowest memory address. ">getMemLow()</a> defines the Region (starting process address and extent).</p>
<dl class="section return"><dt>Returns</dt><dd>the address value for the highest extent (+1) of the SAS Region. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee7be9d68e029d74d6c710c6693bdbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned long getMemLow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Region's lowest memory address. </p>
<p>With <a class="el" href="sassim_8h.html#a6a2371a5b9bb2b4e7acf2fc7385359e4" title="Get the Region&#39;s highest memory address. ">getMemHigh()</a> defines the Region (starting process address and extent).</p>
<dl class="section return"><dt>Returns</dt><dd>the address value for the lowest extent of the SAS Region. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a35fae01cf9ca050fc9009c66d33c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* getSASFinder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SAS finder address. </p>
<dl class="section return"><dt>Returns</dt><dd>the SAS finder address from the anchor block. </dd></dl>

</div>
</div>
<a class="anchor" id="a14184c12f7d30c45ecd74086521d7f2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> unsigned int SASAnchorFreeSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current number of free bytes within the Anchor blocks internal heap. </p>
<dl class="section note"><dt>Note</dt><dd>Low values can prevent managing large or fragmented regions. In this case consider increasing the anchor block size.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of free bytes remaining in the anchor blocks heap. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b55fd13bce1d0dbbf704604d7d8147c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SASBlockAlloc </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>blockSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block of memory within SAS Storage. </p>
<p>Blocks are allocated within the SAS region. Blocks must be a power of 2 in size (256 bytes &gt;= and &lt;= segmentSize). Allocated blocks always have alignment equal to their size or better.</p>
<p>If the required space is not found within a segment backed by existing files in the SAS store, a new segment backing file is created in the SAS store directory and mmaped into the region and added to region free space. This automatically extends the SAS Store as needed to satisfy block allocate requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockSize</td><td>size of the block to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the start of the allocated block, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a0978a3cd41a54163c376853dcdd399db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASBlockDealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>blockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate a block of memory within SAS Storage. </p>
<p>Blocks within the SAS Region are freed by adding the block range to the free list. Adjacent free blocks of equal size and appropriate alignment are combined into larger free blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of start of the block to be deallocated. </td></tr>
    <tr><td class="paramname">blockSize</td><td>size of the block to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1855791a85725dad0cc2d3e216f90b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASCleanUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process wide cleanup for the SAS runtime. +* +*. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not attempt to use SAS/SPH APIs or access the SAS region after this call. +* +* </dd>
<dd>
Threaded applications should pthread_join their child threads before this call. +* +* Unmap all SAS segments and detach the shmem segments used for locks. +* The runtime disables the sigsegv handler for the main thread. +*<ul>
<li></li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afe2261a12b0eab211c7674873cf90ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SASJoinRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join this process to a SAS Region. </p>
<p>Join this process to the SAS Region based on the anchor segment in the SAS Store (either the default '.' directory or the path specified in the environment variable SASSTOREPATH). The anchor segment contains the anchor block including the indexes that manage segments and (free and allocated) block space within the region.</p>
<p>If the backing file for the anchor segment does not exist in the SAS Store directory, the runtime creates a "SegmentSize" backing file and mmaps that file at SAS memLow. The lowest part of this segment is initialed as the SAS anchor block.</p>
<p>Otherwise the the runtime mmaps the anchor segment at memLow and proceeds to bring up the rest of the SAS environment. This includes mmaping additional segments from the SAS Store.</p>
<p>The join function also checks for, and if needed initializes, the matching lock segments. The lock segments are allocated/attached via shmget/shmat using a key generated from the SAS Store path. This insures that applications using different SAS stores also have independent lock segments. </p><pre class="fragment">@return a 0 value indicates success, otherwise failure.</pre> 
</div>
</div>
<a class="anchor" id="a2b000ff09648bb379c63cdcb85613010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SASJoinRegionByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>store_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join this process to a named SAS Region. </p>
<p>Join this process to the SAS Region based on the anchor segment backing file in the named SAS Store. The anchor segment contains the anchor block including the indexes that manage segments and (free and allocated) block space within the region.</p>
<p>If the backing file for the anchor segment does not exist in the SAS Store directory, the runtime creates a "SegmentSize" backing file and mmaps that file at SAS memLow. The lowest part of this segment is initialed as the SAS anchor block.</p>
<p>Otherwise the the runtime mmaps the anchor segment at memLow and proceeds to bring up the rest of the SAS environment. This includes mmaping additional segments from the SAS Store.</p>
<p>The join function also checks for, and if needed initializes, the matching lock segments. The lock segments are allocated/attached via shmat using a key generated from the SAS Store path. This insures that applications using different SAS stores also have independent lock segments.</p>
<p>Finally the runtime sets up as sigsegv handler. This allows the SAS runtime to automatically attach segments created by other processes in this SAS store.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store_name</td><td>C string containing the path to this SAS store directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicates success, otherwise failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ac92db8198695dfcb62977c64be3a8c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASListAllocatedRegion </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lists of currently allocated segment block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized segment blocks currently allocated within the region. It is possible for the allocated list to cover combined segment blocks of (power of 2) multiple segments. Blocks on the regions allocated list always represent segments with a backing file in the SAS Store directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td class="paramname">blockSize</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td class="paramname">count</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a942ed7470f957706261b8914799419f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASListFreeMem </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lists of freed block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks currently freed within the region. Blocks on the freed list are a sub range of existing segments with a backing file in the SAS Store directory. It is possible for the free list to cover combined blocks of multiple (power of 2) segments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td class="paramname">blockSize</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td class="paramname">count</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a99c3107b41b3cfc0a276de960d181248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASListFreeRegion </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lists of currently free segment block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized segment blocks in the regions free list. It is possible for the free list to cover combined segment blocks of (power of 2) multiple segments. Blocks on the regions free list will not have backing files in the SAS store directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td class="paramname">blockSize</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td class="paramname">count</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b65a4d3e7a4cd8233dee60b99f74dc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASListInUseMem </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lists of currently allocated block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks currently allocated within the region. Blocks on the allocated list are a sub range of existing segments with a backing file in the SAS Store directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td class="paramname">blockSize</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td class="paramname">count</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a62d2ace2092f1ed71b5524ce91fa4787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASListUncommittedMem </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lists of currently uncommitted block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks uncommitted blocks within the region. Uncommitted blocks are a sub range of existing segments with a backing file in the SAS Store directory, but have never been allocated. Newly created segments start as uncommitted storage and can be assumed to be initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockAddr</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td class="paramname">blockSize</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td class="paramname">count</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a888c6649d9069e7f0416f4b0909034f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASRelease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the anchor block master lock. </p>

</div>
</div>
<a class="anchor" id="a44b1a8a03cb51378317f81c44627f882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASRemove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the SAS Region. </p>
<dl class="section warning"><dt>Warning</dt><dd>SASRemove will result in the immediate lose of user data within the SAS Region.</dd></dl>
<p>Unmap all segments and delete all backing files. Remove the shmem segments used for locks. </p>

</div>
</div>
<a class="anchor" id="a598e1c54c419984be9c2bd6f60acb828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the SAS Region back to initial state. </p>
<dl class="section warning"><dt>Warning</dt><dd>SASReset will result in the immediate lose of user data within the SAS Region.</dd></dl>
<p>Unmap any segments and delete backing files beyond the anchor segment. Reinitialize the anchor block and lock segments to initial region state. </p>

</div>
</div>
<a class="anchor" id="a5f38ff92742def0e64b69a12475119c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASResetSem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the internal Semaphores used by Seize/Release the SAS lock manager. </p>
<dl class="section warning"><dt>Warning</dt><dd>Should not be called when multiple cooperating processes or threads are accessing the SAS region. Should only be used to recover from an application crash.</dd></dl>
<p>Reset internal semaphore to their initial state. </p>

</div>
</div>
<a class="anchor" id="ac28c54a2a8ab8222e7b99cbd847b3369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASSeize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seize the anchor block master lock. </p>
<p>Used to serialize access to the anchor block and internal data structures. </p>

</div>
</div>
<a class="anchor" id="a705cba3e65bf9db35a520400abbbc71f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASThreadCleanUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread specific cleanup for secondary thread accessing the SAS region. </p>
<p>For secondary threads that called <a class="el" href="sassim_8h.html#ab0832006705c5db69269310611dfc9a6" title="Thread specific setup for secondary thread accessing the SAS region. ">SASThreadSetUp()</a>, <a class="el" href="sassim_8h.html#a705cba3e65bf9db35a520400abbbc71f" title="Thread specific cleanup for secondary thread accessing the SAS region. ">SASThreadCleanUp()</a> should be called before thread exit. The runtime disables the sigsegv handler for this thread. </p>

</div>
</div>
<a class="anchor" id="ab0832006705c5db69269310611dfc9a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void SASThreadSetUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread specific setup for secondary thread accessing the SAS region. </p>
<dl class="section warning"><dt>Warning</dt><dd>Each secondary thread of a SAS/SPH application should call this function before accessing data within the SAS Region.</dd></dl>
<p>The runtime sets up a sigsegv handler for this thread. This allows the SAS runtime to automatically attach SAS segments created by other processes. </p>

</div>
</div>
<a class="anchor" id="a18dd30e5346f63f060cb0374c05921a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void setSASFinder </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the SAS finder pointer to a SAS block or utility object. </p>
<dl class="section warning"><dt>Warning</dt><dd>The finder address is a shared SAS resource and must point to a block or utility object within the SAS region.</dd></dl>
<p>Stores the region wide finder address within the anchor block.</p>
<dl class="section note"><dt>Note</dt><dd>the finder is normally a SPHContext containing name / address associations for application data and other utility objects with the SAS region. This helps the application find it's data and data created by cooperating applications during startup. While setting the finder to a context is normal it can be any data structure or other utility object useful to the application. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db2f431926798a96ec7f96ecaa1c7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void setSASmemrange </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Region's low/high memory address for testing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>defines the regions starting address. </td></tr>
    <tr><td class="paramname">high</td><td>defines the regions ending address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aea3f2fe03f4b74be814ce6bc59d54e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int sasClearOnDealloc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAS clear on block deallocate flag. </p>
<p>Internal flag that requests the SAS runtime to clear blocks as they are deallocated. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 11 2016 05:16:51 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
