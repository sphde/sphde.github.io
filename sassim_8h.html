<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sassim.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sassim.h File Reference</h1>
<p>Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core applications.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>

<p><a href="sassim_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6fe774501e33d06b7dcee51d6b54bd22">sasseg_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SAS segment ID.  <a href="#a6fe774501e33d06b7dcee51d6b54bd22"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a9ee7be9d68e029d74d6c710c6693bdbb">getMemLow</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Region's lowest memory address.  <a href="#a9ee7be9d68e029d74d6c710c6693bdbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6a2371a5b9bb2b4e7acf2fc7385359e4">getMemHigh</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Region's highest memory address.  <a href="#a6a2371a5b9bb2b4e7acf2fc7385359e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0db2f431926798a96ec7f96ecaa1c7da">setSASmemrange</a> (unsigned long low, unsigned long high)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Region's low/high memory address for testing.  <a href="#a0db2f431926798a96ec7f96ecaa1c7da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd">SASJoinRegion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join this process to a SAS Region.  <a href="#afe2261a12b0eab211c7674873cf90ebd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a2b000ff09648bb379c63cdcb85613010">SASJoinRegionByName</a> (const char *store_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join this process to a named SAS Region.  <a href="#a2b000ff09648bb379c63cdcb85613010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a6b55fd13bce1d0dbbf704604d7d8147c">SASBlockAlloc</a> (unsigned long blockSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a block of memory within SAS Storage.  <a href="#a6b55fd13bce1d0dbbf704604d7d8147c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0978a3cd41a54163c376853dcdd399db">SASBlockDealloc</a> (void *blockAddr, unsigned long blockSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate a block of memory within SAS Storage.  <a href="#a0978a3cd41a54163c376853dcdd399db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a99c3107b41b3cfc0a276de960d181248">SASListFreeRegion</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return lists of currently free segment block addresses and sizes.  <a href="#a99c3107b41b3cfc0a276de960d181248"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ac92db8198695dfcb62977c64be3a8c28">SASListAllocatedRegion</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return lists of currently allocated segment block addresses and sizes.  <a href="#ac92db8198695dfcb62977c64be3a8c28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a3b65a4d3e7a4cd8233dee60b99f74dc6">SASListInUseMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return lists of currently allocated block addresses and sizes.  <a href="#a3b65a4d3e7a4cd8233dee60b99f74dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a942ed7470f957706261b8914799419f7">SASListFreeMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return lists of freed block addresses and sizes.  <a href="#a942ed7470f957706261b8914799419f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a62d2ace2092f1ed71b5524ce91fa4787">SASListUncommittedMem</a> (void **blockAddr, unsigned long *blockSize, int *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return lists of currently uncommitted block addresses and sizes.  <a href="#a62d2ace2092f1ed71b5524ce91fa4787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a14184c12f7d30c45ecd74086521d7f2d">SASAnchorFreeSpace</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current number of free bytes within the Anchor blocks internal heap.  <a href="#a14184c12f7d30c45ecd74086521d7f2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a598e1c54c419984be9c2bd6f60acb828">SASReset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the SAS Region back to initial state.  <a href="#a598e1c54c419984be9c2bd6f60acb828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ac28c54a2a8ab8222e7b99cbd847b3369">SASSeize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seize the anchor block master lock.  <a href="#ac28c54a2a8ab8222e7b99cbd847b3369"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a888c6649d9069e7f0416f4b0909034f0">SASRelease</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the anchor block master lock.  <a href="#a888c6649d9069e7f0416f4b0909034f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a5f38ff92742def0e64b69a12475119c9">SASResetSem</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the internal Semaphores used by Seize/Release the SAS lock manager.  <a href="#a5f38ff92742def0e64b69a12475119c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a1855791a85725dad0cc2d3e216f90b06">SASCleanUp</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process wide cleanup for the SAS runtime. +* +*.  <a href="#a1855791a85725dad0cc2d3e216f90b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#ab0832006705c5db69269310611dfc9a6">SASThreadSetUp</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread specific setup for secondary thread accessing the SAS region.  <a href="#ab0832006705c5db69269310611dfc9a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a705cba3e65bf9db35a520400abbbc71f">SASThreadCleanUp</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread specific cleanup for secondary thread accessing the SAS region.  <a href="#a705cba3e65bf9db35a520400abbbc71f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a44b1a8a03cb51378317f81c44627f882">SASRemove</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the SAS Region.  <a href="#a44b1a8a03cb51378317f81c44627f882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a18dd30e5346f63f060cb0374c05921a2">setSASFinder</a> (void *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the SAS finder pointer to a SAS block or utility object.  <a href="#a18dd30e5346f63f060cb0374c05921a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#a0a35fae01cf9ca050fc9009c66d33c62">getSASFinder</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the SAS finder address.  <a href="#a0a35fae01cf9ca050fc9009c66d33c62"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sassim_8h.html#aea3f2fe03f4b74be814ce6bc59d54e4c">sasClearOnDealloc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SAS clear on block deallocate flag.  <a href="#aea3f2fe03f4b74be814ce6bc59d54e4c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Address Space, base runtime for shared and persistent memory for multi-thread/multi-core applications. </p>
<p>! Provides APIs to manage (setup and take-down) the SAS Region and backing store for cooperating processes. The region is a contiguous subrange of the process address space. The exact range varies based on the platform on the platform (as defined in sasconf.h).</p>
<p>Associated with an active SAS region is SAS Store which is a directory contain backing files which are memory mapped for the active portions of the region. A region is fully qualified by its SAS Store (directory) path. Processes joined to the same SAS story are accessing the same data at the same virtual address.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>: For Linux this means memory mapping the pages from the kernel's file cache, and so we are sharing the same real pages across all partipating processes. This enables zero copy sharing and persistence.</dd></dl>
<p>Processes using different SAS Store paths are accessing logically different and disjoint regions. A process can only access one SAS region but there is no limit (other than files system capacity) to the number different SAS regions accessed by different groups of cooperating processes.</p>
<p>The SAS region address range and backing file store are managed via a power of 2 buddy system. Logically the region is divided into segments and blocks. Segment are a fixed power of 2 size (defined for the platform by sasconf.h) and alignment within the region. Blocks are a variable power of 2 size and have an alignment matching their size or better. Logically blocks are sub-allocated from allocated segments (have a backing file and can be mmaped) which are sub-allocated from the region.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>The current runtime restricts blocks to segment size or smaller. Creating larger blocks would require creating (power of 2) multiple segments (and backing files which have to memory mapped) while holding the global anchor block lock. Future releases may remove this restriction.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Segments and blocks inherit their virtual address (within the process) from the region. The region has a fixed starting address and segments always have a unique offset (and file index) within the region. The segment's file index is used to generate the unique file name within the SAS store directory. Obviously blocks inherit their virtual address from the containing segment which inherits from the region.</dd></dl>
<p>The segment is the granule of backing file allocation and memory mapping. Segment backing files are always extended to the full segment size at creation. This minimizes OS overhead by minimizing file system and memory mapping operations at runtime. Segments are not allocated (and backing files created) until additional block space is needed (when free block space, of the required size and alignment, in currently allocated segments, is depleted). This is done implicitly under the block allocate call.</p>
<p>The runtime also sets up shared memory segments (shmat) for SAS locks. SAS locks need to be shared but should not persist across reboot (like memory mapped files do). Different SAS stores must have independent locks (different lock segments). So lock segments are allocated/attached via shmget/shmat using a key generated (ftok) from the SAS Store path. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a6fe774501e33d06b7dcee51d6b54bd22"></a><!-- doxytag: member="sassim.h::sasseg_t" ref="a6fe774501e33d06b7dcee51d6b54bd22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="sassim_8h.html#a6fe774501e33d06b7dcee51d6b54bd22">sasseg_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SAS segment ID. </p>
<p>Internal typedef that identifies a segment (process address range and backing file name) within the SAS Store (directory). </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6a2371a5b9bb2b4e7acf2fc7385359e4"></a><!-- doxytag: member="sassim.h::getMemHigh" ref="a6a2371a5b9bb2b4e7acf2fc7385359e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ unsigned long getMemHigh </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Region's highest memory address. </p>
<p>With <a class="el" href="sassim_8h.html#a9ee7be9d68e029d74d6c710c6693bdbb" title="Get the Region&#39;s lowest memory address.">getMemLow()</a> defines the Region (starting process address and extent).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address value for the highest extent (+1) of the SAS Region. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee7be9d68e029d74d6c710c6693bdbb"></a><!-- doxytag: member="sassim.h::getMemLow" ref="a9ee7be9d68e029d74d6c710c6693bdbb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ unsigned long getMemLow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Region's lowest memory address. </p>
<p>With <a class="el" href="sassim_8h.html#a6a2371a5b9bb2b4e7acf2fc7385359e4" title="Get the Region&#39;s highest memory address.">getMemHigh()</a> defines the Region (starting process address and extent).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address value for the lowest extent of the SAS Region. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a35fae01cf9ca050fc9009c66d33c62"></a><!-- doxytag: member="sassim.h::getSASFinder" ref="a0a35fae01cf9ca050fc9009c66d33c62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* getSASFinder </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the SAS finder address. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the SAS finder address from the anchor block. </dd></dl>

</div>
</div>
<a class="anchor" id="a14184c12f7d30c45ecd74086521d7f2d"></a><!-- doxytag: member="sassim.h::SASAnchorFreeSpace" ref="a14184c12f7d30c45ecd74086521d7f2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ unsigned int SASAnchorFreeSpace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current number of free bytes within the Anchor blocks internal heap. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Low values can prevent managing large or fragmented regions. In this case consider increasing the anchor block size.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of free bytes remaining in the anchor blocks heap. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b55fd13bce1d0dbbf704604d7d8147c"></a><!-- doxytag: member="sassim.h::SASBlockAlloc" ref="a6b55fd13bce1d0dbbf704604d7d8147c" args="(unsigned long blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASBlockAlloc </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a block of memory within SAS Storage. </p>
<p>Blocks are allocated within the SAS region. Blocks must be a power of 2 in size (256 bytes &gt;= and &lt;= segmentSize). Allocated blocks always have alignment equal to their size or better.</p>
<p>If the required space is not found within a segment backed by existing files in the SAS store, a new segment backing file is created in the SAS store directory and mmaped into the region and added to region free space. This automatically extends the SAS Store as needed to satisfy block allocate requests.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>size of the block to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the start of the allocated block, or NULL if the allocation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a0978a3cd41a54163c376853dcdd399db"></a><!-- doxytag: member="sassim.h::SASBlockDealloc" ref="a0978a3cd41a54163c376853dcdd399db" args="(void *blockAddr, unsigned long blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASBlockDealloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate a block of memory within SAS Storage. </p>
<p>Blocks within the SAS Region are freed by adding the block range to the free list. Adjacent free blocks of equal size and appropriate alignment are combined into larger free blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of start of the block to be deallocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>size of the block to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1855791a85725dad0cc2d3e216f90b06"></a><!-- doxytag: member="sassim.h::SASCleanUp" ref="a1855791a85725dad0cc2d3e216f90b06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASCleanUp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process wide cleanup for the SAS runtime. +* +*. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Do not attempt to use SAS/SPH APIs or access the SAS region after this call. +* +* </dd>
<dd>
Threaded applications should pthread_join their child threads before this call. +* +* Unmap all SAS segments and detach the shmem segments used for locks. +* The runtime disables the sigsegv handler for the main thread. +* + </dd></dl>

</div>
</div>
<a class="anchor" id="afe2261a12b0eab211c7674873cf90ebd"></a><!-- doxytag: member="sassim.h::SASJoinRegion" ref="afe2261a12b0eab211c7674873cf90ebd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASJoinRegion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join this process to a SAS Region. </p>
<p>Join this process to the SAS Region based on the anchor segment in the SAS Store (either the default '.' directory or the path specified in the environment variable SASSTOREPATH). The anchor segment contains the anchor block including the indexes that manage segments and (free and allocated) block space within the region.</p>
<p>If the backing file for the anchor segment does not exist in the SAS Store directory, the runtime creates a "SegmentSize" backing file and mmaps that file at SAS memLow. The lowest part of this segment is initialed as the SAS anchor block.</p>
<p>Otherwise the the runtime mmaps the anchor segment at memLow and proceeds to bring up the rest of the SAS environment. This includes mmaping additional segments from the SAS Store.</p>
<p>The join function also checks for, and if needed initializes, the matching lock segments. The lock segments are allocated/attached via shmget/shmat using a key generated from the SAS Store path. This insures that applications using different SAS stores also have independent lock segments.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success, otherwise failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b000ff09648bb379c63cdcb85613010"></a><!-- doxytag: member="sassim.h::SASJoinRegionByName" ref="a2b000ff09648bb379c63cdcb85613010" args="(const char *store_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASJoinRegionByName </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>store_name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join this process to a named SAS Region. </p>
<p>Join this process to the SAS Region based on the anchor segment backing file in the named SAS Store. The anchor segment contains the anchor block including the indexes that manage segments and (free and allocated) block space within the region.</p>
<p>If the backing file for the anchor segment does not exist in the SAS Store directory, the runtime creates a "SegmentSize" backing file and mmaps that file at SAS memLow. The lowest part of this segment is initialed as the SAS anchor block.</p>
<p>Otherwise the the runtime mmaps the anchor segment at memLow and proceeds to bring up the rest of the SAS environment. This includes mmaping additional segments from the SAS Store.</p>
<p>The join function also checks for, and if needed initializes, the matching lock segments. The lock segments are allocated/attached via shmat using a key generated from the SAS Store path. This insures that applications using different SAS stores also have independent lock segments.</p>
<p>Finally the runtime sets up as sigsegv handler. This allows the SAS runtime to automatically attach segments created by other processes in this SAS store.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>store_name</em>&nbsp;</td><td>C string containing the path to this SAS store directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicates success, otherwise failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ac92db8198695dfcb62977c64be3a8c28"></a><!-- doxytag: member="sassim.h::SASListAllocatedRegion" ref="ac92db8198695dfcb62977c64be3a8c28" args="(void **blockAddr, unsigned long *blockSize, int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASListAllocatedRegion </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lists of currently allocated segment block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized segment blocks currently allocated within the region. It is possible for the allocated list to cover combined segment blocks of (power of 2) multiple segments. Blocks on the regions allocated list always represent segments with a backing file in the SAS Store directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a942ed7470f957706261b8914799419f7"></a><!-- doxytag: member="sassim.h::SASListFreeMem" ref="a942ed7470f957706261b8914799419f7" args="(void **blockAddr, unsigned long *blockSize, int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASListFreeMem </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lists of freed block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks currently freed within the region. Blocks on the freed list are a sub range of existing segments with a backing file in the SAS Store directory. It is possible for the free list to cover combined blocks of multiple (power of 2) segments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a99c3107b41b3cfc0a276de960d181248"></a><!-- doxytag: member="sassim.h::SASListFreeRegion" ref="a99c3107b41b3cfc0a276de960d181248" args="(void **blockAddr, unsigned long *blockSize, int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASListFreeRegion </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lists of currently free segment block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized segment blocks in the regions free list. It is possible for the free list to cover combined segment blocks of (power of 2) multiple segments. Blocks on the regions free list will not have backing files in the SAS store directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b65a4d3e7a4cd8233dee60b99f74dc6"></a><!-- doxytag: member="sassim.h::SASListInUseMem" ref="a3b65a4d3e7a4cd8233dee60b99f74dc6" args="(void **blockAddr, unsigned long *blockSize, int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASListInUseMem </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lists of currently allocated block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks currently allocated within the region. Blocks on the allocated list are a sub range of existing segments with a backing file in the SAS Store directory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a62d2ace2092f1ed71b5524ce91fa4787"></a><!-- doxytag: member="sassim.h::SASListUncommittedMem" ref="a62d2ace2092f1ed71b5524ce91fa4787" args="(void **blockAddr, unsigned long *blockSize, int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASListUncommittedMem </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lists of currently uncommitted block addresses and sizes. </p>
<p>Returns the addresses and sizes of power of 2 sized blocks uncommitted blocks within the region. Uncommitted blocks are a sub range of existing segments with a backing file in the SAS Store directory, but have never been allocated. Newly created segments start as uncommitted storage and can be assumed to be initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockAddr</em>&nbsp;</td><td>address of an array or addresses to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>address of an array of block size values to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>address of a int to be filled in with the actual count of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>should change this API to pass the max array size as a parm and return the actual count. </dd></dl>

</div>
</div>
<a class="anchor" id="a888c6649d9069e7f0416f4b0909034f0"></a><!-- doxytag: member="sassim.h::SASRelease" ref="a888c6649d9069e7f0416f4b0909034f0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASRelease </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the anchor block master lock. </p>

</div>
</div>
<a class="anchor" id="a44b1a8a03cb51378317f81c44627f882"></a><!-- doxytag: member="sassim.h::SASRemove" ref="a44b1a8a03cb51378317f81c44627f882" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASRemove </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the SAS Region. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>SASRemove will result in the immediate lose of user data within the SAS Region.</dd></dl>
<p>Unmap all segments and delete all backing files. Remove the shmem segments used for locks. </p>

</div>
</div>
<a class="anchor" id="a598e1c54c419984be9c2bd6f60acb828"></a><!-- doxytag: member="sassim.h::SASReset" ref="a598e1c54c419984be9c2bd6f60acb828" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASReset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the SAS Region back to initial state. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>SASReset will result in the immediate lose of user data within the SAS Region.</dd></dl>
<p>Unmap any segments and delete backing files beyond the anchor segment. Reinitialize the anchor block and lock segments to initial region state. </p>

</div>
</div>
<a class="anchor" id="a5f38ff92742def0e64b69a12475119c9"></a><!-- doxytag: member="sassim.h::SASResetSem" ref="a5f38ff92742def0e64b69a12475119c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASResetSem </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the internal Semaphores used by Seize/Release the SAS lock manager. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Should not be called when multiple cooperating processes or threads are accessing the SAS region. Should only be used to recover from an application crash.</dd></dl>
<p>Reset internal semaphore to their initial state. </p>

</div>
</div>
<a class="anchor" id="ac28c54a2a8ab8222e7b99cbd847b3369"></a><!-- doxytag: member="sassim.h::SASSeize" ref="ac28c54a2a8ab8222e7b99cbd847b3369" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASSeize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seize the anchor block master lock. </p>
<p>Used to serialize access to the anchor block and internal data structures. </p>

</div>
</div>
<a class="anchor" id="a705cba3e65bf9db35a520400abbbc71f"></a><!-- doxytag: member="sassim.h::SASThreadCleanUp" ref="a705cba3e65bf9db35a520400abbbc71f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASThreadCleanUp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread specific cleanup for secondary thread accessing the SAS region. </p>
<p>For secondary threads that called <a class="el" href="sassim_8h.html#ab0832006705c5db69269310611dfc9a6" title="Thread specific setup for secondary thread accessing the SAS region.">SASThreadSetUp()</a>, <a class="el" href="sassim_8h.html#a705cba3e65bf9db35a520400abbbc71f" title="Thread specific cleanup for secondary thread accessing the SAS region.">SASThreadCleanUp()</a> should be called before thread exit. The runtime disables the sigsegv handler for this thread. </p>

</div>
</div>
<a class="anchor" id="ab0832006705c5db69269310611dfc9a6"></a><!-- doxytag: member="sassim.h::SASThreadSetUp" ref="ab0832006705c5db69269310611dfc9a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASThreadSetUp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Thread specific setup for secondary thread accessing the SAS region. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Each secondary thread of a SAS/SPH application should call this function before accessing data within the SAS Region.</dd></dl>
<p>The runtime sets up a sigsegv handler for this thread. This allows the SAS runtime to automatically attach SAS segments created by other processes. </p>

</div>
</div>
<a class="anchor" id="a18dd30e5346f63f060cb0374c05921a2"></a><!-- doxytag: member="sassim.h::setSASFinder" ref="a18dd30e5346f63f060cb0374c05921a2" args="(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void setSASFinder </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the SAS finder pointer to a SAS block or utility object. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The finder address is a shared SAS resource and must point to a block or utility object within the SAS region.</dd></dl>
<p>Stores the region wide finder address within the anchor block.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the finder is normally a SPHContext containing name / address associations for application data and other utility objects with the SAS region. This helps the application find it's data and data created by cooperating applications during startup. While setting the finder to a context is normal it can be any data structure or other utility object useful to the application. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db2f431926798a96ec7f96ecaa1c7da"></a><!-- doxytag: member="sassim.h::setSASmemrange" ref="a0db2f431926798a96ec7f96ecaa1c7da" args="(unsigned long low, unsigned long high)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void setSASmemrange </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>high</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Region's low/high memory address for testing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>low</em>&nbsp;</td><td>defines the regions starting address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>high</em>&nbsp;</td><td>defines the regions ending address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aea3f2fe03f4b74be814ce6bc59d54e4c"></a><!-- doxytag: member="sassim.h::sasClearOnDealloc" ref="aea3f2fe03f4b74be814ce6bc59d54e4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int <a class="el" href="sassim_8h.html#aea3f2fe03f4b74be814ce6bc59d54e4c">sasClearOnDealloc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SAS clear on block deallocate flag. </p>
<p>Internal flag that requests the SAS runtime to clear blocks as they are deallocated. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 7 Jan 2015 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
