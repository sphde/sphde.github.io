<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlflogger.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphlflogger.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, logger. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Loggers (SPHLFLogger_t).  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sphtimer_8h_source.html">sphtimer.h</a>&quot;</code><br />
</div>
<p><a href="sphlflogger_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsphLogEntryLayout__t.html">sphLogEntryLayout_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="unionsphLogEntry__t.html" title="Union of Entry details with 32-bit word for atomic update. ">sphLogEntry_t</a>. Fields defining the entry details word.  <a href="structsphLogEntryLayout__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionsphLogEntry__t.html">sphLogEntry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of Entry details with 32-bit word for atomic update.  <a href="unionsphLogEntry__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFLogHeader__t.html">SPHLFLogHeader_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free Logger Entry Header.  <a href="structSPHLFLogHeader__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free Logger Entry Handle.  <a href="structSPHLFLoggerHandle__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free Logger Iterator.  <a href="structSPHLFLogIterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4d08a6f74d96b695afefd03854839b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr class="memdesc:a4d08a6f74d96b695afefd03854839b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore this macro behined the curtain <br /></td></tr>
<tr class="separator:a4d08a6f74d96b695afefd03854839b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3d02d79c22cfb86d3505a6095f719a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac3d02d79c22cfb86d3505a6095f719a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aac3d02d79c22cfb86d3505a6095f719a">SPHLFLOGGER_CIRCULAR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:aac3d02d79c22cfb86d3505a6095f719a"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for circular log buffers <br /></td></tr>
<tr class="separator:aac3d02d79c22cfb86d3505a6095f719a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e689ef2f88b19f0e7bfb870b3dddc91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e689ef2f88b19f0e7bfb870b3dddc91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a5e689ef2f88b19f0e7bfb870b3dddc91">SPHLFLOGGER_CIRCULAR_WRAPED</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:a5e689ef2f88b19f0e7bfb870b3dddc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped <br /></td></tr>
<tr class="separator:a5e689ef2f88b19f0e7bfb870b3dddc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5e930696a0a2e7e787181346a97377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d5e930696a0a2e7e787181346a97377"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a5d5e930696a0a2e7e787181346a97377">SPHLFLOGGER_CIRCULAR_NOTFIRST</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:a5d5e930696a0a2e7e787181346a97377"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag set when circular log buffers have wrapped multiple times <br /></td></tr>
<tr class="separator:a5d5e930696a0a2e7e787181346a97377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbc3417708abab49203e2cbd5b99d06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefbc3417708abab49203e2cbd5b99d06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aefbc3417708abab49203e2cbd5b99d06">SPHLFLOGGER_CACHE_PREFETCH0</a>&#160;&#160;&#160;(1&lt;&lt;3)</td></tr>
<tr class="memdesc:aefbc3417708abab49203e2cbd5b99d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the immediate (0 offset) cache-line <br /></td></tr>
<tr class="separator:aefbc3417708abab49203e2cbd5b99d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d9be4ee9f3888dda70594a8e4ffc01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4d9be4ee9f3888dda70594a8e4ffc01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aa4d9be4ee9f3888dda70594a8e4ffc01">SPHLFLOGGER_CACHE_PREFETCH1</a>&#160;&#160;&#160;(1&lt;&lt;4)</td></tr>
<tr class="memdesc:aa4d9be4ee9f3888dda70594a8e4ffc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options flag for prefetching the next (line size offset) cache-line <br /></td></tr>
<tr class="separator:aa4d9be4ee9f3888dda70594a8e4ffc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d790503c841b146406f82a937d325"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a535d790503c841b146406f82a937d325">SPHLFLOGGER_CIRCULAR_RESETMASK</a></td></tr>
<tr class="memdesc:a535d790503c841b146406f82a937d325"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal options mask flag used the reset circular log buffers  <a href="#a535d790503c841b146406f82a937d325">More...</a><br /></td></tr>
<tr class="separator:a535d790503c841b146406f82a937d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a646a159bf80760fb1554c78e9a34efec"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a></td></tr>
<tr class="memdesc:a646a159bf80760fb1554c78e9a34efec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an instance of SPH Lock Free Logger.  <a href="#a646a159bf80760fb1554c78e9a34efec">More...</a><br /></td></tr>
<tr class="separator:a646a159bf80760fb1554c78e9a34efec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e89948a0b6d5380f0dd2a41b945dc26"></a>
typedef unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a></td></tr>
<tr class="memdesc:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned int type, consistent with the size of a pointer and used for pointer calculations <br /></td></tr>
<tr class="separator:a9e89948a0b6d5380f0dd2a41b945dc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45524833cc0165adec87ca1b6821db67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45524833cc0165adec87ca1b6821db67"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a45524833cc0165adec87ca1b6821db67">sphLogEntryID_t</a></td></tr>
<tr class="memdesc:a45524833cc0165adec87ca1b6821db67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate type for handling <a class="el" href="structsphLogEntryLayout__t.html" title="sphLogEntry_t. Fields defining the entry details word. ">sphLogEntryLayout_t</a>. <br /></td></tr>
<tr class="separator:a45524833cc0165adec87ca1b6821db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dc2178807f9e94405281afc0acdff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85dc2178807f9e94405281afc0acdff6"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a85dc2178807f9e94405281afc0acdff6">sphpid16_t</a></td></tr>
<tr class="memdesc:a85dc2178807f9e94405281afc0acdff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common type for PID/TID values stored in Logger entries. <br /></td></tr>
<tr class="separator:a85dc2178807f9e94405281afc0acdff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa97969c56a739fb19b7130a71cf3a30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aa97969c56a739fb19b7130a71cf3a30a">SPHLFLoggerInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr class="memdesc:aa97969c56a739fb19b7130a71cf3a30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free Event Logger.  <a href="#aa97969c56a739fb19b7130a71cf3a30a">More...</a><br /></td></tr>
<tr class="separator:aa97969c56a739fb19b7130a71cf3a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d72259e71bc6258295bc85a8dc63481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a0d72259e71bc6258295bc85a8dc63481">SPHLFLoggerInitWithStride</a> (void *buf_seg, block_size_t buf_size, unsigned short entry_stride, unsigned int options)</td></tr>
<tr class="memdesc:a0d72259e71bc6258295bc85a8dc63481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Lock Free Event Logger with a fixed entry stride.  <a href="#a0d72259e71bc6258295bc85a8dc63481">More...</a><br /></td></tr>
<tr class="separator:a0d72259e71bc6258295bc85a8dc63481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f324362e1b7c4bf46f48b29f75ee546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a8f324362e1b7c4bf46f48b29f75ee546">SPHLFLoggerCreate</a> (block_size_t buf_size)</td></tr>
<tr class="memdesc:a8f324362e1b7c4bf46f48b29f75ee546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Event Logger.  <a href="#a8f324362e1b7c4bf46f48b29f75ee546">More...</a><br /></td></tr>
<tr class="separator:a8f324362e1b7c4bf46f48b29f75ee546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefaf9f257d28eab7ca208bb8cc1991a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#afefaf9f257d28eab7ca208bb8cc1991a">SPHLFCircularLoggerCreate</a> (block_size_t buf_size, unsigned short stride)</td></tr>
<tr class="memdesc:afefaf9f257d28eab7ca208bb8cc1991a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Lock Free Event Logger. Mark the logger as circular and specify a fixed Stride.  <a href="#afefaf9f257d28eab7ca208bb8cc1991a">More...</a><br /></td></tr>
<tr class="separator:afefaf9f257d28eab7ca208bb8cc1991a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a311e8b4ea694ec83609933c34356a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a9a311e8b4ea694ec83609933c34356a4">SPHLFLoggerAllocRaw</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, block_size_t alloc_size)</td></tr>
<tr class="memdesc:a9a311e8b4ea694ec83609933c34356a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of a (raw) Logger entry allocated from the specified logger.  <a href="#a9a311e8b4ea694ec83609933c34356a4">More...</a><br /></td></tr>
<tr class="separator:a9a311e8b4ea694ec83609933c34356a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484fb4da41982411dfd931b59e553902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a484fb4da41982411dfd931b59e553902">SPHLFLoggerAllocTimeStamped</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, int catcode, int subcode, block_size_t alloc_size, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a484fb4da41982411dfd931b59e553902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the header, of a timestamped logger entry, from the specified logger.  <a href="#a484fb4da41982411dfd931b59e553902">More...</a><br /></td></tr>
<tr class="separator:a484fb4da41982411dfd931b59e553902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f661b8f81f09b3b9b1f6850dd9d1c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a25f661b8f81f09b3b9b1f6850dd9d1c2">SPHLFLoggerAllocStrideTimeStamped</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, int catcode, int subcode, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a25f661b8f81f09b3b9b1f6850dd9d1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the header, of a timestamped logger entry, from the specified logger.  <a href="#a25f661b8f81f09b3b9b1f6850dd9d1c2">More...</a><br /></td></tr>
<tr class="separator:a25f661b8f81f09b3b9b1f6850dd9d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4c383bc90005138adcbaf3bc277457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aef4c383bc90005138adcbaf3bc277457">SPHLFLoggerAllocTimeStampedNoLock</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, int catcode, int subcode, block_size_t alloc_size, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:aef4c383bc90005138adcbaf3bc277457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the header of a timestamped logger entry from the specified logger, without locking or memory barriers.  <a href="#aef4c383bc90005138adcbaf3bc277457">More...</a><br /></td></tr>
<tr class="separator:aef4c383bc90005138adcbaf3bc277457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba0c5bacad8645ab3cb7a1bd378114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a20ba0c5bacad8645ab3cb7a1bd378114">SPHLFLoggerAllocStrideTimeStampedNoLock</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, int catcode, int subcode, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a20ba0c5bacad8645ab3cb7a1bd378114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize the header, of a timestamped logger entry, from the specified logger, without locking or memory barriers.  <a href="#a20ba0c5bacad8645ab3cb7a1bd378114">More...</a><br /></td></tr>
<tr class="separator:a20ba0c5bacad8645ab3cb7a1bd378114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31e8d34b0189f3cefeb54b0aead3af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#ae31e8d34b0189f3cefeb54b0aead3af9">SPHLFLoggerEntryComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *entryhandle)</td></tr>
<tr class="memdesc:ae31e8d34b0189f3cefeb54b0aead3af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete.  <a href="#ae31e8d34b0189f3cefeb54b0aead3af9">More...</a><br /></td></tr>
<tr class="separator:ae31e8d34b0189f3cefeb54b0aead3af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c282d04c12d2709bea8e32dde4a73b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aa3c282d04c12d2709bea8e32dde4a73b">SPHLFLoggerEntryIsComplete</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *entryhandle)</td></tr>
<tr class="memdesc:aa3c282d04c12d2709bea8e32dde4a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#aa3c282d04c12d2709bea8e32dde4a73b">More...</a><br /></td></tr>
<tr class="separator:aa3c282d04c12d2709bea8e32dde4a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f0622cb18aa8721481169b1edffff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#aa2f0622cb18aa8721481169b1edffff9">SPHLFLoggerEntryIsTimestamped</a> (<a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *entryhandle)</td></tr>
<tr class="memdesc:aa2f0622cb18aa8721481169b1edffff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the entry handle.  <a href="#aa2f0622cb18aa8721481169b1edffff9">More...</a><br /></td></tr>
<tr class="separator:aa2f0622cb18aa8721481169b1edffff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33dc2c143417daba57d092ca59158fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#ad33dc2c143417daba57d092ca59158fb">SPHLFLoggerIteratorNext</a> (<a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *iterator, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:ad33dc2c143417daba57d092ca59158fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the provided Logger Iterator creates a entry handle for the next sequential Logger entry. The resulting entry handle can be used to read the contents of the Logger entry.  <a href="#ad33dc2c143417daba57d092ca59158fb">More...</a><br /></td></tr>
<tr class="separator:ad33dc2c143417daba57d092ca59158fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b3de7042a1cd4161fe87e84810e653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a60b3de7042a1cd4161fe87e84810e653">SPHLFLoggerCreateIterator</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, <a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *iteratorSpace)</td></tr>
<tr class="memdesc:a60b3de7042a1cd4161fe87e84810e653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a logger Iterator for reading sequential entries from a specific logger.  <a href="#a60b3de7042a1cd4161fe87e84810e653">More...</a><br /></td></tr>
<tr class="separator:a60b3de7042a1cd4161fe87e84810e653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0ab0149361b1af84ab811da715b417"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#ade0ab0149361b1af84ab811da715b417">SPHLFLoggerEmpty</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:ade0ab0149361b1af84ab811da715b417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified logger.  <a href="#ade0ab0149361b1af84ab811da715b417">More...</a><br /></td></tr>
<tr class="separator:ade0ab0149361b1af84ab811da715b417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0cbabef8abdda5fbe5c3b6d3e2d7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#acd0cbabef8abdda5fbe5c3b6d3e2d7fa">SPHLFLoggerWrapped</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:acd0cbabef8abdda5fbe5c3b6d3e2d7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified logger.  <a href="#acd0cbabef8abdda5fbe5c3b6d3e2d7fa">More...</a><br /></td></tr>
<tr class="separator:acd0cbabef8abdda5fbe5c3b6d3e2d7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bb0f8231e90fed27feff2c6838acee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a71bb0f8231e90fed27feff2c6838acee">SPHLFLoggerFreeSpace</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:a71bb0f8231e90fed27feff2c6838acee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of free space (in bytes) remaining in the specified logger.  <a href="#a71bb0f8231e90fed27feff2c6838acee">More...</a><br /></td></tr>
<tr class="separator:a71bb0f8231e90fed27feff2c6838acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af692b887002e4b0a2cafa0533379e38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#af692b887002e4b0a2cafa0533379e38e">SPHLFLoggerFull</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:af692b887002e4b0a2cafa0533379e38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified logger.  <a href="#af692b887002e4b0a2cafa0533379e38e">More...</a><br /></td></tr>
<tr class="separator:af692b887002e4b0a2cafa0533379e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7986b545bdbe08e622eb26c8c230e8c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a7986b545bdbe08e622eb26c8c230e8c4">SPHLFLoggerResetIfFullSync</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:a7986b545bdbe08e622eb26c8c230e8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the specific logger to empty state synchronously if it is currently full.  <a href="#a7986b545bdbe08e622eb26c8c230e8c4">More...</a><br /></td></tr>
<tr class="separator:a7986b545bdbe08e622eb26c8c230e8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d888509f49c6a211471d125e90e26a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a7d888509f49c6a211471d125e90e26a3">SPHLFLoggerResetAsync</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:a7d888509f49c6a211471d125e90e26a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the specific logger to empty state asynchronously (without locking or atomic updates).  <a href="#a7d888509f49c6a211471d125e90e26a3">More...</a><br /></td></tr>
<tr class="separator:a7d888509f49c6a211471d125e90e26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82936f79714a789a4755031a0399f7f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a82936f79714a789a4755031a0399f7f5">SPHLFLoggerPrefetch</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:a82936f79714a789a4755031a0399f7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch pages from the specific logger.  <a href="#a82936f79714a789a4755031a0399f7f5">More...</a><br /></td></tr>
<tr class="separator:a82936f79714a789a4755031a0399f7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366e2c25597d629d7b32f48d391219a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a366e2c25597d629d7b32f48d391219a9">SPHLFLoggerSetCachePrefetch</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log, int prefetch)</td></tr>
<tr class="memdesc:a366e2c25597d629d7b32f48d391219a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache-line prefetch options for entry allocate.  <a href="#a366e2c25597d629d7b32f48d391219a9">More...</a><br /></td></tr>
<tr class="separator:a366e2c25597d629d7b32f48d391219a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f06b453e5984165f72ead3f67c5c94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlflogger_8h.html#a5f06b453e5984165f72ead3f67c5c94a">SPHLFLoggerDestroy</a> (<a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:a5f06b453e5984165f72ead3f67c5c94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the logger and frees the SAS storage for reuse.  <a href="#a5f06b453e5984165f72ead3f67c5c94a">More...</a><br /></td></tr>
<tr class="separator:a5f06b453e5984165f72ead3f67c5c94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, logger. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to implement Lock Free Loggers (SPHLFLogger_t). </p>
<p>This Logger API supports atomic allocation of storage for event entries for zero copy persistence and sharing. Only the allocation of the entry is serialized. If there are multiple threads or processes generating log entries, on a multi-core processor, hardware threads can fill in Log entries in parallel with other threads.</p>
<p>The API support simple loggers and circular loggers. Simple loggers stop allocating entries when the log buffer is full. Circular loggers wrap to the beginning of the log buffer when the log buffer fills. This overwrites the oldest log entries. but allows logging on a continuous basis. Circular loggers use a fixed entry stride to insure the oldest entry can be found easily. A stride that matches the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple logger entries across cores/sockets.</p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> logger;</div>
<div class="line"><a class="code" href="sphcontext_8h.html#ad8728eed25450b6111b1c01d39fa8a3d">SPHContext_t</a> context;</div>
<div class="line"></div>
<div class="line"><a class="code" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd">SASJoinRegion</a>();</div>
<div class="line"><span class="comment">// set up shared circular logger with fixed size entries</span></div>
<div class="line"><span class="comment">// Stride is a full cache line for better performance</span></div>
<div class="line">logger = <a class="code" href="sphlflogger_8h.html#afefaf9f257d28eab7ca208bb8cc1991a">SPHLFCircularLoggerCreate</a> (log_alloc, 128);</div>
<div class="line"><span class="keywordflow">if</span> ( logger )</div>
<div class="line">{</div>
<div class="line">    context = <a class="code" href="sphcontext_8h.html#a6d4f8df6f1a011bf652f02ad6f1136d5">SPHSetupProjectContext</a> (<span class="stringliteral">&quot;myproject&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (context)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="sphcontext_8h.html#a633bf063f164e3d6808d62fa6c1bacf7">SPHContextAddName</a> (context, <span class="stringliteral">&quot;flight_recorder&quot;</span>, logger)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <pre class="fragment">As an option the logger allocator will fill in a 16 byte
entry header with: \n Entry status and length.  \n Entry identifying
Category and SubCategory codes. \n Process and Thread Ids.  \n High
resolution timestamp.
</pre><div class="fragment"><div class="line"><a class="code" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> logger;</div>
<div class="line"><a class="code" href="sphcontext_8h.html#ad8728eed25450b6111b1c01d39fa8a3d">SPHContext_t</a> context;</div>
<div class="line"><a class="code" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlex, handle_data;</div>
<div class="line"></div>
<div class="line"><a class="code" href="sassim_8h.html#afe2261a12b0eab211c7674873cf90ebd">SASJoinRegion</a>();</div>
<div class="line"><span class="comment">// get up shared circular logger</span></div>
<div class="line">context <a class="code" href="sphcontext_8h.html#a3e68eeb2c11dcd6cbbf47f2a1143fefb">getProjectContextByName</a> (<span class="stringliteral">&quot;myproject&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (context)</div>
<div class="line">{</div>
<div class="line">   logger = (<a class="code" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>)<a class="code" href="sphcontext_8h.html#a4ed11d44fa79cc18cc95418c6b114be1">SPHContextFindByName</a> (context, <span class="stringliteral">&quot;flight_recorder&quot;</span>);</div>
<div class="line">       ...</div>
<div class="line">   <span class="comment">// create a flight_recorder entry with application category/subcategory codes</span></div>
<div class="line">   <span class="comment">// with process/thread IDs and timestamp.</span></div>
<div class="line">   <span class="keywordflow">if</span> (logger)</div>
<div class="line">   {</div>
<div class="line">        handex = <a class="code" href="sphlflogger_8h.html#a25f661b8f81f09b3b9b1f6850dd9d1c2">SPHLFLoggerAllocStrideTimeStamped</a> (logger, category_x, subcat_y, handle_data);</div>
<div class="line">        ...</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --> <pre class="fragment">Any additional storage allocated to the entry
is available for application specific data.
The sphlflogentry.h API also provides
several mechanisms to store application data including; direct
array or structure overlay, and a streams like mechanism.
The API provides a completion function (SPHLFLoggerEntryComplete)
which provides any memory barriers required by the platform and
marks the entry complete.
</pre><div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// create a flight_recorder entry with application cat/subcat codes</span></div>
<div class="line"><span class="comment">// rumtime provides process/thread IDs and time_stamp.</span></div>
<div class="line"></div>
<div class="line">handex = <a class="code" href="sphlflogger_8h.html#a25f661b8f81f09b3b9b1f6850dd9d1c2">SPHLFLoggerAllocStrideTimeStamped</a> (logger, category_x, subcat_y, handle_data);</div>
<div class="line"><span class="keywordflow">if</span> (handex)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// insert a stream of application specific data</span></div>
<div class="line">    SPHLFLogEntryAddInt(handlex, int_data1);</div>
<div class="line">    SPHLFLogEntryAddInt(handlex, int_data2);</div>
<div class="line">    SPHLFLogEntryAddPtr(handlex, ptr_1);</div>
<div class="line">    SPHLFLogEntryAddDouble(handlex, double_data1);</div>
<div class="line">    SPHLFLogEntryAddString(handlex, <span class="stringliteral">&quot;any_c_string&quot;</span>);</div>
<div class="line">           ...</div>
<div class="line">       <span class="comment">// Insure the entry is coherent and mark this entry complete</span></div>
<div class="line">       <a class="code" href="sphlflogentry_8h.html#ab02b38ca9d77f83da11c28bb9c094f87">SPHLFLogEntryComplete</a> (handlex);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The logger contents are shared and persistent and will not be lost if the logging process crashes. Logger entries can be retrieved at any time after it is marked complete. </p><pre class="fragment">The API provides Log Iterator functions that support sequential read-back
of (completed) Logger entries. First create a log iterator
(with SPHLFloggerCreateIterator). Then use the resulting iterator to
sequentially step through log entries (via SPHLFLoggerItertorNext).
The iterator runtime handles both simple and circular loggers and insures
entries are read-out (oldest to newest) in order.
</pre><div class="fragment"><div class="line"><a class="code" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *iter, iter0;</div>
<div class="line"><a class="code" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlex, handle_data;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// create a Log iterator over the flight recorder</span></div>
<div class="line">iter = <a class="code" href="sphlflogger_8h.html#a60b3de7042a1cd4161fe87e84810e653">SPHLFLoggerCreateIterator</a>(logger, &amp;iter0);</div>
<div class="line"><span class="keywordflow">if</span> (iter)</div>
<div class="line">{</div>
<div class="line">    handlex = <a class="code" href="sphlflogger_8h.html#ad33dc2c143417daba57d092ca59158fb">SPHLFLoggerIteratorNext</a> (iter, &amp;handle_data);</div>
<div class="line">    <span class="keywordflow">while</span> (handex)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="sphtimer_8h.html#a2075c191959b463818a251bc7a9372dd">sphtimer_t</a> entry_timestamp;</div>
<div class="line">        <span class="keywordtype">int</span> cat, subcat, PID, TID:</div>
<div class="line">        <span class="keywordtype">int</span> int_data1, int_data1;</div>
<div class="line">        <span class="keywordtype">void</span> * ptr_1;</div>
<div class="line">        <span class="keywordtype">double</span> double_data1;</div>
<div class="line">        <span class="keywordtype">char</span> * entry_str;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// extract entry data</span></div>
<div class="line">        PID = <a class="code" href="sphlflogentry_8h.html#af3c21c76b0b2acf23be72967d7f585d3">SPHLFLogEntryPID</a> (handlex);</div>
<div class="line">        TID = <a class="code" href="sphlflogentry_8h.html#abc1c5f4478f0c957577658ef90e6e315">SPHLFLogEntryTID</a> (handlex);</div>
<div class="line">        cat = <a class="code" href="sphlflogentry_8h.html#adc871e0a3c447918582f9facd2390b09">SPHLFLogEntryCategory</a> (handlex);</div>
<div class="line">        subcat = <a class="code" href="sphlflogentry_8h.html#ac8099ead0eff9b3f124e1ab30e8c840c">SPHLFLogEntrySubcat</a> (handlex);</div>
<div class="line">        entry_timestamp = <a class="code" href="sphlflogentry_8h.html#a91a75a87871d4bdb483a92d8a8ffdd8a">SPHLFLogEntryTimeStamp</a> (handlex);</div>
<div class="line">        ...</div>
<div class="line">        <span class="comment">// extract application specific data, in insertion order</span></div>
<div class="line">        int_data1 = SPHLFLogEntryGetNextInt(handlex);</div>
<div class="line">        int_data2 = SPHLFLogEntryGetNextInt(handlex);</div>
<div class="line">        ptr_1 = SPHLFLogEntryGetNextPtr(handlex);</div>
<div class="line">        double_data1 = SPHLFLogEntryGetNextDouble(handlex);</div>
<div class="line">        entry_str SPHLFLogEntryGetNextString(handlex);</div>
<div class="line">           ...</div>
<div class="line">        <span class="comment">// do something with the date</span></div>
<div class="line">        ...</div>
<div class="line">        <span class="comment">// get next entry</span></div>
<div class="line">        handlex = <a class="code" href="sphlflogger_8h.html#ad33dc2c143417daba57d092ca59158fb">SPHLFLoggerIteratorNext</a> (iter, &amp;handle_data);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a535d790503c841b146406f82a937d325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPHLFLOGGER_CIRCULAR_RESETMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="sphlflogger_8h.html#aac3d02d79c22cfb86d3505a6095f719a">SPHLFLOGGER_CIRCULAR</a> | <a class="code" href="sphlflogger_8h.html#aefbc3417708abab49203e2cbd5b99d06">\</a></div>
<div class="line"><a class="code" href="sphlflogger_8h.html#aefbc3417708abab49203e2cbd5b99d06">		SPHLFLOGGER_CACHE_PREFETCH0</a> | <a class="code" href="sphlflogger_8h.html#aa4d9be4ee9f3888dda70594a8e4ffc01">\</a></div>
<div class="line"><a class="code" href="sphlflogger_8h.html#aa4d9be4ee9f3888dda70594a8e4ffc01">		SPHLFLOGGER_CACHE_PREFETCH1</a>)</div>
<div class="ttc" id="sphlflogger_8h_html_aefbc3417708abab49203e2cbd5b99d06"><div class="ttname"><a href="sphlflogger_8h.html#aefbc3417708abab49203e2cbd5b99d06">SPHLFLOGGER_CACHE_PREFETCH0</a></div><div class="ttdeci">#define SPHLFLOGGER_CACHE_PREFETCH0</div><div class="ttdoc">internal options flag for prefetching the immediate (0 offset) cache-line </div><div class="ttdef"><b>Definition:</b> sphlflogger.h:286</div></div>
<div class="ttc" id="sphlflogger_8h_html_aac3d02d79c22cfb86d3505a6095f719a"><div class="ttname"><a href="sphlflogger_8h.html#aac3d02d79c22cfb86d3505a6095f719a">SPHLFLOGGER_CIRCULAR</a></div><div class="ttdeci">#define SPHLFLOGGER_CIRCULAR</div><div class="ttdoc">internal options flag for circular log buffers </div><div class="ttdef"><b>Definition:</b> sphlflogger.h:280</div></div>
<div class="ttc" id="sphlflogger_8h_html_aa4d9be4ee9f3888dda70594a8e4ffc01"><div class="ttname"><a href="sphlflogger_8h.html#aa4d9be4ee9f3888dda70594a8e4ffc01">SPHLFLOGGER_CACHE_PREFETCH1</a></div><div class="ttdeci">#define SPHLFLOGGER_CACHE_PREFETCH1</div><div class="ttdoc">internal options flag for prefetching the next (line size offset) cache-line </div><div class="ttdef"><b>Definition:</b> sphlflogger.h:288</div></div>
</div><!-- fragment -->
<p>internal options mask flag used the reset circular log buffers </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a646a159bf80760fb1554c78e9a34efec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an instance of SPH Lock Free Logger. </p>
<p>The type is SAS_RUNTIME_LOCKFREELOGGER </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afefaf9f257d28eab7ca208bb8cc1991a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLFCircularLoggerCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Event Logger. Mark the logger as circular and specify a fixed Stride. </p>
<p>Allocate a block from SAS storage and initialize that block block as a Logger. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a311e8b4ea694ec83609933c34356a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHLFLoggerAllocRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the address of a (raw) Logger entry allocated from the specified logger. </p>
<p>The allocation size is rounded up to the next quadword boundary. Mostly for internal use and testing. If the specified logger is full the allocation may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the entry to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the raw Log Entry is returned if successful, or NULL if unsuccessful. For example the Allocate may fail if the logger is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a25f661b8f81f09b3b9b1f6850dd9d1c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFLoggerAllocStrideTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the header, of a timestamped logger entry, from the specified logger. </p>
<p>The allocation size fixed as specified by the SPHLFCircularLoggerCreate. The Category, Subcategory, PID, TID and high persision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a> API. If the specified logger is full the allocation may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the allocatation failed. For example the Allocate may fail if the logger is full and is not mark circular. </dd></dl>

</div>
</div>
<a class="anchor" id="a20ba0c5bacad8645ab3cb7a1bd378114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFLoggerAllocStrideTimeStampedNoLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the header, of a timestamped logger entry, from the specified logger, without locking or memory barriers. </p>
<p>The allocation size fixed as specified by the SPHLFCircularLoggerCreate. The Category, Subcategory, PID, TID and high persision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a> API. If the specified logger is full the allocation may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>The NoLock form is only appropriate for single thread applications where the logger is not shared with other processes. Or if used in a multi-threaded application each thread should have it's own private logger instance.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Also recommended that the NoLock allocates should be completed with <a class="el" href="sphlflogentry_8h.html#a71d19cda09ecda87c2677bd16d250f71" title="Marks the entry specified by the entry handle as complete. No memory barriers are performance...">SPHLFLogEntryWeakComplete()</a> from <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry, from the handlespace parm, or 0 (NULL) if the allocatation failed. For example the Allocate may fail if the logger is full and is not mark circular. </dd></dl>

</div>
</div>
<a class="anchor" id="a484fb4da41982411dfd931b59e553902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFLoggerAllocTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the header, of a timestamped logger entry, from the specified logger. </p>
<p>The allocation size is rounded up to the next quadword boundary and does not include the implicit size of the Timestamp entry header. The Category, Subcategory, PID, TID and high persision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a> API. If the specified logger is full the allocation may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>Size in bytes of the entry to be allocated. The actual entry will be +16 bytes to include the entry header. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry handle, from the handlespace parm, or 0 (NULL) if the allocatation failed. For example the Allocate may fail if the logger is full. </dd></dl>

</div>
</div>
<a class="anchor" id="aef4c383bc90005138adcbaf3bc277457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFLoggerAllocTimeStampedNoLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize the header of a timestamped logger entry from the specified logger, without locking or memory barriers. </p>
<p>The allocation size is rounded up to the next quadword boundary and does not include the implicit size of the Timestamp entry header. The Category, Subcategory, PID, TID and high persision timestamp are stored in the header of the new entry. Returns an entry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a> API. If the specified logger is full the allocation may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>The NoLock form is only appropriate for single thread applications where the logger is not shared with other processes. Or if used in a multi-threaded application each thread should have it's own private logger instance.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Also recommended that the NoLock allocates should be completed with <a class="el" href="sphlflogentry_8h.html#a71d19cda09ecda87c2677bd16d250f71" title="Marks the entry specified by the entry handle as complete. No memory barriers are performance...">SPHLFLogEntryWeakComplete()</a> from <a class="el" href="sphlflogentry_8h.html" title="Shared Persistent Heap, logger entry status, update and access functions. ">sphlflogentry.h</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code to the new entry. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>Size in bytes of the entry to be allocated. The actual entry will be +16 bytes to include the entry header. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the initialized logger entry handle, from the handlespace parm, or 0 (NULL) if the allocatation failed. For example the Allocate may fail if the logger is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f324362e1b7c4bf46f48b29f75ee546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLFLoggerCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Lock Free Event Logger. </p>
<p>Allocate a block from SAS storage and initialize that block block as a Logger. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a60b3de7042a1cd4161fe87e84810e653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a>* SPHLFLoggerCreateIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iteratorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a logger Iterator for reading sequential entries from a specific logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
    <tr><td class="paramname">iteratorSpace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLogIterator__t.html" title="Instance of a Lock Free Logger Iterator. ">SPHLFLogIterator_t</a> associated with the log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the iterator space provided, initialized as a Logger Iterator if successful. Otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f06b453e5984165f72ead3f67c5c94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the logger and frees the SAS storage for reuse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ade0ab0149361b1af84ab811da715b417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the logger is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="ae31e8d34b0189f3cefeb54b0aead3af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerEntryComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>entryhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. </p>
<p>Also executes any memory barriers required by the platform to ensure that all previous stores to this entry by this thread are visible to other threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryhandle</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3c282d04c12d2709bea8e32dde4a73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerEntryIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>entryhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryhandle</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f0622cb18aa8721481169b1edffff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerEntryIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>entryhandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryhandle</td><td>log entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was timestamped, otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a71bb0f8231e90fed27feff2c6838acee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t SPHLFLoggerFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of free space (in bytes) remaining in the specified logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of free space remainign in the Logger buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="af692b887002e4b0a2cafa0533379e38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the logger is currently full. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aa97969c56a739fb19b7130a71cf3a30a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLFLoggerInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Lock Free Event Logger. </p>
<p>Initialize the specified storage block as Lock Free Logger control blocks. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_LOCKFREELOGGER.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d72259e71bc6258295bc85a8dc63481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLFLoggerInitWithStride </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>entry_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Lock Free Event Logger with a fixed entry stride. </p>
<p>Initialize the specified storage block as Lock Free Logger control blocks. The stride and control flags are also stored. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_RUNTIME_LOCKFREELOGGER.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">entry_stride</td><td>the stride offset is bytes between allocated entries. </td></tr>
    <tr><td class="paramname">options</td><td>option bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="ad33dc2c143417daba57d092ca59158fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFLoggerIteratorNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFLogIterator__t.html">SPHLFLogIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the provided Logger Iterator creates a entry handle for the next sequential Logger entry. The resulting entry handle can be used to read the contents of the Logger entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Handle associated with a Logger. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the handle space provided, initialized as a Logger entry handle for the next sequential entry if successful. Otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a82936f79714a789a4755031a0399f7f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerPrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch pages from the specific logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d888509f49c6a211471d125e90e26a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerResetAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the specific logger to empty state asynchronously (without locking or atomic updates). </p>
<p>Internal use for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a7986b545bdbe08e622eb26c8c230e8c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerResetIfFullSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the specific logger to empty state synchronously if it is currently full. </p>
<p>Internal use for testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the logger was full and this thread did the reset. Otherwise 1 if not full or another thread already reset this logger. Other values indicated a serious error, for example the reference is not a logger. </dd></dl>

</div>
</div>
<a class="anchor" id="a366e2c25597d629d7b32f48d391219a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerSetCachePrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefetch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the cache-line prefetch options for entry allocate. </p>
<p>prefetch == 0; No prefetch issued. <br />
 prefetch == 1; Prefetch the currently allocated cache-line. <br />
 prefetch == 2; Prefetch the cache-line following the allocated entry. <br />
 prefetch == 3; Prefetch the current and next cache-lines. </p><pre class="fragment">@param log Handle to a Logger.
@param prefetch prefetch option code.
@return 0 if successful.</pre> 
</div>
</div>
<a class="anchor" id="acd0cbabef8abdda5fbe5c3b6d3e2d7fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLFLoggerWrapped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>Handle to a Logger. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the logger is circular and has wrapped (at least once). Otherwise False. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 03:14:09 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
