<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlockfreeheap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphlockfreeheap.h File Reference</h1>
<p>Shared Persistent Heap, lock free heap allocator for shared memory multi-thread/multi-core applications.  
<a href="#_details">More...</a></p>
<code>#include &quot;sastype.h&quot;</code><br/>

<p><a href="sphlockfreeheap_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle to an instance of SPH Lock Free Heap.  <a href="#a5315ca5f61482af08f31bcc6ef0f055d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2f1c74c54d7192383f258b409ab0e9db">SPHLockFreeHeapInit</a> (void *heap_block, sas_type_t sasType, block_size_t heap_size, size_t unit_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a shared storage block as a lock free heap.  <a href="#a2f1c74c54d7192383f258b409ab0e9db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a428be2c4cfaccdc4357632beb55d460f">SPHLockFreeHeapCreate</a> (block_size_t heap_size, size_t unit_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a lock free heap in a shared storage block.  <a href="#a428be2c4cfaccdc4357632beb55d460f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#ad20bd30abc9e130b7a39a7af82965b99">SPHLockFreeHeapDestroy</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a lock free heap and free the shared storage block.  <a href="#ad20bd30abc9e130b7a39a7af82965b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ block_size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a3ae3418f11ff976c6bc554b32fac2898">SPHLockFreeHeapFreeSpace</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remaining allocatable free space within the specified lock free heap..  <a href="#a3ae3418f11ff976c6bc554b32fac2898"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a230c64dcc0d6fb362b6ab4ce3dd5abca">SPHLockFreeHeapEmpty</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a boolean result indicating if the lock free heap is empty.  <a href="#a230c64dcc0d6fb362b6ab4ce3dd5abca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a6a56c54c8f81b6473304cfd8072b2ae7">SPHLockFreeHeapFull</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a boolean result indicating if the lock free heap is completely full.  <a href="#a6a56c54c8f81b6473304cfd8072b2ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a0894a6cd556f6ad658e93d9d803d7a11">SPHLockFreeHeapAlloc</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, block_size_t alloc_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suballocate memory from a lock-free heap.  <a href="#a0894a6cd556f6ad658e93d9d803d7a11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#abc6d3ba225588ff613beb0226549d633">SPHLockFreeHeapAlignAlloc</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, block_size_t alloc_size, block_size_t alignment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suballocate memory from a lock free heap at a specified alignment.  <a href="#abc6d3ba225588ff613beb0226549d633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a3332fc76a911a412ab02d5191cdc0632">SPHLockFreeHeapNearAlloc</a> (void *nearObj, long alloc_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suballocate memory from a lock free heap, close to a previous allocation.  <a href="#a3332fc76a911a412ab02d5191cdc0632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a7dc710e1e8cad70431f390a074bb000b">SPHLockFreeHeapFree</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a7dc710e1e8cad70431f390a074bb000b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2576958139ae86bf67c8f839504b2793">SPHLockFreeHeapFreeNear</a> (void *free_block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a2576958139ae86bf67c8f839504b2793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a14cb5303169d767f53c098cef63d824f">SPHLockFreeHeapFreeIn</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a14cb5303169d767f53c098cef63d824f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a502ee25c6da31f7a6d87d52eba3ba6d9">SPHLockFreeHeapFreeChk</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block, block_size_t alloc_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify size of the allocation before freeing memory.  <a href="#a502ee25c6da31f7a6d87d52eba3ba6d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2bdad61f6627b5dbb892338eaaa9a247">SPHLockFreeHeapFreeNearChk</a> (void *free_block, block_size_t alloc_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verify size of the allocation before freeing memory.  <a href="#a2bdad61f6627b5dbb892338eaaa9a247"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a6bef4f23857381dab78e1f96f5e80987">SPHLockFreeHeapNearFind</a> (void *nearObj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the containing SPHLockFreeHeap for a block of memory.  <a href="#a6bef4f23857381dab78e1f96f5e80987"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, lock free heap allocator for shared memory multi-thread/multi-core applications. </p>
<p>! This implementation uses atomic bit vectors to control the allocation of memory in a fast and thread-safe manner. Each bit within the bit vector represents a fixed granule for allocation of memory. A string of contiguous bits represent larger allocations in multiples of the granule size.</p>
<p>Following the SPH design blocks used for LF heaps must be power of 2 in size and matching power of 2 alignment or better. This is required to support the near forms of alloc/free where the head header is implied from the contained address. The granules also must be power of 2 size which supports the aligned forms of allocation.</p>
<p>Allocations are tracked using bit vectors where each bit represents an power of 2 unit with matching alignment. Each heap is configured for a specific allocation unit size and different heaps can can be configured with varying unit sizes as required. For each unit size the maximum individual allocation size is limited the maximum atomic update granual of the underlying processor. For most processors this is defined by the largest compare-and-swap or equivalent atomic operation. However for biarch systems we may choose that smaller granual of the supported modes for consistency, normally 32-bits.</p>
<p>So any specific heap instance will support a maximum allocation request of 32 * unit-size. The Minimun unit size is 16-bytes so a heap configured with this size can support allocations of 16-byte multiples up to 512 bytes. If an application needs a larger allocation size a different heap needs to be configured with an appropriate unit size. For example if allocation up to 4K are need then a unit size of at least 128 bytes is needed. Of course this unit-size will also be the minimum allocation size and alignment for that heap.</p>
<p>We assume that this simple lock free heap will be used in the implementation of a compound lock free heap. Such a compound heap would automatically allocate multiple simple heaps with unit-sizes selected to support the the dynamic requests of the application. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a5315ca5f61482af08f31bcc6ef0f055d"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeap_t" ref="a5315ca5f61482af08f31bcc6ef0f055d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle to an instance of SPH Lock Free Heap. </p>
<p>The type is SAS_RUNTIME_LOCKFREEHEAP </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abc6d3ba225588ff613beb0226549d633"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapAlignAlloc" ref="abc6d3ba225588ff613beb0226549d633" args="(SPHLockFreeHeap_t heap, block_size_t alloc_size, block_size_t alignment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SPHLockFreeHeapAlignAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alignment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suballocate memory from a lock free heap at a specified alignment. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next intergral unit_size. The minimal alignment of the allocation will be specified by alignment. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size or alignment is available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to allocated from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the allocation request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignment</em>&nbsp;</td><td>required power of 2 alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0894a6cd556f6ad658e93d9d803d7a11"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapAlloc" ref="a0894a6cd556f6ad658e93d9d803d7a11" args="(SPHLockFreeHeap_t heap, block_size_t alloc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SPHLockFreeHeapAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suballocate memory from a lock-free heap. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next intergral unit_size. The minimal alignment of the allocation will be the unit_size. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size is available.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to allocated from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the allocation request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a428be2c4cfaccdc4357632beb55d460f"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapCreate" ref="a428be2c4cfaccdc4357632beb55d460f" args="(block_size_t heap_size, size_t unit_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>heap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a lock free heap in a shared storage block. </p>
<p>Allocate a SAS block and initialize the control blocks as a lock free heap. The block size must be power of two in size. The unit_size is the allocation granule in bytes and must be a power of two size greater then 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap_size</em>&nbsp;</td><td>power of 2 size of the heap to allocated and initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unit_size</em>&nbsp;</td><td>power of 2 of the allocation granule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle of the newly allocated SPHLockFreeHeap_t. Or NULL for the failure case. </dd></dl>

</div>
</div>
<a class="anchor" id="ad20bd30abc9e130b7a39a7af82965b99"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapDestroy" ref="ad20bd30abc9e130b7a39a7af82965b99" args="(SPHLockFreeHeap_t heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a lock free heap and free the shared storage block. </p>
<p>The sas_type_t must be of type SAS_LOCKFREEHEAP_TYPE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to destroyed and the storage freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 0 value indicated success, otherwise failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a230c64dcc0d6fb362b6ab4ce3dd5abca"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapEmpty" ref="a230c64dcc0d6fb362b6ab4ce3dd5abca" args="(SPHLockFreeHeap_t heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a boolean result indicating if the lock free heap is empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to checked for full/empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all available space is free. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc710e1e8cad70431f390a074bb000b"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFree" ref="a7dc710e1e8cad70431f390a074bb000b" args="(SPHLockFreeHeap_t heap, void *free_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>free_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>containing the allocation to be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_block</em>&nbsp;</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a502ee25c6da31f7a6d87d52eba3ba6d9"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFreeChk" ref="a502ee25c6da31f7a6d87d52eba3ba6d9" args="(SPHLockFreeHeap_t heap, void *free_block, block_size_t alloc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFreeChk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>free_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify size of the allocation before freeing memory. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. The allocation size is checked against the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>containing the allocation to be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_block</em>&nbsp;</td><td>pointer to the previously allocated storage to be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the original allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a14cb5303169d767f53c098cef63d824f"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFreeIn" ref="a14cb5303169d767f53c098cef63d824f" args="(SPHLockFreeHeap_t heap, void *free_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFreeIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>free_block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>containing the allocation to be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>free_block</em>&nbsp;</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2576958139ae86bf67c8f839504b2793"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFreeNear" ref="a2576958139ae86bf67c8f839504b2793" args="(void *free_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFreeNear </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>free_block</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The containing lock free heap is found, if possible, then the memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>free_block</em>&nbsp;</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bdad61f6627b5dbb892338eaaa9a247"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFreeNearChk" ref="a2bdad61f6627b5dbb892338eaaa9a247" args="(void *free_block, block_size_t alloc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFreeNearChk </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>free_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify size of the allocation before freeing memory. </p>
<p>The containing lock free heap is found, if posible, then the memory at *free_block is freed for reuse up to the length of the original allocation. The allocation size is checked against the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>free_block</em>&nbsp;</td><td>pointer to the previously allocated storage to be freed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the original allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae3418f11ff976c6bc554b32fac2898"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFreeSpace" ref="a3ae3418f11ff976c6bc554b32fac2898" args="(SPHLockFreeHeap_t heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ block_size_t SPHLockFreeHeapFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the remaining allocatable free space within the specified lock free heap.. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to checked for size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the remaining free space for this heap in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a56c54c8f81b6473304cfd8072b2ae7"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapFull" ref="a6a56c54c8f81b6473304cfd8072b2ae7" args="(SPHLockFreeHeap_t heap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLockFreeHeapFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&nbsp;</td>
          <td class="paramname"> <em>heap</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a boolean result indicating if the lock free heap is completely full. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>to checked for full/empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all available space is already allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f1c74c54d7192383f258b409ab0e9db"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapInit" ref="a2f1c74c54d7192383f258b409ab0e9db" args="(void *heap_block, sas_type_t sasType, block_size_t heap_size, size_t unit_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapInit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>heap_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sas_type_t&nbsp;</td>
          <td class="paramname"> <em>sasType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>heap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a shared storage block as a lock free heap. </p>
<p>Initialize the control blocks within the specified storage block as a lock free heap. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_LOCKFREEHEAP_TYPE. The unit_size is the allocation granule in bytes and must be a power of two size greater then 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap_block</em>&nbsp;</td><td>a block of allocated SAS storage matching the heap_size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sasType</em>&nbsp;</td><td>a SAS type code for internal consistency checking. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heap_size</em>&nbsp;</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unit_size</em>&nbsp;</td><td>power of 2 size of the allocation granule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>at handle to the initialized SPHLockFreeHeap_t </dd></dl>

</div>
</div>
<a class="anchor" id="a3332fc76a911a412ab02d5191cdc0632"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapNearAlloc" ref="a3332fc76a911a412ab02d5191cdc0632" args="(void *nearObj, long alloc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SPHLockFreeHeapNearAlloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>nearObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suballocate memory from a lock free heap, close to a previous allocation. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next integral unit_size. The minimal alignment of the allocation will be the unit_size. Attempt to allocate from the SPHLockFreeHeap which contains the near object. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size is available in the "near" SPHLockFreeHeap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nearObj</em>&nbsp;</td><td>address of another lock free heap allocation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the allocation request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bef4f23857381dab78e1f96f5e80987"></a><!-- doxytag: member="sphlockfreeheap.h::SPHLockFreeHeapNearFind" ref="a6bef4f23857381dab78e1f96f5e80987" args="(void *nearObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapNearFind </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>nearObj</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the containing SPHLockFreeHeap for a block of memory. </p>
<p>The containing lock free heap is found, if posible, then return LF heap address or NULL. From the near object pointer round down using increasing powers of 2 until a valid block header is found. If the block header is marked as a LockFreeHeap, return the block address. Otherwise return NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nearObj</em>&nbsp;</td><td>pointer to any current or previous allocation within the target heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the containing SPHLockFreeHeap_t, or NULL if not found. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Jan 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
