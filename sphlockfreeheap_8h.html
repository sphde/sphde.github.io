<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlockfreeheap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphlockfreeheap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, lock free heap allocator for shared memory multi-thread/multi-core applications.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;sastype.h&quot;</code><br />
</div>
<p><a href="sphlockfreeheap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5315ca5f61482af08f31bcc6ef0f055d"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a></td></tr>
<tr class="memdesc:a5315ca5f61482af08f31bcc6ef0f055d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an instance of SPH Lock Free Heap.  <a href="#a5315ca5f61482af08f31bcc6ef0f055d">More...</a><br /></td></tr>
<tr class="separator:a5315ca5f61482af08f31bcc6ef0f055d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f1c74c54d7192383f258b409ab0e9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2f1c74c54d7192383f258b409ab0e9db">SPHLockFreeHeapInit</a> (void *heap_block, sas_type_t sasType, block_size_t heap_size, size_t unit_size)</td></tr>
<tr class="memdesc:a2f1c74c54d7192383f258b409ab0e9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a lock free heap.  <a href="#a2f1c74c54d7192383f258b409ab0e9db">More...</a><br /></td></tr>
<tr class="separator:a2f1c74c54d7192383f258b409ab0e9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428be2c4cfaccdc4357632beb55d460f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a428be2c4cfaccdc4357632beb55d460f">SPHLockFreeHeapCreate</a> (block_size_t heap_size, size_t unit_size)</td></tr>
<tr class="memdesc:a428be2c4cfaccdc4357632beb55d460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lock free heap in a shared storage block.  <a href="#a428be2c4cfaccdc4357632beb55d460f">More...</a><br /></td></tr>
<tr class="separator:a428be2c4cfaccdc4357632beb55d460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20bd30abc9e130b7a39a7af82965b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#ad20bd30abc9e130b7a39a7af82965b99">SPHLockFreeHeapDestroy</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr class="memdesc:ad20bd30abc9e130b7a39a7af82965b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a lock free heap and free the shared storage block.  <a href="#ad20bd30abc9e130b7a39a7af82965b99">More...</a><br /></td></tr>
<tr class="separator:ad20bd30abc9e130b7a39a7af82965b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae3418f11ff976c6bc554b32fac2898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a3ae3418f11ff976c6bc554b32fac2898">SPHLockFreeHeapFreeSpace</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr class="memdesc:a3ae3418f11ff976c6bc554b32fac2898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the remaining allocatable free space within the specified lock free heap..  <a href="#a3ae3418f11ff976c6bc554b32fac2898">More...</a><br /></td></tr>
<tr class="separator:a3ae3418f11ff976c6bc554b32fac2898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230c64dcc0d6fb362b6ab4ce3dd5abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a230c64dcc0d6fb362b6ab4ce3dd5abca">SPHLockFreeHeapEmpty</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr class="memdesc:a230c64dcc0d6fb362b6ab4ce3dd5abca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean result indicating if the lock free heap is empty.  <a href="#a230c64dcc0d6fb362b6ab4ce3dd5abca">More...</a><br /></td></tr>
<tr class="separator:a230c64dcc0d6fb362b6ab4ce3dd5abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a56c54c8f81b6473304cfd8072b2ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a6a56c54c8f81b6473304cfd8072b2ae7">SPHLockFreeHeapFull</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap)</td></tr>
<tr class="memdesc:a6a56c54c8f81b6473304cfd8072b2ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean result indicating if the lock free heap is completely full.  <a href="#a6a56c54c8f81b6473304cfd8072b2ae7">More...</a><br /></td></tr>
<tr class="separator:a6a56c54c8f81b6473304cfd8072b2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0894a6cd556f6ad658e93d9d803d7a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a0894a6cd556f6ad658e93d9d803d7a11">SPHLockFreeHeapAlloc</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, block_size_t alloc_size)</td></tr>
<tr class="memdesc:a0894a6cd556f6ad658e93d9d803d7a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suballocate memory from a lock-free heap.  <a href="#a0894a6cd556f6ad658e93d9d803d7a11">More...</a><br /></td></tr>
<tr class="separator:a0894a6cd556f6ad658e93d9d803d7a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6d3ba225588ff613beb0226549d633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#abc6d3ba225588ff613beb0226549d633">SPHLockFreeHeapAlignAlloc</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, block_size_t alloc_size, block_size_t alignment)</td></tr>
<tr class="memdesc:abc6d3ba225588ff613beb0226549d633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suballocate memory from a lock free heap at a specified alignment.  <a href="#abc6d3ba225588ff613beb0226549d633">More...</a><br /></td></tr>
<tr class="separator:abc6d3ba225588ff613beb0226549d633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3332fc76a911a412ab02d5191cdc0632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a3332fc76a911a412ab02d5191cdc0632">SPHLockFreeHeapNearAlloc</a> (void *nearObj, long alloc_size)</td></tr>
<tr class="memdesc:a3332fc76a911a412ab02d5191cdc0632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suballocate memory from a lock free heap, close to a previous allocation.  <a href="#a3332fc76a911a412ab02d5191cdc0632">More...</a><br /></td></tr>
<tr class="separator:a3332fc76a911a412ab02d5191cdc0632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc710e1e8cad70431f390a074bb000b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a7dc710e1e8cad70431f390a074bb000b">SPHLockFreeHeapFree</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block)</td></tr>
<tr class="memdesc:a7dc710e1e8cad70431f390a074bb000b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a7dc710e1e8cad70431f390a074bb000b">More...</a><br /></td></tr>
<tr class="separator:a7dc710e1e8cad70431f390a074bb000b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2576958139ae86bf67c8f839504b2793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2576958139ae86bf67c8f839504b2793">SPHLockFreeHeapFreeNear</a> (void *free_block)</td></tr>
<tr class="memdesc:a2576958139ae86bf67c8f839504b2793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a2576958139ae86bf67c8f839504b2793">More...</a><br /></td></tr>
<tr class="separator:a2576958139ae86bf67c8f839504b2793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb5303169d767f53c098cef63d824f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a14cb5303169d767f53c098cef63d824f">SPHLockFreeHeapFreeIn</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block)</td></tr>
<tr class="memdesc:a14cb5303169d767f53c098cef63d824f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated from a lock free heap for reuse.  <a href="#a14cb5303169d767f53c098cef63d824f">More...</a><br /></td></tr>
<tr class="separator:a14cb5303169d767f53c098cef63d824f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502ee25c6da31f7a6d87d52eba3ba6d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a502ee25c6da31f7a6d87d52eba3ba6d9">SPHLockFreeHeapFreeChk</a> (<a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> heap, void *free_block, block_size_t alloc_size)</td></tr>
<tr class="memdesc:a502ee25c6da31f7a6d87d52eba3ba6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify size of the allocation before freeing memory.  <a href="#a502ee25c6da31f7a6d87d52eba3ba6d9">More...</a><br /></td></tr>
<tr class="separator:a502ee25c6da31f7a6d87d52eba3ba6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdad61f6627b5dbb892338eaaa9a247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a2bdad61f6627b5dbb892338eaaa9a247">SPHLockFreeHeapFreeNearChk</a> (void *free_block, block_size_t alloc_size)</td></tr>
<tr class="memdesc:a2bdad61f6627b5dbb892338eaaa9a247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify size of the allocation before freeing memory.  <a href="#a2bdad61f6627b5dbb892338eaaa9a247">More...</a><br /></td></tr>
<tr class="separator:a2bdad61f6627b5dbb892338eaaa9a247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bef4f23857381dab78e1f96f5e80987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlockfreeheap_8h.html#a6bef4f23857381dab78e1f96f5e80987">SPHLockFreeHeapNearFind</a> (void *nearObj)</td></tr>
<tr class="memdesc:a6bef4f23857381dab78e1f96f5e80987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the containing SPHLockFreeHeap for a block of memory.  <a href="#a6bef4f23857381dab78e1f96f5e80987">More...</a><br /></td></tr>
<tr class="separator:a6bef4f23857381dab78e1f96f5e80987"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, lock free heap allocator for shared memory multi-thread/multi-core applications. </p>
<p>! This implementation uses atomic bit vectors to control the allocation of memory in a fast and thread-safe manner. Each bit within the bit vector represents a fixed granule for allocation of memory. A string of contiguous bits represent larger allocations in multiples of the granule size.</p>
<p>Following the SPH design blocks used for LF heaps must be power of 2 in size and matching power of 2 alignment or better. This is required to support the near forms of alloc/free where the head header is implied from the contained address. The granules also must be power of 2 size which supports the aligned forms of allocation.</p>
<p>Allocations are tracked using bit vectors where each bit represents an power of 2 unit with matching alignment. Each heap is configured for a specific allocation unit size and different heaps can can be configured with varying unit sizes as required. For each unit size the maximum individual allocation size is limited the maximum atomic update granual of the underlying processor. For most processors this is defined by the largest compare-and-swap or equivalent atomic operation. However for biarch systems we may choose that smaller granual of the supported modes for consistency, normally 32-bits.</p>
<p>So any specific heap instance will support a maximum allocation request of 32 * unit-size. The Minimun unit size is 16-bytes so a heap configured with this size can support allocations of 16-byte multiples up to 512 bytes. If an application needs a larger allocation size a different heap needs to be configured with an appropriate unit size. For example if allocation up to 4K are need then a unit size of at least 128 bytes is needed. Of course this unit-size will also be the minimum allocation size and alignment for that heap.</p>
<p>We assume that this simple lock free heap will be used in the implementation of a compound lock free heap. Such a compound heap would automatically allocate multiple simple heaps with unit-sizes selected to support the the dynamic requests of the application. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5315ca5f61482af08f31bcc6ef0f055d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an instance of SPH Lock Free Heap. </p>
<p>The type is SAS_RUNTIME_LOCKFREEHEAP </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abc6d3ba225588ff613beb0226549d633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHLockFreeHeapAlignAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suballocate memory from a lock free heap at a specified alignment. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next intergral unit_size. The minimal alignment of the allocation will be specified by alignment. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size or alignment is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to allocated from. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the allocation request. </td></tr>
    <tr><td class="paramname">alignment</td><td>required power of 2 alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0894a6cd556f6ad658e93d9d803d7a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHLockFreeHeapAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suballocate memory from a lock-free heap. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next intergral unit_size. The minimal alignment of the allocation will be the unit_size. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to allocated from. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the allocation request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a428be2c4cfaccdc4357632beb55d460f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>heap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unit_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lock free heap in a shared storage block. </p>
<p>Allocate a SAS block and initialize the control blocks as a lock free heap. The block size must be power of two in size. The unit_size is the allocation granule in bytes and must be a power of two size greater then 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap_size</td><td>power of 2 size of the heap to allocated and initialized. </td></tr>
    <tr><td class="paramname">unit_size</td><td>power of 2 of the allocation granule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle of the newly allocated SPHLockFreeHeap_t. Or NULL for the failure case. </dd></dl>

</div>
</div>
<a class="anchor" id="ad20bd30abc9e130b7a39a7af82965b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a lock free heap and free the shared storage block. </p>
<p>The sas_type_t must be of type SAS_LOCKFREEHEAP_TYPE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to destroyed and the storage freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 0 value indicated success, otherwise failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a230c64dcc0d6fb362b6ab4ce3dd5abca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean result indicating if the lock free heap is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to checked for full/empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all available space is free. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc710e1e8cad70431f390a074bb000b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>containing the allocation to be freed. </td></tr>
    <tr><td class="paramname">free_block</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a502ee25c6da31f7a6d87d52eba3ba6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFreeChk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify size of the allocation before freeing memory. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. The allocation size is checked against the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>containing the allocation to be freed. </td></tr>
    <tr><td class="paramname">free_block</td><td>pointer to the previously allocated storage to be freed. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the original allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a14cb5303169d767f53c098cef63d824f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFreeIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>containing the allocation to be freed. </td></tr>
    <tr><td class="paramname">free_block</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2576958139ae86bf67c8f839504b2793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFreeNear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free memory allocated from a lock free heap for reuse. </p>
<p>The containing lock free heap is found, if possible, then the memory at *free_block is freed for reuse up to the length of the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_block</td><td>pointer to the previously allocated storage to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bdad61f6627b5dbb892338eaaa9a247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFreeNearChk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>free_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify size of the allocation before freeing memory. </p>
<p>The containing lock free heap is found, if posible, then the memory at *free_block is freed for reuse up to the length of the original allocation. The allocation size is checked against the original allocation. Returns zero if the free operation is successful. Otherwise a non-zero value for an error condition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free_block</td><td>pointer to the previously allocated storage to be freed. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the original allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates success, otherwise the free operation failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae3418f11ff976c6bc554b32fac2898"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> block_size_t SPHLockFreeHeapFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the remaining allocatable free space within the specified lock free heap.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to checked for size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the remaining free space for this heap in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a56c54c8f81b6473304cfd8072b2ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLockFreeHeapFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a>&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a boolean result indicating if the lock free heap is completely full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>to checked for full/empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all available space is already allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f1c74c54d7192383f258b409ab0e9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>heap_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sas_type_t&#160;</td>
          <td class="paramname"><em>sasType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>heap_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unit_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a lock free heap. </p>
<p>Initialize the control blocks within the specified storage block as a lock free heap. The storage block must be power of two in size and have the same power of two (or better) alignment. The type should be SAS_LOCKFREEHEAP_TYPE. The unit_size is the allocation granule in bytes and must be a power of two size greater then 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap_block</td><td>a block of allocated SAS storage matching the heap_size. </td></tr>
    <tr><td class="paramname">sasType</td><td>a SAS type code for internal consistency checking. </td></tr>
    <tr><td class="paramname">heap_size</td><td>power of two size of the heap to be initialized. </td></tr>
    <tr><td class="paramname">unit_size</td><td>power of 2 size of the allocation granule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>at handle to the initialized SPHLockFreeHeap_t </dd></dl>

</div>
</div>
<a class="anchor" id="a3332fc76a911a412ab02d5191cdc0632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHLockFreeHeapNearAlloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nearObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suballocate memory from a lock free heap, close to a previous allocation. </p>
<p>Request alloc_size bytes of memory from the heap. The allocation size will be rounded up to the next integral unit_size. The minimal alignment of the allocation will be the unit_size. Attempt to allocate from the SPHLockFreeHeap which contains the near object. Returns a pointer to the allocated memory or NULL if no contiguous space of the requested size is available in the "near" SPHLockFreeHeap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearObj</td><td>address of another lock free heap allocation. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the allocation request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the successfully allocate storage. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bef4f23857381dab78e1f96f5e80987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlockfreeheap_8h.html#a5315ca5f61482af08f31bcc6ef0f055d">SPHLockFreeHeap_t</a> SPHLockFreeHeapNearFind </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nearObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the containing SPHLockFreeHeap for a block of memory. </p>
<p>The containing lock free heap is found, if posible, then return LF heap address or NULL. From the near object pointer round down using increasing powers of 2 until a valid block header is found. If the block header is marked as a LockFreeHeap, return the block address. Otherwise return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nearObj</td><td>pointer to any current or previous allocation within the target heap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the containing SPHLockFreeHeap_t, or NULL if not found. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 11 2016 05:16:51 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
