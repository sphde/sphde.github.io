<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlogportal.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphlogportal.h File Reference</h1>
<p>Shared Persistent Heap, log Portal. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to collect a set of Lock Free Loggers (SPHLFLogger_t) and control the switching to a fresh logger when it fills up, in a non-blocking but thread safe manner.  
<a href="#_details">More...</a></p>
<code>#include &quot;sastype.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphlflogger_8h_source.html">sphlflogger.h</a>&quot;</code><br/>

<p><a href="sphlogportal_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of a Log Portal Iterator.  <a href="structSPHLFPortalIterator__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle to an instance of SPH Log Portal.  <a href="#a6ad505308f62af2bbe9843f24940f38a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a1d49c9db12c09c12cec6ad27160c35a9">SPHLogPortalInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a shared storage block as a Log Portal.  <a href="#a1d49c9db12c09c12cec6ad27160c35a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a2bebd711c4e813c2ed5d48803a168cf9">SPHLogPortalCreate</a> (block_size_t buf_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Log Portal.  <a href="#a2bebd711c4e813c2ed5d48803a168cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#af60358d3e70610a83721cd9d890ede45">SPHLogPortalEmpty</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the specified Log Portal.  <a href="#af60358d3e70610a83721cd9d890ede45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a1347ec6f803398e07c904a9c855ee024">SPHLogPortalEntries</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of active Loggers in the portal list.  <a href="#a1347ec6f803398e07c904a9c855ee024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ae70c926293dba935861e60fce1a1669b">SPHLogPortalCapacity</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum number of Loggers the list can hold.  <a href="#ae70c926293dba935861e60fce1a1669b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ad95eaff0cc7464604584d74c77af9691">SPHLogPortalAddLogger</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a SPHLFLogger_t into the next free slot og this Log Portal. This Logger can be then be used to log events via the Log Portal (when it becomes the current logger). Use the SPHLogPortalAlloc* functions to allocate and complete log entries.  <a href="#ad95eaff0cc7464604584d74c77af9691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aab3338570c0b6f9c3d2241d7b31e37c1">SPHLogPortalGetCurrentLogger</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle of the current Logger target of the Portal.  <a href="#aab3338570c0b6f9c3d2241d7b31e37c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ac4ede44ae8d429519a753c3a64fd19a8">SPHLogPortalGetLoggerByIndex</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="sphlfentry_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a> index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle of the Logger in the Portal list slot specified by the index number.  <a href="#ac4ede44ae8d429519a753c3a64fd19a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aea742204fc65dc03123b3d855dd838a1">SPHLogPortalGetCurrentIndex</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of the current Logger target of the Portal.  <a href="#aea742204fc65dc03123b3d855dd838a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a739033891fd545e645802116f72ffaad">SPHLogPortalAllocStrideTimeStamped</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, int catcode, int subcode, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry.  <a href="#a739033891fd545e645802116f72ffaad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a7fd31eb77cae1e82f0920b0aa7302609">SPHLogPortalAllocTimeStamped</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, int catcode, int subcode, block_size_t alloc_size, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry.  <a href="#a7fd31eb77cae1e82f0920b0aa7302609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a4658ed70dbd791639755d537e5f8f349">SPHLFPortalCreateIterator</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *iteratorSpace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator positioned at the first entry of the first logger attached to this portal.  <a href="#a4658ed70dbd791639755d537e5f8f349"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a642037d4ae99fc9414a6963c40a083b9">SPHLFPortalIteratorNext</a> (<a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *iterator, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a sequence of completed logger entries in-order.  <a href="#a642037d4ae99fc9414a6963c40a083b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#abd0a48c02d266e410091b0e3f8c2da7b">SPHLogPortalAllocRaw</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, block_size_t alloc_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address of a (raw) Logger entry allocated from the current logger.  <a href="#abd0a48c02d266e410091b0e3f8c2da7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aadcc86c4ec3624fdbb47b2c30dc3ab15">SPHLogPortalDestroy</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the Log Portal and free the storage.  <a href="#aadcc86c4ec3624fdbb47b2c30dc3ab15"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, log Portal. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to collect a set of Lock Free Loggers (SPHLFLogger_t) and control the switching to a fresh logger when it fills up, in a non-blocking but thread safe manner. </p>
<p>! A Log Portal manages a set of Lock Free Loggers. This includes:</p>
<ol type="1">
<li>Managing a list of Logger spaces available for logging events.<ul>
<li>Allocating the next free slot for adding a logger to the list.</li>
<li>Managing the current Logger within the list.</li>
<li>Control access to the Logger list elements.</li>
</ul>
</li>
<li>Passing Logger event allocation requests through to the current Logger.</li>
<li>Advancing the Current logger to next free Logger when the current Logger fills up.</li>
</ol>
<p>A portal is used when the required capacity for logger entries exceeds that posible for a single logger. Or we need to support rolling/continous logs over a long period of time. By switching out filled loggers with new/empty loggers, logging can continue indeffinitely. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a6ad505308f62af2bbe9843f24940f38a"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortal_t" ref="a6ad505308f62af2bbe9843f24940f38a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle to an instance of SPH Log Portal. </p>
<p>The type is SAS_RUNTIME_LOGPORTAL </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4658ed70dbd791639755d537e5f8f349"></a><!-- doxytag: member="sphlogportal.h::SPHLFPortalCreateIterator" ref="a4658ed70dbd791639755d537e5f8f349" args="(SPHLogPortal_t portal, SPHLFPortalIterator_t *iteratorSpace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a>* SPHLFPortalCreateIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iteratorSpace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an iterator positioned at the first entry of the first logger attached to this portal. </p>
<p>Returns the handle of a Portal Iterator. The iterator can be used to iterate through the completed entries of the attached loggers. Starting with the initial logger and continuing in sequence through any additional loggers that are non-empty.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iteratorSpace</em>&nbsp;</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLogIterator__t.html" title="Instance of a Lock Free Logger Iterator.">SPHLFLogIterator_t</a> associated with the log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the provided Iterator_space or NULL. If successful, The address of Iterator_space initialized as a <a class="el" href="structSPHLFPortalIterator__t.html" title="Instance of a Log Portal Iterator.">SPHLFPortalIterator_t</a> is returned. Otherwise NULL is returned (for example if the Portal was empty). </dd></dl>

</div>
</div>
<a class="anchor" id="a642037d4ae99fc9414a6963c40a083b9"></a><!-- doxytag: member="sphlogportal.h::SPHLFPortalIteratorNext" ref="a642037d4ae99fc9414a6963c40a083b9" args="(SPHLFPortalIterator_t *iterator, SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFPortalIteratorNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a sequence of completed logger entries in-order. </p>
<p>Returns the handle of the current logger entry for the current logger for the provided Portal Iterator. The logger entry handle can of then be used to access the contents of the logger entry. The iterator is advanced to the next logger entry. If the iterator is positioned at the end of the current logger then the iterator will be advanced to the first entry of the next logger allocated to this portal. If we are at the end of the list of allocated loggers we are done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterator</em>&nbsp;</td><td>Handle asociated with a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle.">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the provided handlespace or NULL. If successful, The address of handlespace initialized as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle.">SPHLFLoggerHandle_t</a> is returned. Otherwise NULL is returned (for example if the Portal was empty or we are at the end of the last logger). </dd></dl>

</div>
</div>
<a class="anchor" id="ad95eaff0cc7464604584d74c77af9691"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalAddLogger" ref="ad95eaff0cc7464604584d74c77af9691" args="(SPHLogPortal_t portal, SPHLFLogger_t log)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalAddLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&nbsp;</td>
          <td class="paramname"> <em>log</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a SPHLFLogger_t into the next free slot og this Log Portal. This Logger can be then be used to log events via the Log Portal (when it becomes the current logger). Use the SPHLogPortalAlloc* functions to allocate and complete log entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>log</em>&nbsp;</td><td>Handle to a Lock Free Logger to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The provided SPHLFLogger_t handle or NULL. If successful, the provided Logger handle is returned. Otherwise NULL (For example the Add may fail if the Logger list is already at capacity.) </dd></dl>

</div>
</div>
<a class="anchor" id="abd0a48c02d266e410091b0e3f8c2da7b"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalAllocRaw" ref="abd0a48c02d266e410091b0e3f8c2da7b" args="(SPHLogPortal_t portal, block_size_t alloc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SPHLogPortalAllocRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the address of a (raw) Logger entry allocated from the current logger. </p>
<p>The allocation size is rounded up to the next quadword boundary. Mostly for internal use and testing. If the specified portal's loggers are full the allocation may fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>size in bytes of the entry to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the address of the raw Log Entry is returned if successful, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a739033891fd545e645802116f72ffaad"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalAllocStrideTimeStamped" ref="a739033891fd545e645802116f72ffaad" args="(SPHLogPortal_t portal, int catcode, int subcode, SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLogPortalAllocStrideTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catcode</em>&nbsp;</td><td>Category code for the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subcode</em>&nbsp;</td><td>subcategory code for the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle.">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of handleorg or NULL, The address of the initialized Log Entry Handle is returned if successful, or NULL if unsuccessful (for example the Allocate may fail if the last Logger in the list is full). </dd></dl>

</div>
</div>
<a class="anchor" id="a7fd31eb77cae1e82f0920b0aa7302609"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalAllocTimeStamped" ref="a7fd31eb77cae1e82f0920b0aa7302609" args="(SPHLogPortal_t portal, int catcode, int subcode, block_size_t alloc_size, SPHLFLoggerHandle_t *handlespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLogPortalAllocTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handlespace</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catcode</em>&nbsp;</td><td>Category code for the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subcode</em>&nbsp;</td><td>subcategory code for the new entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alloc_size</em>&nbsp;</td><td>Size in bytes of the entry to be allocated. The actual entry will be +16 bytes to include the entry header. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handlespace</em>&nbsp;</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle.">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address of handleorg or NULL, The address of the initialized Log Entry Handle is returned if successful, or NULL if unsuccessful (for example the allocate may fail if the last Logger in the list is full). </dd></dl>

</div>
</div>
<a class="anchor" id="ae70c926293dba935861e60fce1a1669b"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalCapacity" ref="ae70c926293dba935861e60fce1a1669b" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLogPortalCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum number of Loggers the list can hold. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum number of Logger entries for this portal. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bebd711c4e813c2ed5d48803a168cf9"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalCreate" ref="a2bebd711c4e813c2ed5d48803a168cf9" args="(block_size_t buf_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> SPHLogPortalCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and initialize a shared storage block as a Log Portal. </p>
<p>Allocate a block from SAS storage and initialize that block as a Log Portal. The storage block must be power of two in size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the portal to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aadcc86c4ec3624fdbb47b2c30dc3ab15"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalDestroy" ref="aadcc86c4ec3624fdbb47b2c30dc3ab15" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLogPortalDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the Log Portal and free the storage. </p>
<p>NOTE need to add code to free any attached Loggers</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Logger to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="af60358d3e70610a83721cd9d890ede45"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalEmpty" ref="af60358d3e70610a83721cd9d890ede45" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLogPortalEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the specified Log Portal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the portal is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a1347ec6f803398e07c904a9c855ee024"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalEntries" ref="a1347ec6f803398e07c904a9c855ee024" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLogPortalEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of active Loggers in the portal list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>current number of Logger entries for this portal. </dd></dl>

</div>
</div>
<a class="anchor" id="aea742204fc65dc03123b3d855dd838a1"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalGetCurrentIndex" ref="aea742204fc65dc03123b3d855dd838a1" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHLogPortalGetCurrentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the index of the current Logger target of the Portal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Non-negative int or -1, The current Logger index is returned if successful, or -1 if unsuccessful. For example the Get may fail if the Logger list is currently empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aab3338570c0b6f9c3d2241d7b31e37c1"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalGetCurrentLogger" ref="aab3338570c0b6f9c3d2241d7b31e37c1" args="(SPHLogPortal_t portal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalGetCurrentLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the handle of the current Logger target of the Portal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SPHLFLogger_t or NULL, The Logger handle is returned if successful, or NULL if unsuccessful. For example the Get may fail if the Logger list is currently empty or the last available Logger is already full. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ede44ae8d429519a753c3a64fd19a8"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalGetLoggerByIndex" ref="ac4ede44ae8d429519a753c3a64fd19a8" args="(SPHLogPortal_t portal, longPtr_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalGetLoggerByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&nbsp;</td>
          <td class="paramname"> <em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlfentry_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the handle of the Logger in the Portal list slot specified by the index number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portal</em>&nbsp;</td><td>Handle to a Log Portal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the logger to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SPHLFLogger_t or NULL, The Logger address is returned if successful, or NULL if unsuccessful. For example the Get may fail if the Logger list is currently empty or the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d49c9db12c09c12cec6ad27160c35a9"></a><!-- doxytag: member="sphlogportal.h::SPHLogPortalInit" ref="a1d49c9db12c09c12cec6ad27160c35a9" args="(void *buf_seg, block_size_t buf_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> SPHLogPortalInit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>buf_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a shared storage block as a Log Portal. </p>
<p>Initialize the control blocks within the specified storage block as a Log Portal. The storage block must be power of two in size and have the same power of two (or better) alignment. The type will be SAS_RUNTIME_LOGPORTAL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf_seg</em>&nbsp;</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf_size</em>&nbsp;</td><td>power of two size of the portal to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 7 Jan 2015 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
