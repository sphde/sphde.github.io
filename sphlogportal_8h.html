<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphlogportal.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphlogportal.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, log Portal. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to collect a set of Lock Free Loggers (SPHLFLogger_t) and control the switching to a fresh logger when it fills up, in a non-blocking but thread safe manner.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sphlflogger_8h_source.html">sphlflogger.h</a>&quot;</code><br />
</div>
<p><a href="sphlogportal_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Log Portal Iterator.  <a href="structSPHLFPortalIterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6ad505308f62af2bbe9843f24940f38a"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a></td></tr>
<tr class="memdesc:a6ad505308f62af2bbe9843f24940f38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to an instance of SPH Log Portal.  <a href="#a6ad505308f62af2bbe9843f24940f38a">More...</a><br /></td></tr>
<tr class="separator:a6ad505308f62af2bbe9843f24940f38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d49c9db12c09c12cec6ad27160c35a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a1d49c9db12c09c12cec6ad27160c35a9">SPHLogPortalInit</a> (void *buf_seg, block_size_t buf_size)</td></tr>
<tr class="memdesc:a1d49c9db12c09c12cec6ad27160c35a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shared storage block as a Log Portal.  <a href="#a1d49c9db12c09c12cec6ad27160c35a9">More...</a><br /></td></tr>
<tr class="separator:a1d49c9db12c09c12cec6ad27160c35a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bebd711c4e813c2ed5d48803a168cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a2bebd711c4e813c2ed5d48803a168cf9">SPHLogPortalCreate</a> (block_size_t buf_size)</td></tr>
<tr class="memdesc:a2bebd711c4e813c2ed5d48803a168cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared storage block as a Log Portal.  <a href="#a2bebd711c4e813c2ed5d48803a168cf9">More...</a><br /></td></tr>
<tr class="separator:a2bebd711c4e813c2ed5d48803a168cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60358d3e70610a83721cd9d890ede45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#af60358d3e70610a83721cd9d890ede45">SPHLogPortalEmpty</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:af60358d3e70610a83721cd9d890ede45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the specified Log Portal.  <a href="#af60358d3e70610a83721cd9d890ede45">More...</a><br /></td></tr>
<tr class="separator:af60358d3e70610a83721cd9d890ede45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347ec6f803398e07c904a9c855ee024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a1347ec6f803398e07c904a9c855ee024">SPHLogPortalEntries</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:a1347ec6f803398e07c904a9c855ee024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of active Loggers in the portal list.  <a href="#a1347ec6f803398e07c904a9c855ee024">More...</a><br /></td></tr>
<tr class="separator:a1347ec6f803398e07c904a9c855ee024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70c926293dba935861e60fce1a1669b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ae70c926293dba935861e60fce1a1669b">SPHLogPortalCapacity</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:ae70c926293dba935861e60fce1a1669b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of Loggers the list can hold.  <a href="#ae70c926293dba935861e60fce1a1669b">More...</a><br /></td></tr>
<tr class="separator:ae70c926293dba935861e60fce1a1669b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95eaff0cc7464604584d74c77af9691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ad95eaff0cc7464604584d74c77af9691">SPHLogPortalAddLogger</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> log)</td></tr>
<tr class="memdesc:ad95eaff0cc7464604584d74c77af9691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a SPHLFLogger_t into the next free slot og this Log Portal. This Logger can be then be used to log events via the Log Portal (when it becomes the current logger). Use the SPHLogPortalAlloc* functions to allocate and complete log entries.  <a href="#ad95eaff0cc7464604584d74c77af9691">More...</a><br /></td></tr>
<tr class="separator:ad95eaff0cc7464604584d74c77af9691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3338570c0b6f9c3d2241d7b31e37c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aab3338570c0b6f9c3d2241d7b31e37c1">SPHLogPortalGetCurrentLogger</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:aab3338570c0b6f9c3d2241d7b31e37c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle of the current Logger target of the Portal.  <a href="#aab3338570c0b6f9c3d2241d7b31e37c1">More...</a><br /></td></tr>
<tr class="separator:aab3338570c0b6f9c3d2241d7b31e37c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ede44ae8d429519a753c3a64fd19a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#ac4ede44ae8d429519a753c3a64fd19a8">SPHLogPortalGetLoggerByIndex</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="sphlflogger_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a> index)</td></tr>
<tr class="memdesc:ac4ede44ae8d429519a753c3a64fd19a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle of the Logger in the Portal list slot specified by the index number.  <a href="#ac4ede44ae8d429519a753c3a64fd19a8">More...</a><br /></td></tr>
<tr class="separator:ac4ede44ae8d429519a753c3a64fd19a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea742204fc65dc03123b3d855dd838a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aea742204fc65dc03123b3d855dd838a1">SPHLogPortalGetCurrentIndex</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:aea742204fc65dc03123b3d855dd838a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the current Logger target of the Portal.  <a href="#aea742204fc65dc03123b3d855dd838a1">More...</a><br /></td></tr>
<tr class="separator:aea742204fc65dc03123b3d855dd838a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739033891fd545e645802116f72ffaad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a739033891fd545e645802116f72ffaad">SPHLogPortalAllocStrideTimeStamped</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, int catcode, int subcode, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a739033891fd545e645802116f72ffaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry.  <a href="#a739033891fd545e645802116f72ffaad">More...</a><br /></td></tr>
<tr class="separator:a739033891fd545e645802116f72ffaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd31eb77cae1e82f0920b0aa7302609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a7fd31eb77cae1e82f0920b0aa7302609">SPHLogPortalAllocTimeStamped</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, int catcode, int subcode, block_size_t alloc_size, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a7fd31eb77cae1e82f0920b0aa7302609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry.  <a href="#a7fd31eb77cae1e82f0920b0aa7302609">More...</a><br /></td></tr>
<tr class="separator:a7fd31eb77cae1e82f0920b0aa7302609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4658ed70dbd791639755d537e5f8f349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a4658ed70dbd791639755d537e5f8f349">SPHLFPortalCreateIterator</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *iteratorSpace)</td></tr>
<tr class="memdesc:a4658ed70dbd791639755d537e5f8f349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an iterator positioned at the first entry of the first logger attached to this portal.  <a href="#a4658ed70dbd791639755d537e5f8f349">More...</a><br /></td></tr>
<tr class="separator:a4658ed70dbd791639755d537e5f8f349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642037d4ae99fc9414a6963c40a083b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#a642037d4ae99fc9414a6963c40a083b9">SPHLFPortalIteratorNext</a> (<a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *iterator, <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *handlespace)</td></tr>
<tr class="memdesc:a642037d4ae99fc9414a6963c40a083b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a sequence of completed logger entries in-order.  <a href="#a642037d4ae99fc9414a6963c40a083b9">More...</a><br /></td></tr>
<tr class="separator:a642037d4ae99fc9414a6963c40a083b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a48c02d266e410091b0e3f8c2da7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#abd0a48c02d266e410091b0e3f8c2da7b">SPHLogPortalAllocRaw</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal, block_size_t alloc_size)</td></tr>
<tr class="memdesc:abd0a48c02d266e410091b0e3f8c2da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the address of a (raw) Logger entry allocated from the current logger.  <a href="#abd0a48c02d266e410091b0e3f8c2da7b">More...</a><br /></td></tr>
<tr class="separator:abd0a48c02d266e410091b0e3f8c2da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc86c4ec3624fdbb47b2c30dc3ab15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphlogportal_8h.html#aadcc86c4ec3624fdbb47b2c30dc3ab15">SPHLogPortalDestroy</a> (<a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> portal)</td></tr>
<tr class="memdesc:aadcc86c4ec3624fdbb47b2c30dc3ab15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Log Portal and free the storage.  <a href="#aadcc86c4ec3624fdbb47b2c30dc3ab15">More...</a><br /></td></tr>
<tr class="separator:aadcc86c4ec3624fdbb47b2c30dc3ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, log Portal. For shared memory multi-thread/multi-core applications. This implementation uses atomic operations to collect a set of Lock Free Loggers (SPHLFLogger_t) and control the switching to a fresh logger when it fills up, in a non-blocking but thread safe manner. </p>
<p>! A Log Portal manages a set of Lock Free Loggers. This includes:</p><ol type="1">
<li>Managing a list of Logger spaces available for logging events.<ul>
<li>Allocating the next free slot for adding a logger to the list.</li>
<li>Managing the current Logger within the list.</li>
<li>Control access to the Logger list elements.</li>
</ul>
</li>
<li>Passing Logger event allocation requests through to the current Logger.</li>
<li>Advancing the Current logger to next free Logger when the current Logger fills up.</li>
</ol>
<p>A portal is used when the required capacity for logger entries exceeds that posible for a single logger. Or we need to support rolling/continuous logs over a long period of time. By switching out filled loggers with new/empty loggers, logging can continue indeffinitely. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a6ad505308f62af2bbe9843f24940f38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to an instance of SPH Log Portal. </p>
<p>The type is SAS_RUNTIME_LOGPORTAL </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4658ed70dbd791639755d537e5f8f349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a>* SPHLFPortalCreateIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iteratorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an iterator positioned at the first entry of the first logger attached to this portal. </p>
<p>Returns the handle of a Portal Iterator. The iterator can be used to iterate through the completed entries of the attached loggers. Starting with the initial logger and continuing in sequence through any additional loggers that are non-empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">iteratorSpace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLogIterator__t.html" title="Instance of a Lock Free Logger Iterator. ">SPHLFLogIterator_t</a> associated with the log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the provided Iterator_space or NULL. If successful, The address of Iterator_space initialized as a <a class="el" href="structSPHLFPortalIterator__t.html" title="Instance of a Log Portal Iterator. ">SPHLFPortalIterator_t</a> is returned. Otherwise NULL is returned (for example if the Portal was empty). </dd></dl>

</div>
</div>
<a class="anchor" id="a642037d4ae99fc9414a6963c40a083b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLFPortalIteratorNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSPHLFPortalIterator__t.html">SPHLFPortalIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a sequence of completed logger entries in-order. </p>
<p>Returns the handle of the current logger entry for the current logger for the provided Portal Iterator. The logger entry handle can of then be used to access the contents of the logger entry. The iterator is advanced to the next logger entry. If the iterator is positioned at the end of the current logger then the iterator will be advanced to the first entry of the next logger allocated to this portal. If we are at the end of the list of allocated loggers we are done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Handle associated with a Log Portal. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the provided handlespace or NULL. If successful, The address of handlespace initialized as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> is returned. Otherwise NULL is returned (for example if the Portal was empty or we are at the end of the last logger). </dd></dl>

</div>
</div>
<a class="anchor" id="ad95eaff0cc7464604584d74c77af9691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalAddLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a>&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a SPHLFLogger_t into the next free slot og this Log Portal. This Logger can be then be used to log events via the Log Portal (when it becomes the current logger). Use the SPHLogPortalAlloc* functions to allocate and complete log entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">log</td><td>Handle to a Lock Free Logger to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The provided SPHLFLogger_t handle or NULL. If successful, the provided Logger handle is returned. Otherwise NULL (For example the Add may fail if the Logger list is already at capacity.) </dd></dl>

</div>
</div>
<a class="anchor" id="abd0a48c02d266e410091b0e3f8c2da7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> void* SPHLogPortalAllocRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the address of a (raw) Logger entry allocated from the current logger. </p>
<p>The allocation size is rounded up to the next quadword boundary. Mostly for internal use and testing. If the specified portal's loggers are full the allocation may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>size in bytes of the entry to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the raw Log Entry is returned if successful, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a739033891fd545e645802116f72ffaad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLogPortalAllocStrideTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code for the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code for the new entry. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of handleorg or NULL, The address of the initialized Log Entry Handle is returned if successful, or NULL if unsuccessful (for example the Allocate may fail if the last Logger in the list is full). </dd></dl>

</div>
</div>
<a class="anchor" id="a7fd31eb77cae1e82f0920b0aa7302609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a>* SPHLogPortalAllocTimeStamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>alloc_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSPHLFLoggerHandle__t.html">SPHLFLoggerHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handlespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the handle of a Logger entry allocated from the current logger of the Portal. If the current logger is full, attempt to move current to the next available Logger and retry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code for the new entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>subcategory code for the new entry. </td></tr>
    <tr><td class="paramname">alloc_size</td><td>Size in bytes of the entry to be allocated. The actual entry will be +16 bytes to include the entry header. </td></tr>
    <tr><td class="paramname">handlespace</td><td>Address of local area that will be initialied as a <a class="el" href="structSPHLFLoggerHandle__t.html" title="Instance of a Lock Free Logger Entry Handle. ">SPHLFLoggerHandle_t</a> for the allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of handleorg or NULL, The address of the initialized Log Entry Handle is returned if successful, or NULL if unsuccessful (for example the allocate may fail if the last Logger in the list is full). </dd></dl>

</div>
</div>
<a class="anchor" id="ae70c926293dba935861e60fce1a1669b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLogPortalCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum number of Loggers the list can hold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum number of Logger entries for this portal. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bebd711c4e813c2ed5d48803a168cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> SPHLogPortalCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared storage block as a Log Portal. </p>
<p>Allocate a block from SAS storage and initialize that block as a Log Portal. The storage block must be power of two in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_size</td><td>power of two size of the portal to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
<a class="anchor" id="aadcc86c4ec3624fdbb47b2c30dc3ab15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLogPortalDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the Log Portal and free the storage. </p>
<p>NOTE need to add code to free any attached Loggers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Logger to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="af60358d3e70610a83721cd9d890ede45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLogPortalEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the specified Log Portal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the portal is currently Empty (no entries). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a1347ec6f803398e07c904a9c855ee024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLogPortalEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of active Loggers in the portal list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current number of Logger entries for this portal. </dd></dl>

</div>
</div>
<a class="anchor" id="aea742204fc65dc03123b3d855dd838a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHLogPortalGetCurrentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the current Logger target of the Portal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative int or -1, The current Logger index is returned if successful, or -1 if unsuccessful. For example the Get may fail if the Logger list is currently empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aab3338570c0b6f9c3d2241d7b31e37c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalGetCurrentLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the handle of the current Logger target of the Portal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPHLFLogger_t or NULL, The Logger handle is returned if successful, or NULL if unsuccessful. For example the Get may fail if the Logger list is currently empty or the last available Logger is already full. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ede44ae8d429519a753c3a64fd19a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlflogger_8h.html#a646a159bf80760fb1554c78e9a34efec">SPHLFLogger_t</a> SPHLogPortalGetLoggerByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a>&#160;</td>
          <td class="paramname"><em>portal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlflogger_8h.html#a9e89948a0b6d5380f0dd2a41b945dc26">longPtr_t</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the handle of the Logger in the Portal list slot specified by the index number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portal</td><td>Handle to a Log Portal. </td></tr>
    <tr><td class="paramname">index</td><td>index of the logger to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPHLFLogger_t or NULL, The Logger address is returned if successful, or NULL if unsuccessful. For example the Get may fail if the Logger list is currently empty or the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d49c9db12c09c12cec6ad27160c35a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphtimer_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlogportal_8h.html#a6ad505308f62af2bbe9843f24940f38a">SPHLogPortal_t</a> SPHLogPortalInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shared storage block as a Log Portal. </p>
<p>Initialize the control blocks within the specified storage block as a Log Portal. The storage block must be power of two in size and have the same power of two (or better) alignment. The type will be SAS_RUNTIME_LOGPORTAL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_seg</td><td>a block of allocated SAS storage matching the buf_size. </td></tr>
    <tr><td class="paramname">buf_size</td><td>power of two size of the portal to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the initialized SPHLFLogger_t. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 11 2016 05:16:51 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
