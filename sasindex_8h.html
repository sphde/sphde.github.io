<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sasindex.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sasindex.h File Reference</h1>
<p>Shared Address Space B-tree based on binary values including virtual addresses.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="sasindexkey_8h_source.html">sasindexkey.h</a>&quot;</code><br/>
<code>#include &quot;sasindexnode.h&quot;</code><br/>

<p><a href="sasindex_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle to an instance of binary index B-tree.  <a href="#add83fd961a7f0e392d1ffe34aa50b2b3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a0d40519e1274d75e3c76d2b967bd66c7">SASIndexFixedCreate</a> (block_size_t block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a fixed SAS B-Tree of block_size size capacity.  <a href="#a0d40519e1274d75e3c76d2b967bd66c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#aaaff789ba031e6eee0618452440d744d">SASIndexExpandCreate</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function that creates new block of B-Tree nodes for an expanding SAS B-Tree <em>btree</em>.  <a href="#aaaff789ba031e6eee0618452440d744d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a861776412c36bcc755b4f49168f452be">SASIndexCreatePageSize</a> (block_size_t block_size, block_size_t page_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new expanding SAS B-Tree with <em>heap_size</em> size and <em>page_size</em> node size.  <a href="#a861776412c36bcc755b4f49168f452be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a3dbe7aba572d19b69ff76c47fd95e8ce">SASIndexCreate</a> (block_size_t block_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new expanding SAS B-Tree with initial <em>heap_size</em> size and default page_size for nodes.  <a href="#a3dbe7aba572d19b69ff76c47fd95e8ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a818d925ebd7d58a9b4b4de99324cc9a5">SASIndexDestroy</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the SAS B-Tree <em>btree</em>.  <a href="#a818d925ebd7d58a9b4b4de99324cc9a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a6faaf4f924119e3af5600422136a5f6f">SASIndexGetModCount</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number or insert/replace/remove operations performed on <em>btree</em>.  <a href="#a6faaf4f924119e3af5600422136a5f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a58c3ca27e445bb5c6c15009cb02e385e">SASIndexGetModCount_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number or insert/replace/remove operations performed on <em>btree</em>.  <a href="#a58c3ca27e445bb5c6c15009cb02e385e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a513a70e368f58e56218d630926df23b5">SASIndexGetMaxKey</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum key string from <em>btree</em>.  <a href="#a513a70e368f58e56218d630926df23b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#aca1975ec8e11783e88c1c451d1431a3c">SASIndexGetMaxKey_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum key string from <em>btree</em>.  <a href="#aca1975ec8e11783e88c1c451d1431a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#ae6f6496ddbe077536be5d2b96b4d0267">SASIndexGetMinKey</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the minimum key string from <em>btree</em>.  <a href="#ae6f6496ddbe077536be5d2b96b4d0267"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a9c112a3bb178316a976ab3cda0a40bac">SASIndexGetMinKey_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the minimum key string from <em>btree</em>.  <a href="#a9c112a3bb178316a976ab3cda0a40bac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#af0864fbc45af1a9f67974280d18bbc5b">SASIndexContainsKey</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the SAS B-Tree <em>btree</em> contains the key <em>key</em>.  <a href="#af0864fbc45af1a9f67974280d18bbc5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a959908a7e4fc3cf348a5a363ecdc8aaa">SASIndexContainsKey_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the SAS B-Tree <em>btree</em> contains the key <em>key</em>.  <a href="#a959908a7e4fc3cf348a5a363ecdc8aaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#ac946e413d7611563a07ac80861c4e7fd">SASIndexGet</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the memory address value associated with <em>key</em> in SAS B-Tree <em>btree</em>.  <a href="#ac946e413d7611563a07ac80861c4e7fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a100556155a36b6f43fb73bf1e1b6bb95">SASIndexGet_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the memory address value associated with <em>key</em> in SAS B-Tree <em>btree</em>.  <a href="#a100556155a36b6f43fb73bf1e1b6bb95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a2a007f2b8f438c1a59ed87dedee5f37e">SASIndexIsEmpty</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the SAS B-Tree <em>btree</em> is empty.  <a href="#a2a007f2b8f438c1a59ed87dedee5f37e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a8840159d5c6739078b867e3fd63b846f">SASIndexIsEmpty_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if the SAS B-Tree <em>btree</em> is empty.  <a href="#a8840159d5c6739078b867e3fd63b846f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a37b4a3b0bef14f2a9b0ba9d7817c15b7">SASIndexPut</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element <em>value</em> with key <em>key</em> in the SAS B-Tree <em>btree</em>.  <a href="#a37b4a3b0bef14f2a9b0ba9d7817c15b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#aef5677ab8a45bd377558cec4fb89c1d8">SASIndexPut_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new element <em>value</em> with key <em>key</em> in the SAS B-Tree <em>btree</em>.  <a href="#aef5677ab8a45bd377558cec4fb89c1d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#aad6bc50f7dee46492f682faaa5abb48b">SASIndexReplace</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the associated value of the element with key <em>key</em> in SAS B-Tree <em>btree</em> with the value <em>value</em>.  <a href="#aad6bc50f7dee46492f682faaa5abb48b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a1d37450050681f1c82334c62a057bee8">SASIndexReplace_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key, void *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the associated value of the element with key <em>key</em> in SAS B-Tree <em>btree</em> with the value <em>value</em>.  <a href="#a1d37450050681f1c82334c62a057bee8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a47d57fc6f4df0104e8e3349d375cfdb1">SASIndexRemove</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the key <em>key</em> and its associated value from SAS B-Tree <em>btree</em>.  <a href="#a47d57fc6f4df0104e8e3349d375cfdb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a77437f6c4276d9c806d383a87dc24d78">SASIndexRemove_nolock</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree, <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the key <em>key</em> and its associated value from SAS B-Tree <em>btree</em>.  <a href="#a77437f6c4276d9c806d383a87dc24d78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#aa43069d9671fcabc24155cca5b1ba9d5">SASIndexInit</a> (void *btree_block, block_size_t btree_size, block_size_t page_size, int expanding)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function to initialize storage as a B-tree.  <a href="#aa43069d9671fcabc24155cca5b1ba9d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ block_size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#a127f331a403e10ab5f64e2f35252616b">SASIndexAllocSize</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the page size used for node allocation for <em>btree</em>.  <a href="#a127f331a403e10ab5f64e2f35252616b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ block_size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sasindex_8h.html#ad96c176e960f7832cf126205ac819a33">SASIndexFreeSpace</a> (<a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total available node free space for <em>btree</em>.  <a href="#ad96c176e960f7832cf126205ac819a33"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Address Space B-tree based on binary values including virtual addresses. </p>
<p>Allocate SAS block storage and manage it as a B-tree data structure using <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> struct as keys which are associated address value. This provides "map" (or association) between a binary value and an arbitrary address (an block or SPH object in SAS storage). One expected usage is to provide the reverse mapping from the address of a SAS block or SPH object back to its human readable label stored in a SASStringBTree_t. This is in fact the mechanism used by the SPHContext_t implementation.</p>
<p>The Index B-tree keeps the binary key data sorted and allows search/insert/delete in logarithmic time. The B-Tree is organized into page-size nodes to improve storage locality for search and minimize paging when very large B-Trees are needed.</p>
<p>A new Index can be constructed using the functions <a class="el" href="sasindex_8h.html#a3dbe7aba572d19b69ff76c47fd95e8ce" title="Create a new expanding SAS B-Tree with initial heap_size size and default page_size...">SASIndexCreate</a>, <a class="el" href="sasindex_8h.html#aaaff789ba031e6eee0618452440d744d" title="Internal function that creates new block of B-Tree nodes for an expanding SAS B-Tree...">SASIndexExpandCreate</a>, or <a class="el" href="sasindex_8h.html#a861776412c36bcc755b4f49168f452be" title="Create a new expanding SAS B-Tree with heap_size size and page_size node size.">SASIndexCreatePageSize</a>. The functions differs for the options provides. A SAS block can be initialized as a SBT by using the function <a class="el" href="sasindex_8h.html#aa43069d9671fcabc24155cca5b1ba9d5" title="Internal function to initialize storage as a B-tree.">SASIndexInit</a>.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3" title="Handle to an instance of binary index B-tree.">SASIndex_t</a> indexBTree;
 <a class="code" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> mykey;
 <span class="keywordtype">char</span> *myorigdata, *myassocdata;

 indexBTree = <a class="code" href="sasindex_8h.html#a3dbe7aba572d19b69ff76c47fd95e8ce" title="Create a new expanding SAS B-Tree with initial heap_size size and default page_size...">SASIndexCreate</a> (blockSize);
 <span class="keywordflow">if</span> (indexBTree)
   {  <span class="comment">// Use index to associate addresses of myassocdata with myorigdata</span>
     <a class="code" href="sasindexkey_8h.html#a4ed5838af625d9cde80ef0d280348653" title="Initial a binary key @ destination with a address value.">SASIndexKeyInitRef</a>(&amp;mykey, myorigdata);
     rc = <a class="code" href="sasindex_8h.html#a37b4a3b0bef14f2a9b0ba9d7817c15b7" title="Add a new element value with key key in the SAS B-Tree btree.">SASIndexPut</a> (indexBTree, &amp;mykey, myassocdata);
     <span class="keywordflow">if</span> (rc)
       {
         printf(<span class="stringliteral">&quot;Associated @%p with @%p in BTree@%p&quot;</span>,
           myassocdata, myorigdata, stringBTree);
      }
   }
</pre></div><p>The helper functions <a class="el" href="sasindex_8h.html#a37b4a3b0bef14f2a9b0ba9d7817c15b7" title="Add a new element value with key key in the SAS B-Tree btree.">SASIndexPut</a>, <a class="el" href="sasindex_8h.html#aad6bc50f7dee46492f682faaa5abb48b" title="Replace the associated value of the element with key key in SAS B-Tree btree with...">SASIndexReplace</a>, and <a class="el" href="sasindex_8h.html#a47d57fc6f4df0104e8e3349d375cfdb1" title="Remove the key key and its associated value from SAS B-Tree btree.">SASIndexRemove</a> can be used to insert, replace and remove a string/pointer tuple from SBT. Others useful functions are <a class="el" href="sasindex_8h.html#af0864fbc45af1a9f67974280d18bbc5b" title="Return true if the SAS B-Tree btree contains the key key.">SASIndexContainsKey</a>, which returns if a key exists; and <a class="el" href="sasindex_8h.html#ac946e413d7611563a07ac80861c4e7fd" title="Return the memory address value associated with key in SAS B-Tree btree.">SASIndexGet</a>, which returns the value of a key.</p>
<p>The enumeration API from <a class="el" href="sasindexenum_8h.html" title="Enumeration API for iteration over Shared Address Space binary B-tree index defined...">sasindexenum.h</a> can be use to iterate over the (in whole or part) of contents of BTree in key order.</p>
<p>The functions above apply SASLock and SASUnlock around each Index operation to insure consistency of the Index.</p>
<p>If at process needs exclusive access or needs to scan or populate an Index quickly, the application can SASLock the SASIndex_t, then use the *_nolock forms of the function above for faster access. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3" title="Handle to an instance of binary index B-tree.">SASIndex_t</a> indexBTree;
 <a class="code" href="sasindexenum_8h.html#a814f1df2e3490a3846761caa3a465c58" title="Handle to an instance of binary BTree Index Enumeration.">SASIndexEnum_t</a> senum;
 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *keyref;

 <a class="code" href="saslock_8h.html#a554c10c18c84297ce7a2ef91b1c4af42" title="Lock a SAS Address.">SASLock</a> (indexBTree, SasUserLock__READ);
 senum = <a class="code" href="sasindexenum_8h.html#a065b5993ccea3fb240854d5f3fadb68e" title="Create a SASIndexEnum_t enumeration that can be used to iterate over the key space...">SASIndexEnumCreate</a> (index);
 <span class="keywordflow">if</span> (!senum)
   {
     printf (<span class="stringliteral">&quot;SASIndexEnumCreate (%p) failed&quot;</span>, index);
     <span class="keywordflow">return</span> 1;
  }

 <span class="keywordflow">while</span> (<a class="code" href="sasindexenum_8h.html#a260a397fc45cc195e5316ec9e52202da" title="Return status of a SASIndexEnum_t enumeration.">SASIndexEnumHasMore</a> (senum))
  {
    keyref = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *) <a class="code" href="sasindexenum_8h.html#a25395ed0f961c8f25353cc10f8f2c14e" title="Move the enumeration to the next binary BTree Index key entry and return the associated...">SASIndexEnumNext_nolock</a> (senum);
    <span class="keywordflow">if</span> (keyref)
      {
      <span class="comment">// process reference value associated with next enum</span>
            }
   }
 <a class="code" href="saslock_8h.html#a33b8c7a9a5f493c42c8d4619e24a46d2" title="UnLock a SAS Address.">SASUnlock</a> (indexBTree);
</pre></div><p>Finally, a created SAS binary B-Tree <em>SASIndex_t</em> can be destroy with <a class="el" href="sasindex_8h.html#a818d925ebd7d58a9b4b4de99324cc9a5" title="Destroy the SAS B-Tree btree.">SASIndexDestroy</a>. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="add83fd961a7f0e392d1ffe34aa50b2b3"></a><!-- doxytag: member="sasindex.h::SASIndex_t" ref="add83fd961a7f0e392d1ffe34aa50b2b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle to an instance of binary index B-tree. </p>
<p>The type is SAS_RUNTIME_INDEX </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a127f331a403e10ab5f64e2f35252616b"></a><!-- doxytag: member="sasindex.h::SASIndexAllocSize" ref="a127f331a403e10ab5f64e2f35252616b" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ block_size_t SASIndexAllocSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the page size used for node allocation for <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle the to SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The page size value in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="af0864fbc45af1a9f67974280d18bbc5b"></a><!-- doxytag: member="sasindex.h::SASIndexContainsKey" ref="af0864fbc45af1a9f67974280d18bbc5b" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexContainsKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the SAS B-Tree <em>btree</em> contains the key <em>key</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>. This function searches the B-Tree for a matching key and returns true if found.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Null terminated key string to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the key is within <em>btree</em> or 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a959908a7e4fc3cf348a5a363ecdc8aaa"></a><!-- doxytag: member="sasindex.h::SASIndexContainsKey_nolock" ref="a959908a7e4fc3cf348a5a363ecdc8aaa" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexContainsKey_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the SAS B-Tree <em>btree</em> contains the key <em>key</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. This function searches the B-Tree for a matching key and returns true if found.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Null terminated key string to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the key is within <em>btree</em> or 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dbe7aba572d19b69ff76c47fd95e8ce"></a><!-- doxytag: member="sasindex.h::SASIndexCreate" ref="a3dbe7aba572d19b69ff76c47fd95e8ce" args="(block_size_t block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> SASIndexCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new expanding SAS B-Tree with initial <em>heap_size</em> size and default page_size for nodes. </p>
<p>Create and initialize a B-Tree. The storage block must be power of two in size and SAS type returned is SAS_RUNTIME_INDEX. The internal page size used is the default one defined in sasalloc.h (4096).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>Size of the B-Tree to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to created SASIndex_t or 0 if creation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a861776412c36bcc755b4f49168f452be"></a><!-- doxytag: member="sasindex.h::SASIndexCreatePageSize" ref="a861776412c36bcc755b4f49168f452be" args="(block_size_t block_size, block_size_t page_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> SASIndexCreatePageSize </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>page_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new expanding SAS B-Tree with <em>heap_size</em> size and <em>page_size</em> node size. </p>
<p>Similiar to <a class="el" href="sasindex_8h.html#a3dbe7aba572d19b69ff76c47fd95e8ce" title="Create a new expanding SAS B-Tree with initial heap_size size and default page_size...">SASIndexCreate</a> but with additional option to set the internal node page size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>Size of the B-Tree to create. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>page_size</em>&nbsp;</td><td>Size of the internal node pages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to created SASCompoundHeap_t or 0 if creation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a818d925ebd7d58a9b4b4de99324cc9a5"></a><!-- doxytag: member="sasindex.h::SASIndexDestroy" ref="a818d925ebd7d58a9b4b4de99324cc9a5" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void SASIndexDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the SAS B-Tree <em>btree</em>. </p>
<p>The type must be SAS_RUNTIME_INDEX. Destroy holds an exclusive write lock while clearing the control blocks and freeing the SAS block (or blocks for a expanding B-Tree).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle of the SASIndex_t to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaff789ba031e6eee0618452440d744d"></a><!-- doxytag: member="sasindex.h::SASIndexExpandCreate" ref="aaaff789ba031e6eee0618452440d744d" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> SASIndexExpandCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function that creates new block of B-Tree nodes for an expanding SAS B-Tree <em>btree</em>. </p>
<p>Create a block and initialize it to provide additional B-Tree node space to an existing expanding SAS B-Tree <em>btree</em>. This block is added the internal block list of the B-Tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>The SAS B-Tree to be expanded by one block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new SASStringBtree_t handle or 0 if the block allocate or initialization fails. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d40519e1274d75e3c76d2b967bd66c7"></a><!-- doxytag: member="sasindex.h::SASIndexFixedCreate" ref="a0d40519e1274d75e3c76d2b967bd66c7" args="(block_size_t block_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> SASIndexFixedCreate </td>
          <td>(</td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>block_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a fixed SAS B-Tree of block_size size capacity. </p>
<p>Create and initialize a B-Tree. The storage block must be power of two in size and the SAS type returned is SAS_RUNTIME_STRINGBTREE. The internal page size used is the default one defined in sasalloc.h (4096).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block_size</em>&nbsp;</td><td>Size of the B-Tree to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to created SASStringBtree_t or 0 if creation fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ad96c176e960f7832cf126205ac819a33"></a><!-- doxytag: member="sasindex.h::SASIndexFreeSpace" ref="ad96c176e960f7832cf126205ac819a33" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ block_size_t SASIndexFreeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the total available node free space for <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a write lock while calculating the total node free space from B-Tree.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total available free node space in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac946e413d7611563a07ac80861c4e7fd"></a><!-- doxytag: member="sasindex.h::SASIndexGet" ref="ac946e413d7611563a07ac80861c4e7fd" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the memory address value associated with <em>key</em> in SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>. This function searches the B-Tree for a matching key and if found, returns the associated memory address value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> key to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The associated memory address with <em>key</em> or 0 if the B-Tree <em>btree</em> does not contain the key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a100556155a36b6f43fb73bf1e1b6bb95"></a><!-- doxytag: member="sasindex.h::SASIndexGet_nolock" ref="a100556155a36b6f43fb73bf1e1b6bb95" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexGet_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the memory address value associated with <em>key</em> in SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. This function searches the B-Tree for a matching key and if found, returns the associated memory address value.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> key to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The associated memory address with <em>key</em> or 0 if the B-Tree <em>btree</em> does not contain the key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a513a70e368f58e56218d630926df23b5"></a><!-- doxytag: member="sasindex.h::SASIndexGetMaxKey" ref="a513a70e368f58e56218d630926df23b5" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a>* SASIndexGetMaxKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum key string from <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>. The maximum key is the right most entry of the right most node.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this value it stored in the header of the SASIndex_t initial block and should never be modified by the application.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> from B-Tree <em>btree</em> or 0 if the B-Tree does not have any key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="aca1975ec8e11783e88c1c451d1431a3c"></a><!-- doxytag: member="sasindex.h::SASIndexGetMaxKey_nolock" ref="aca1975ec8e11783e88c1c451d1431a3c" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a>* SASIndexGetMaxKey_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum key string from <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The maximum key is the right most entry of the right most node.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this value it stored in the header of the SASIndex_t initial block and should never be modified by the application.</dd></dl>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> from B-Tree <em>btree</em> or 0 if the B-Tree does not have any key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6f6496ddbe077536be5d2b96b4d0267"></a><!-- doxytag: member="sasindex.h::SASIndexGetMinKey" ref="ae6f6496ddbe077536be5d2b96b4d0267" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a>* SASIndexGetMinKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the minimum key string from <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>. The minimum key is the left most entry of the left most node.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this value it stored in the header of the SASIndex_t initial block and should never be modified by the application.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> from B-Tree <em>btree</em> or 0 if the B-Tree does not have any key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c112a3bb178316a976ab3cda0a40bac"></a><!-- doxytag: member="sasindex.h::SASIndexGetMinKey_nolock" ref="a9c112a3bb178316a976ab3cda0a40bac" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a>* SASIndexGetMinKey_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the minimum key string from <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The minimum key is the left most entry of the left most node.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this value it stored in the header of the SASIndex_t initial block and should never be modified by the application.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>handle to maximum <a class="el" href="structSASIndexKey__t.html" title="Index Key Handle structure for binary index B-trees.">SASIndexKey_t</a> from B-Tree <em>btree</em> or 0 if the B-Tree does not have any key or if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a6faaf4f924119e3af5600422136a5f6f"></a><!-- doxytag: member="sasindex.h::SASIndexGetModCount" ref="a6faaf4f924119e3af5600422136a5f6f" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ long SASIndexGetModCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number or insert/replace/remove operations performed on <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>. An initialized SAS B-Tree starts with mod count 1 and it is incremented each time a insert/replace/remove operation is performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of insert/replace/remove operations performed on <em>btree</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a58c3ca27e445bb5c6c15009cb02e385e"></a><!-- doxytag: member="sasindex.h::SASIndexGetModCount_nolock" ref="a58c3ca27e445bb5c6c15009cb02e385e" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ long SASIndexGetModCount_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number or insert/replace/remove operations performed on <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. An initialized SAS B-Tree starts with mod count 1 and it is incremented each time a insert/replace/remove operation is performed.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of insert/replace/remove operations performed on <em>btree</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa43069d9671fcabc24155cca5b1ba9d5"></a><!-- doxytag: member="sasindex.h::SASIndexInit" ref="aa43069d9671fcabc24155cca5b1ba9d5" args="(void *btree_block, block_size_t btree_size, block_size_t page_size, int expanding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a> SASIndexInit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>btree_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>btree_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_size_t&nbsp;</td>
          <td class="paramname"> <em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>expanding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal function to initialize storage as a B-tree. </p>
<p>An internal function used to initialize the control blocks within the specific storage block <em>block</em> as a SAS binary index B-tree. Both <em>block_size</em> and <em>page_size</em> must be power of two in size and have the same power of two (or better) alignment. The SAS type created is SAS_RUNTIME_STRINGBTREE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree_block</em>&nbsp;</td><td>Block of allocated SAS storage. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>btree_size</em>&nbsp;</td><td>Size of the B-tree within the block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>page_size</em>&nbsp;</td><td>Size of page size to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expanding</em>&nbsp;</td><td>boolean indicates if the B-tree is expand or fixed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the initialized SASIndex_t or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a007f2b8f438c1a59ed87dedee5f37e"></a><!-- doxytag: member="sasindex.h::SASIndexIsEmpty" ref="a2a007f2b8f438c1a59ed87dedee5f37e" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the SAS B-Tree <em>btree</em> is empty. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a read lock over B-Tree <em>btree</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the B-Tree is not empty or 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8840159d5c6739078b867e3fd63b846f"></a><!-- doxytag: member="sasindex.h::SASIndexIsEmpty_nolock" ref="a8840159d5c6739078b867e3fd63b846f" args="(SASIndex_t btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexIsEmpty_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if the SAS B-Tree <em>btree</em> is empty. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the B-Tree is not empty or 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a37b4a3b0bef14f2a9b0ba9d7817c15b7"></a><!-- doxytag: member="sasindex.h::SASIndexPut" ref="a37b4a3b0bef14f2a9b0ba9d7817c15b7" args="(SASIndex_t btree, SASIndexKey_t *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element <em>value</em> with key <em>key</em> in the SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a write lock over B-Tree <em>btree</em>. This function inserts the key and associated memory address value into the B-Tree. This B-Tree implementation does not allow duplicated key values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key to use as index for the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Memory address to insert in the B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the operation succeeds or 0 otherwise. For example if the key already exist in this B-Tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aef5677ab8a45bd377558cec4fb89c1d8"></a><!-- doxytag: member="sasindex.h::SASIndexPut_nolock" ref="aef5677ab8a45bd377558cec4fb89c1d8" args="(SASIndex_t btree, SASIndexKey_t *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SASIndexPut_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new element <em>value</em> with key <em>key</em> in the SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. This function inserts the key and associated memory address value into the B-Tree. This B-Tree implementation does not allow duplicated key values.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key to use as index for the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Memory address to insert in the B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the operation succeeds or 0 otherwise. For example if the key already exist in this B-Tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a47d57fc6f4df0104e8e3349d375cfdb1"></a><!-- doxytag: member="sasindex.h::SASIndexRemove" ref="a47d57fc6f4df0104e8e3349d375cfdb1" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the key <em>key</em> and its associated value from SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a write lock over B-Tree <em>btree</em>. This function searches the B-Tree for a matching key and if found, removes the key and associates value from this B-Tree.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>removing the key and associated value from the B-Tree does not remove or alter the data at that memory address. It only removes the associated between the and key and the address from this B-Tree.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key value to be removed from this B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the previous item or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a77437f6c4276d9c806d383a87dc24d78"></a><!-- doxytag: member="sasindex.h::SASIndexRemove_nolock" ref="a77437f6c4276d9c806d383a87dc24d78" args="(SASIndex_t btree, SASIndexKey_t *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexRemove_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the key <em>key</em> and its associated value from SAS B-Tree <em>btree</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. This function searches the B-Tree for a matching key and if found, removes the key and associates value from this B-Tree.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>removing the key and associated value from the B-Tree does not remove or alter the data at that memory address. It only removes the associated between the and key and the address from this B-Tree.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key value to be removed from this B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the previous item or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="aad6bc50f7dee46492f682faaa5abb48b"></a><!-- doxytag: member="sasindex.h::SASIndexReplace" ref="aad6bc50f7dee46492f682faaa5abb48b" args="(SASIndex_t btree, SASIndexKey_t *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the associated value of the element with key <em>key</em> in SAS B-Tree <em>btree</em> with the value <em>value</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. The function holds a write lock over B-Tree <em>btree</em>. This function searches the B-Tree for a matching key and if found, replaces the associated memory address value with <em>value</em>, and returns the previous associated value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key to use as index for the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Memory address to replace in the B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the previous associated value for the matching key, or 0 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d37450050681f1c82334c62a057bee8"></a><!-- doxytag: member="sasindex.h::SASIndexReplace_nolock" ref="a1d37450050681f1c82334c62a057bee8" args="(SASIndex_t btree, SASIndexKey_t *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ void* SASIndexReplace_nolock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sasindex_8h.html#add83fd961a7f0e392d1ffe34aa50b2b3">SASIndex_t</a>&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSASIndexKey__t.html">SASIndexKey_t</a> *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the associated value of the element with key <em>key</em> in SAS B-Tree <em>btree</em> with the value <em>value</em>. </p>
<p>The sas_type_t must be SAS_RUNTIME_INDEX. This function searches the B-Tree for a matching key and if found, replaces the associated memory address value with <em>value</em>, and returns the previous associated value.</p>
<p>This nolock form should only be used when the referenced SASIndex_t is known to be locked by the application or contained within a larger structure with a controlling lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>btree</em>&nbsp;</td><td>Handle to the SASIndex_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Key to use as index for the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Memory address to replace in the B-Tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the previous associated value for the matching key, or 0 if an error occurs. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 3 Jun 2014 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
