<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphdirectpcqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/sphdirectpcqueue.h File Reference</h1>
<p>Shared Persistent Heap, single producer single consumer queue direct API.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;sastype.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphlfentry_8h_source.html">sphlfentry.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sphsinglepcqueue_8h_source.html">sphsinglepcqueue.h</a>&quot;</code><br/>

<p><a href="sphdirectpcqueue_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a><!-- doxytag: member="sphdirectpcqueue.h::__C__" ref="a4d08a6f74d96b695afefd03854839b83" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ignore this macro behind the curtain <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance of a Lock Free event direct data Handle.  <a href="#a206f641019c26a3569dcfd8bbdc56377"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a0870fbd111ff161e696d4582b2b04759">SPHLFEntryDirectComplete</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle, <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> entry_template, int catcode, int subcode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete.  <a href="#a0870fbd111ff161e696d4582b2b04759"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a873945ea6ab74626e7ea1cc293bd0d03">SPHLFEntryDirectGetFreePtr</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first free byte address for the direct entry specified by the direct entry handle. This is normally the byte after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update.">sphLFEntry_t</a>.  <a href="#a873945ea6ab74626e7ea1cc293bd0d03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a9c05f176d4d3ced51f47ccd7c318c088">SPHLFEntryDirectGetPtrAligned</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle, size_t alignval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first free byte address, with required alignment, within the direct entry specified by the direct entry handle. This is normally the address after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update.">sphLFEntry_t</a> plus alignment padding.  <a href="#a9c05f176d4d3ced51f47ccd7c318c088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aa5cdfd616e0f427f57f7103c3c15b243">SPHLFEntryDirectIncAndAlign</a> (void *directptr, size_t incval, size_t alignval)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the next free byte address within direct entry specified by a current address within that direct entry.  <a href="#aa5cdfd616e0f427f57f7103c3c15b243"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a23788fc67715bb71768a4fefbeecdf62">SPHLFEntryDirectIsComplete</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#a23788fc67715bb71768a4fefbeecdf62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aa5f93f1d934f8751a9647c52ee917b7e">SPHLFEntryDirectIsTimestamped</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#aa5f93f1d934f8751a9647c52ee917b7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a13025380ee0723957e9709a59bc9bdfe">SPHLFEntryDirectCategory</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry category for the entry specified by the direct entry handle.  <a href="#a13025380ee0723957e9709a59bc9bdfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a429adbbe6673ae51a2dcfd513d1f2a17">SPHLFEntryDirectSubcat</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the direct entry handle.  <a href="#a429adbbe6673ae51a2dcfd513d1f2a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90">SPHSinglePCQueueGetEntryTemplate</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the entry template for an existing Lock Free Single Producer Single Consumer Queue. This template is used later to mark an allocated entry complete.  <a href="#a30c586b711cfa209da68d97c727a3f90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#ae97de2ad82066b7b61f1fcddaa56c6c0">SPHSinglePCQueueAllocStrideDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#ae97de2ad82066b7b61f1fcddaa56c6c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a4f5f678509240b9936705b5076ec3832">SPHSinglePCQueueAllocStrideDirectSpin</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is.  <a href="#a4f5f678509240b9936705b5076ec3832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#ad9ab882b3d0f06c9f4c603301e291bd2">SPHSinglePCQueueAllocStrideDirectSpinPause</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. While spinning use appropriate arch specific instructions to free up core resources for other threads.  <a href="#ad9ab882b3d0f06c9f4c603301e291bd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a42f22f8c49b31eeb7ddadd2d88889e24">SPHSinglePCQueueGetNextCompleteDirectSpin</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a42f22f8c49b31eeb7ddadd2d88889e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a273b8483e82ccb040661fed44f860189">SPHSinglePCQueueGetNextCompleteDirectSpinPause</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a273b8483e82ccb040661fed44f860189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a3a1241c61422534e4f6ab37c454a6e3a">SPHSinglePCQueueGetNextCompleteDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a3a1241c61422534e4f6ab37c454a6e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aecf42336a34826d5599d9d36bc4623b5">SPHSinglePCQueueFreeNextEntryDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> next_entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue.  <a href="#aecf42336a34826d5599d9d36bc4623b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a5702403a993f0e6923007b63b2377526">SPHSinglePCQueueGetNextEntryDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows the consumer to get the next allocated queue entry from the specified single producer single consumer queue.  <a href="#a5702403a993f0e6923007b63b2377526"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__C__ int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a334a4eb641f9bf8f9761057ebd5c53af">SPHSinglePCQueueEntryIsCompleteDirect</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#a334a4eb641f9bf8f9761057ebd5c53af"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared Persistent Heap, single producer single consumer queue direct API. </p>
<p>For shared memory multi-thread/multi-core applications. This implementation is based on the Lock Free Producer/Consumer Queue (SPHSinglePCQueue_t) but simplifies access to the Entry for lower latency.</p>
<p>This API supports atomic allocation of storage for queue entries for zero copy persistence and sharing. Zero copy queues divides the process of producing a queue entry in to three steps:</p>
<ul>
<li>Allocate the queue entry (and initialize the header)</li>
<li>Use the return entry handle to fill in application specific data.</li>
<li>Marks the entry complete in the header.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sphdirectpcqueue_8h.html" title="Shared Persistent Heap, single producer single consumer queue direct API.">sphdirectpcqueue.h</a>&gt;</span>

  <a class="code" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e" title="Aggregate type for handling sphLogEntryLayout_t.">sphLFEntryID_t</a> entry_tmp;

  <span class="comment">// only need to do this once per pcqueue and so should be</span>
  <span class="comment">// outside of the primary producer message loop.</span>
  entry_tmp = <a class="code" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90" title="Return the entry template for an existing Lock Free Single Producer Single Consumer...">SPHSinglePCQueueGetEntryTemplate</a>(pqueue);

  <a class="code" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377" title="Instance of a Lock Free event direct data Handle.">SPHLFEntryDirect_t</a> handle;

  <span class="keywordtype">int</span> *array;

  handle = <a class="code" href="sphdirectpcqueue_8h.html#a4f5f678509240b9936705b5076ec3832" title="Allows the producer thread to allocate and initialize the header of a queue entry...">SPHSinglePCQueueAllocStrideDirectSpin</a> (pqueue);
  <span class="keywordflow">if</span> (handle)
    {
      array = (<span class="keywordtype">int</span> *) <a class="code" href="sphdirectpcqueue_8h.html#a873945ea6ab74626e7ea1cc293bd0d03" title="Return the first free byte address for the direct entry specified by the direct entry...">SPHLFEntryDirectGetFreePtr</a> (handle);
      array[0] = val1;
      array[1] = val2;
      array[2] = val3;
      <a class="code" href="sphdirectpcqueue_8h.html#a0870fbd111ff161e696d4582b2b04759" title="Marks the entry specified by the entry handle as complete. Also executes write memory...">SPHLFEntryDirectComplete</a> (handle, entry_tmp, 1, 2);
    }
  <span class="keywordflow">else</span>
    {
      <span class="comment">// error handling</span>
    }
</pre></div><p>The consumer can access queue entries once they are marked complete. The consumer:</p>
<ul>
<li>checks (spins) for the next allocated entry to become complete.</li>
<li>uses the returned entry handle to directly access the entry contents.</li>
<li>When done processing the queue entry, it marks the entry header invalid and deallocates the entry.</li>
<li>This makes the next queue entry available, if any.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="sphdirectpcqueue_8h.html" title="Shared Persistent Heap, single producer single consumer queue direct API.">sphdirectpcqueue.h</a>&gt;</span>

  <span class="keywordtype">int</span> *array;
  <span class="keywordtype">int</span> data1, data2, data3;

  handle = <a class="code" href="sphdirectpcqueue_8h.html#a42f22f8c49b31eeb7ddadd2d88889e24" title="Allows the consumer to get the next completed queue entry from the specified single...">SPHSinglePCQueueGetNextCompleteDirectSpin</a> (cqueue);
  <span class="keywordflow">if</span> (handle)
    {
      array = (<span class="keywordtype">int</span> *) <a class="code" href="sphdirectpcqueue_8h.html#a873945ea6ab74626e7ea1cc293bd0d03" title="Return the first free byte address for the direct entry specified by the direct entry...">SPHLFEntryDirectGetFreePtr</a> (handle);
      data1 = array[0];
      data2 = array[1];
      data3 = array[2];

      <span class="keywordflow">if</span> (<a class="code" href="sphdirectpcqueue_8h.html#aecf42336a34826d5599d9d36bc4623b5" title="Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete...">SPHSinglePCQueueFreeNextEntryDirect</a> (cqueue, handle))
        {
          <span class="comment">// complete handling of message</span>
        }
      <span class="keywordflow">else</span>
        { <span class="comment">// error handling</span>
          printf (<span class="stringliteral">&quot;SPHSinglePCQueueFreeNextEntry() = failed\n&quot;</span>);
        }
    }
  <span class="keywordflow">else</span>
    { <span class="comment">// error handling</span>
      printf (<span class="stringliteral">&quot;SPHSinglePCQueueGetNextCompleteDirectSpin() = failed\n&quot;</span>);
    }
</pre></div><p>In this implementation the allocation of the entry is minimally serialized based on the assumption that only one (producer) thread will be allocating queue entries. Likewise the assumption is that there is only one consumer thread per SPHSinglePCQueue_t instance. This allows independent producer/consumer thread pairs to interact with a queue instance with minimum synchronization and overhead.</p>
<p>As an option the queue entry allocator will fill in a 4 byte entry header with:</p>
<ul>
<li>Entry status and length.</li>
<li>Entry identifying Category and SubCategory codes.</li>
</ul>
<p>Any additional storage allocated to the entry (after the header) is available for application specific data. This API also provides a direct pointer mechanism to store application data. The API provides a completion function (SPHSinglePCQueueEntryComplete) which provides any memory barriers required by the platform and marks the entry complete.</p>
<p>The API support simple circular queues and requires a constant entry stride. A stride that matches or is multiple of the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple queue entries across cores/sockets. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a206f641019c26a3569dcfd8bbdc56377"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirect_t" ref="a206f641019c26a3569dcfd8bbdc56377" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instance of a Lock Free event direct data Handle. </p>
<p>Contains fields required to: locate the entry, record the total space allocated to the entry, and manage the next location within the entry and remaining storage.</p>
<p>Entry Handles should be allocated in private (local stack) storage to allow concurrent access to independent entries from multiple threads. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a13025380ee0723957e9709a59bc9bdfe"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectCategory" ref="a13025380ee0723957e9709a59bc9bdfe" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryDirectCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry category for the entry specified by the direct entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a0870fbd111ff161e696d4582b2b04759"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectComplete" ref="a0870fbd111ff161e696d4582b2b04759" args="(SPHLFEntryDirect_t directHandle, sphLFEntryID_t entry_template, int catcode, int subcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryDirectComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a>&nbsp;</td>
          <td class="paramname"> <em>entry_template</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>subcode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes write memory barries required by the platform to ensure that all previous stores by this thread to this entry are complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry_template</em>&nbsp;</td><td>from <a class="el" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90" title="Return the entry template for an existing Lock Free Single Producer Single Consumer...">SPHSinglePCQueueGetEntryTemplate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>catcode</em>&nbsp;</td><td>Category code to the completed entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subcode</em>&nbsp;</td><td>Subcategory code to the completed entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a 1 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="a873945ea6ab74626e7ea1cc293bd0d03"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectGetFreePtr" ref="a873945ea6ab74626e7ea1cc293bd0d03" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryDirectGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first free byte address for the direct entry specified by the direct entry handle. This is normally the byte after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update.">sphLFEntry_t</a>. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function should be used carefully. It is may not provide the correct alignment for the data that follow and does not manage the space within the direct entry, if multiple application functions may update the same entry.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c05f176d4d3ced51f47ccd7c318c088"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectGetPtrAligned" ref="a9c05f176d4d3ced51f47ccd7c318c088" args="(SPHLFEntryDirect_t directHandle, size_t alignval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryDirectGetPtrAligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alignval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first free byte address, with required alignment, within the direct entry specified by the direct entry handle. This is normally the address after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update.">sphLFEntry_t</a> plus alignment padding. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function does not manage the space within the direct entry, this may be an issue if multiple application functions update the same entry.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignval</em>&nbsp;</td><td>required alignment of the next value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5cdfd616e0f427f57f7103c3c15b243"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectIncAndAlign" ref="aa5cdfd616e0f427f57f7103c3c15b243" args="(void *directptr, size_t incval, size_t alignval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* SPHLFEntryDirectIncAndAlign </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>directptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>incval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>alignval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the next free byte address within direct entry specified by a current address within that direct entry. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function does not manage the space within the direct entry, this may be an issue if multiple application functions update the same entry.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directptr</em>&nbsp;</td><td>current data address within Entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incval</em>&nbsp;</td><td>size of last entry address to stepped over. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alignval</em>&nbsp;</td><td>required alignment of the next value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>next address within the entry with require alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a23788fc67715bb71768a4fefbeecdf62"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectIsComplete" ref="a23788fc67715bb71768a4fefbeecdf62" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryDirectIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5f93f1d934f8751a9647c52ee917b7e"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectIsTimestamped" ref="aa5f93f1d934f8751a9647c52ee917b7e" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryDirectIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a429adbbe6673ae51a2dcfd513d1f2a17"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHLFEntryDirectSubcat" ref="a429adbbe6673ae51a2dcfd513d1f2a17" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SPHLFEntryDirectSubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry sub-category for the entry specified by the direct entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae97de2ad82066b7b61f1fcddaa56c6c0"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueAllocStrideDirect" ref="ae97de2ad82066b7b61f1fcddaa56c6c0" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f5f678509240b9936705b5076ec3832"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueAllocStrideDirectSpin" ref="a4f5f678509240b9936705b5076ec3832" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirectSpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9ab882b3d0f06c9f4c603301e291bd2"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueAllocStrideDirectSpinPause" ref="ad9ab882b3d0f06c9f4c603301e291bd2" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirectSpinPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. While spinning use appropriate arch specific instructions to free up core resources for other threads. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions...">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a334a4eb641f9bf8f9761057ebd5c53af"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueEntryIsCompleteDirect" ref="a334a4eb641f9bf8f9761057ebd5c53af" args="(SPHLFEntryDirect_t directHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueEntryIsCompleteDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>directHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directHandle</em>&nbsp;</td><td>entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the entry was complete (SPHSinglePCQueueEntryComplete has been called for this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf42336a34826d5599d9d36bc4623b5"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueFreeNextEntryDirect" ref="aecf42336a34826d5599d9d36bc4623b5" args="(SPHSinglePCQueue_t queue, SPHLFEntryDirect_t next_entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ int SPHSinglePCQueueFreeNextEntryDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&nbsp;</td>
          <td class="paramname"> <em>next_entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue. </p>
<p>Mark the current queue tail entry as free (unallocated and invalid) and bump the queue tail pointer to the next entry. If the specified queue is empty or the current tail entry is not yet completed the Free may fail.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The Consumer thread should not touch or modify a queue entry after calling FreeEntry. This is important to both correctness and performance.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_entry</em>&nbsp;</td><td>Direct handle of the queue entry to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True for successful tail free, otherwise indicated failure. For example the Free may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a30c586b711cfa209da68d97c727a3f90"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueGetEntryTemplate" ref="a30c586b711cfa209da68d97c727a3f90" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> SPHSinglePCQueueGetEntryTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the entry template for an existing Lock Free Single Producer Single Consumer Queue. This template is used later to mark an allocated entry complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the entry template for this queue or 0 if not a valid SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a1241c61422534e4f6ab37c454a6e3a"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueGetNextCompleteDirect" ref="a3a1241c61422534e4f6ab37c454a6e3a" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a42f22f8c49b31eeb7ddadd2d88889e24"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueGetNextCompleteDirectSpin" ref="a42f22f8c49b31eeb7ddadd2d88889e24" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirectSpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed, spin until data is ready.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get id the queue is not actually a SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a273b8483e82ccb040661fed44f860189"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueGetNextCompleteDirectSpinPause" ref="a273b8483e82ccb040661fed44f860189" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirectSpinPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed, spin until data is ready. While spinning use appropriate arch specific instructions to free up core resources for other threads.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get id the queue is not actually a SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a5702403a993f0e6923007b63b2377526"></a><!-- doxytag: member="sphdirectpcqueue.h::SPHSinglePCQueueGetNextEntryDirect" ref="a5702403a993f0e6923007b63b2377526" args="(SPHSinglePCQueue_t queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__C__ <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextEntryDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&nbsp;</td>
          <td class="paramname"> <em>queue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the consumer to get the next allocated queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the entry allocated by the produced thread. If the specified queue is empty or the next queue is not yet allocated the get may fail. Returning a entry does not mean the the producer has completed the entry and the consumer wait/spin (SPHLFEntryDirectIsComplete) for the entry to become complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>queue</em>&nbsp;</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet allocated. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 7 Jan 2015 for Shared Persistent Heap Data Environment Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
