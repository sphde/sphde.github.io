<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Shared Persistent Heap Data Environment Manual: src/sphdirectpcqueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Shared Persistent Heap Data Environment Manual
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sphdirectpcqueue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Shared Persistent Heap, single producer single consumer queue direct API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;sastype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sasatom_8h_source.html">sasatom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphlfentry_8h_source.html">sphlfentry.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sphsinglepcqueue_8h_source.html">sphsinglepcqueue.h</a>&quot;</code><br />
</div>
<p><a href="sphdirectpcqueue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4d08a6f74d96b695afefd03854839b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d08a6f74d96b695afefd03854839b83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a></td></tr>
<tr class="memdesc:a4d08a6f74d96b695afefd03854839b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore this macro behind the curtain <br /></td></tr>
<tr class="separator:a4d08a6f74d96b695afefd03854839b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a206f641019c26a3569dcfd8bbdc56377"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a></td></tr>
<tr class="memdesc:a206f641019c26a3569dcfd8bbdc56377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of a Lock Free event direct data Handle.  <a href="#a206f641019c26a3569dcfd8bbdc56377">More...</a><br /></td></tr>
<tr class="separator:a206f641019c26a3569dcfd8bbdc56377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a402662292f8ba9f24a0f2fa7828906f7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a402662292f8ba9f24a0f2fa7828906f7">SPHLFEntryDirectComplete</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle, <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> entry_template, int catcode, int subcode)</td></tr>
<tr class="memdesc:a402662292f8ba9f24a0f2fa7828906f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores by this thread to this entry are complete.  <a href="#a402662292f8ba9f24a0f2fa7828906f7">More...</a><br /></td></tr>
<tr class="separator:a402662292f8ba9f24a0f2fa7828906f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b2d3b82343ff17bf46401f064b73e0"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#ad6b2d3b82343ff17bf46401f064b73e0">SPHLFEntryDirectGetFreePtr</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:ad6b2d3b82343ff17bf46401f064b73e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first free byte address for the direct entry specified by the direct entry handle. This is normally the byte after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update. ">sphLFEntry_t</a>.  <a href="#ad6b2d3b82343ff17bf46401f064b73e0">More...</a><br /></td></tr>
<tr class="separator:ad6b2d3b82343ff17bf46401f064b73e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912f28ed3b06ee1df3300f657811e27c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a912f28ed3b06ee1df3300f657811e27c">SPHLFEntryDirectGetPtrAligned</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle, size_t alignval)</td></tr>
<tr class="memdesc:a912f28ed3b06ee1df3300f657811e27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first free byte address, with required alignment, within the direct entry specified by the direct entry handle. This is normally the address after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update. ">sphLFEntry_t</a> plus alignment padding.  <a href="#a912f28ed3b06ee1df3300f657811e27c">More...</a><br /></td></tr>
<tr class="separator:a912f28ed3b06ee1df3300f657811e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b6a68ebdd0fd1e48a0de4fcb5f0cf"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aef2b6a68ebdd0fd1e48a0de4fcb5f0cf">SPHLFEntryDirectIncAndAlign</a> (void *directptr, size_t incval, size_t alignval)</td></tr>
<tr class="memdesc:aef2b6a68ebdd0fd1e48a0de4fcb5f0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next free byte address within direct entry specified by a current address within that direct entry.  <a href="#aef2b6a68ebdd0fd1e48a0de4fcb5f0cf">More...</a><br /></td></tr>
<tr class="separator:aef2b6a68ebdd0fd1e48a0de4fcb5f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc671cef17fa340d0b2d99909a13d2b5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#abc671cef17fa340d0b2d99909a13d2b5">SPHLFEntryDirectIsComplete</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:abc671cef17fa340d0b2d99909a13d2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#abc671cef17fa340d0b2d99909a13d2b5">More...</a><br /></td></tr>
<tr class="separator:abc671cef17fa340d0b2d99909a13d2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb82e42518f79ba8a6d256e5bb66826"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aacb82e42518f79ba8a6d256e5bb66826">SPHLFEntryDirectIsTimestamped</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:aacb82e42518f79ba8a6d256e5bb66826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#aacb82e42518f79ba8a6d256e5bb66826">More...</a><br /></td></tr>
<tr class="separator:aacb82e42518f79ba8a6d256e5bb66826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeafb44bc25be707cb58cf6cb86be9d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#acfeafb44bc25be707cb58cf6cb86be9d">SPHLFEntryDirectCategory</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:acfeafb44bc25be707cb58cf6cb86be9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry category for the entry specified by the direct entry handle.  <a href="#acfeafb44bc25be707cb58cf6cb86be9d">More...</a><br /></td></tr>
<tr class="separator:acfeafb44bc25be707cb58cf6cb86be9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970124925f11d4f989a0a9fa3d720f2c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a970124925f11d4f989a0a9fa3d720f2c">SPHLFEntryDirectSubcat</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:a970124925f11d4f989a0a9fa3d720f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry sub-category for the entry specified by the direct entry handle.  <a href="#a970124925f11d4f989a0a9fa3d720f2c">More...</a><br /></td></tr>
<tr class="separator:a970124925f11d4f989a0a9fa3d720f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c586b711cfa209da68d97c727a3f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90">SPHSinglePCQueueGetEntryTemplate</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a30c586b711cfa209da68d97c727a3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entry template for an existing Lock Free Single Producer Single Consumer Queue. This template is used later to mark an allocated entry complete.  <a href="#a30c586b711cfa209da68d97c727a3f90">More...</a><br /></td></tr>
<tr class="separator:a30c586b711cfa209da68d97c727a3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97de2ad82066b7b61f1fcddaa56c6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#ae97de2ad82066b7b61f1fcddaa56c6c0">SPHSinglePCQueueAllocStrideDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:ae97de2ad82066b7b61f1fcddaa56c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue.  <a href="#ae97de2ad82066b7b61f1fcddaa56c6c0">More...</a><br /></td></tr>
<tr class="separator:ae97de2ad82066b7b61f1fcddaa56c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5f678509240b9936705b5076ec3832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a4f5f678509240b9936705b5076ec3832">SPHSinglePCQueueAllocStrideDirectSpin</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a4f5f678509240b9936705b5076ec3832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is.  <a href="#a4f5f678509240b9936705b5076ec3832">More...</a><br /></td></tr>
<tr class="separator:a4f5f678509240b9936705b5076ec3832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ab882b3d0f06c9f4c603301e291bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#ad9ab882b3d0f06c9f4c603301e291bd2">SPHSinglePCQueueAllocStrideDirectSpinPause</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:ad9ab882b3d0f06c9f4c603301e291bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. While spinning use appropriate arch specific instructions to free up core resources for other threads.  <a href="#ad9ab882b3d0f06c9f4c603301e291bd2">More...</a><br /></td></tr>
<tr class="separator:ad9ab882b3d0f06c9f4c603301e291bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f22f8c49b31eeb7ddadd2d88889e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a42f22f8c49b31eeb7ddadd2d88889e24">SPHSinglePCQueueGetNextCompleteDirectSpin</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a42f22f8c49b31eeb7ddadd2d88889e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a42f22f8c49b31eeb7ddadd2d88889e24">More...</a><br /></td></tr>
<tr class="separator:a42f22f8c49b31eeb7ddadd2d88889e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273b8483e82ccb040661fed44f860189"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a273b8483e82ccb040661fed44f860189">SPHSinglePCQueueGetNextCompleteDirectSpinPause</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a273b8483e82ccb040661fed44f860189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a273b8483e82ccb040661fed44f860189">More...</a><br /></td></tr>
<tr class="separator:a273b8483e82ccb040661fed44f860189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1241c61422534e4f6ab37c454a6e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a3a1241c61422534e4f6ab37c454a6e3a">SPHSinglePCQueueGetNextCompleteDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a3a1241c61422534e4f6ab37c454a6e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue.  <a href="#a3a1241c61422534e4f6ab37c454a6e3a">More...</a><br /></td></tr>
<tr class="separator:a3a1241c61422534e4f6ab37c454a6e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf42336a34826d5599d9d36bc4623b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#aecf42336a34826d5599d9d36bc4623b5">SPHSinglePCQueueFreeNextEntryDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue, <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> next_entry)</td></tr>
<tr class="memdesc:aecf42336a34826d5599d9d36bc4623b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue.  <a href="#aecf42336a34826d5599d9d36bc4623b5">More...</a><br /></td></tr>
<tr class="separator:aecf42336a34826d5599d9d36bc4623b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5702403a993f0e6923007b63b2377526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a5702403a993f0e6923007b63b2377526">SPHSinglePCQueueGetNextEntryDirect</a> (<a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a> queue)</td></tr>
<tr class="memdesc:a5702403a993f0e6923007b63b2377526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the consumer to get the next allocated queue entry from the specified single producer single consumer queue.  <a href="#a5702403a993f0e6923007b63b2377526">More...</a><br /></td></tr>
<tr class="separator:a5702403a993f0e6923007b63b2377526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334a4eb641f9bf8f9761057ebd5c53af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sphdirectpcqueue_8h.html#a334a4eb641f9bf8f9761057ebd5c53af">SPHSinglePCQueueEntryIsCompleteDirect</a> (<a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> directHandle)</td></tr>
<tr class="memdesc:a334a4eb641f9bf8f9761057ebd5c53af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the entry specified by the direct entry handle.  <a href="#a334a4eb641f9bf8f9761057ebd5c53af">More...</a><br /></td></tr>
<tr class="separator:a334a4eb641f9bf8f9761057ebd5c53af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shared Persistent Heap, single producer single consumer queue direct API. </p>
<p>For shared memory multi-thread/multi-core applications. This implementation is based on the Lock Free Producer/Consumer Queue (SPHSinglePCQueue_t) but simplifies access to the Entry for lower latency.</p>
<p>This API supports atomic allocation of storage for queue entries for zero copy persistence and sharing. Zero copy queues divides the process of producing a queue entry in to three steps:</p><ul>
<li>Allocate the queue entry (and initialize the header)</li>
<li>Use the return entry handle to fill in application specific data.</li>
<li>Marks the entry complete in the header.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphdirectpcqueue_8h.html">sphdirectpcqueue.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">  <a class="code" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> entry_tmp;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// only need to do this once per pcqueue and so should be</span></div>
<div class="line">  <span class="comment">// outside of the primary producer message loop.</span></div>
<div class="line">  entry_tmp = <a class="code" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90">SPHSinglePCQueueGetEntryTemplate</a>(pqueue);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> handle;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> *array;</div>
<div class="line"></div>
<div class="line">  handle = <a class="code" href="sphdirectpcqueue_8h.html#a4f5f678509240b9936705b5076ec3832">SPHSinglePCQueueAllocStrideDirectSpin</a> (pqueue);</div>
<div class="line">  <span class="keywordflow">if</span> (handle)</div>
<div class="line">    {</div>
<div class="line">      array = (<span class="keywordtype">int</span> *) <a class="code" href="sphdirectpcqueue_8h.html#ad6b2d3b82343ff17bf46401f064b73e0">SPHLFEntryDirectGetFreePtr</a> (handle);</div>
<div class="line">      array[0] = val1;</div>
<div class="line">      array[1] = val2;</div>
<div class="line">      array[2] = val3;</div>
<div class="line">      <a class="code" href="sphdirectpcqueue_8h.html#a402662292f8ba9f24a0f2fa7828906f7">SPHLFEntryDirectComplete</a> (handle, entry_tmp, 1, 2);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// error handling</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p>The consumer can access queue entries once they are marked complete. The consumer:</p><ul>
<li>checks (spins) for the next allocated entry to become complete.</li>
<li>uses the returned entry handle to directly access the entry contents.</li>
<li>When done processing the queue entry, it marks the entry header invalid and deallocates the entry.</li>
<li>This makes the next queue entry available, if any.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sphdirectpcqueue_8h.html">sphdirectpcqueue.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> *array;</div>
<div class="line">  <span class="keywordtype">int</span> data1, data2, data3;</div>
<div class="line"></div>
<div class="line">  handle = <a class="code" href="sphdirectpcqueue_8h.html#a42f22f8c49b31eeb7ddadd2d88889e24">SPHSinglePCQueueGetNextCompleteDirectSpin</a> (cqueue);</div>
<div class="line">  <span class="keywordflow">if</span> (handle)</div>
<div class="line">    {</div>
<div class="line">      array = (<span class="keywordtype">int</span> *) <a class="code" href="sphdirectpcqueue_8h.html#ad6b2d3b82343ff17bf46401f064b73e0">SPHLFEntryDirectGetFreePtr</a> (handle);</div>
<div class="line">      data1 = array[0];</div>
<div class="line">      data2 = array[1];</div>
<div class="line">      data3 = array[2];</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="sphdirectpcqueue_8h.html#aecf42336a34826d5599d9d36bc4623b5">SPHSinglePCQueueFreeNextEntryDirect</a> (cqueue, handle))</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// complete handling of message</span></div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        { <span class="comment">// error handling</span></div>
<div class="line">          printf (<span class="stringliteral">&quot;SPHSinglePCQueueFreeNextEntry() = failed\n&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    { <span class="comment">// error handling</span></div>
<div class="line">      printf (<span class="stringliteral">&quot;SPHSinglePCQueueGetNextCompleteDirectSpin() = failed\n&quot;</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>In this implementation the allocation of the entry is minimally serialized based on the assumption that only one (producer) thread will be allocating queue entries. Likewise the assumption is that there is only one consumer thread per SPHSinglePCQueue_t instance. This allows independent producer/consumer thread pairs to interact with a queue instance with minimum synchronization and overhead.</p>
<p>As an option the queue entry allocator will fill in a 4 byte entry header with:</p><ul>
<li>Entry status and length.</li>
<li>Entry identifying Category and SubCategory codes.</li>
</ul>
<p>Any additional storage allocated to the entry (after the header) is available for application specific data. This API also provides a direct pointer mechanism to store application data. The API provides a completion function (SPHSinglePCQueueEntryComplete) which provides any memory barriers required by the platform and marks the entry complete.</p>
<p>The API support simple circular queues and requires a constant entry stride. A stride that matches or is multiple of the cache line size can improve performance by avoiding "false sharing" of cache lines containing multiple queue entries across cores/sockets. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a206f641019c26a3569dcfd8bbdc56377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instance of a Lock Free event direct data Handle. </p>
<p>Contains fields required to: locate the entry, record the total space allocated to the entry, and manage the next location within the entry and remaining storage. </p><pre class="fragment">Entry Handles should be allocated in private (local stack) storage
to allow concurrent access to independent entries from multiple threads.</pre> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acfeafb44bc25be707cb58cf6cb86be9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryDirectCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry category for the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a402662292f8ba9f24a0f2fa7828906f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryDirectComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a>&#160;</td>
          <td class="paramname"><em>entry_template</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>catcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the entry specified by the entry handle as complete. Also executes any memory barriers required by the platform to ensure that all previous stores by this thread to this entry are complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">entry_template</td><td>from <a class="el" href="sphdirectpcqueue_8h.html#a30c586b711cfa209da68d97c727a3f90" title="Return the entry template for an existing Lock Free Single Producer Single Consumer Queue...">SPHSinglePCQueueGetEntryTemplate()</a>. </td></tr>
    <tr><td class="paramname">catcode</td><td>Category code to the completed entry. </td></tr>
    <tr><td class="paramname">subcode</td><td>Subcategory code to the completed entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 1 value indicates success. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b2d3b82343ff17bf46401f064b73e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryDirectGetFreePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first free byte address for the direct entry specified by the direct entry handle. This is normally the byte after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update. ">sphLFEntry_t</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function should be used carefully. It is may not provide the correct alignment for the data that follow and does not manage the space within the direct entry, if multiple application functions may update the same entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="a912f28ed3b06ee1df3300f657811e27c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryDirectGetPtrAligned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first free byte address, with required alignment, within the direct entry specified by the direct entry handle. This is normally the address after the <a class="el" href="unionsphLFEntry__t.html" title="Union of Entry details with 32-bit word for atomic update. ">sphLFEntry_t</a> plus alignment padding. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function does not manage the space within the direct entry, this may be an issue if multiple application functions update the same entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
    <tr><td class="paramname">alignval</td><td>required alignment of the next value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address the entries free space. </dd></dl>

</div>
</div>
<a class="anchor" id="aef2b6a68ebdd0fd1e48a0de4fcb5f0cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* SPHLFEntryDirectIncAndAlign </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>directptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>incval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>alignval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next free byte address within direct entry specified by a current address within that direct entry. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function does not manage the space within the direct entry, this may be an issue if multiple application functions update the same entry.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directptr</td><td>current data address within Entry. </td></tr>
    <tr><td class="paramname">incval</td><td>size of last entry address to stepped over. </td></tr>
    <tr><td class="paramname">alignval</td><td>required alignment of the next value to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next address within the entry with require alignment. </dd></dl>

</div>
</div>
<a class="anchor" id="abc671cef17fa340d0b2d99909a13d2b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryDirectIsComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHLFLoggerEntryComplete has been called fo this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aacb82e42518f79ba8a6d256e5bb66826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryDirectIsTimestamped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was time stamped. Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="a970124925f11d4f989a0a9fa3d720f2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int SPHLFEntryDirectSubcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entry sub-category for the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>Entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-category from the entry, if the entry was valid. Otherwise return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ae97de2ad82066b7b61f1fcddaa56c6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f5f678509240b9936705b5076ec3832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirectSpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9ab882b3d0f06c9f4c603301e291bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueAllocStrideDirectSpinPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the producer thread to allocate and initialize the header of a queue entry for access. The allocation is from the specified Single Producer Single Consumer Queue. If space is not Immediately available, spin until it is. While spinning use appropriate arch specific instructions to free up core resources for other threads. </p>
<p>The allocation size is the stride set when the PC queue was initialized/created. The Entry status and length are stored in the header of the new entry. Returns an dire ctentry handle which allows the application to insert application specific data into the entry via the <a class="el" href="sphlfentry_8h.html" title="Shared Persistent Heap, logger/queue etc event entry status, update, and access functions. ">sphlfentry.h</a> API. If the specified queue is full the allocation may fail.</p>
<dl class="section note"><dt>Note</dt><dd>The queue entry is not ready for access by the Consumer thread, until additional application data is inserted and the entry is completed (via SPHLFEntryDirectComplete). Category and Subcategory may be supplied as the entry is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct handle of the initialized queue entry, or 0 (NULL) if the allocation failed. For example the Allocate may fail if the queue is full. </dd></dl>

</div>
</div>
<a class="anchor" id="a334a4eb641f9bf8f9761057ebd5c53af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueEntryIsCompleteDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>directHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status of the entry specified by the direct entry handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directHandle</td><td>entry Handle for an allocated entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry was complete (SPHSinglePCQueueEntryComplete has been called for this entry). Otherwise False. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf42336a34826d5599d9d36bc4623b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> int SPHSinglePCQueueFreeNextEntryDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a>&#160;</td>
          <td class="paramname"><em>next_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to free the queue entry it just processed (using SPHSinglePCQueueGetNextComplete), from the specified single producer single consumer queue. </p>
<p>Mark the current queue tail entry as free (unallocated and invalid) and bump the queue tail pointer to the next entry. If the specified queue is empty or the current tail entry is not yet completed the Free may fail.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Consumer thread should not touch or modify a queue entry after calling FreeEntry. This is important to both correctness and performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue, </td></tr>
    <tr><td class="paramname">next_entry</td><td>Direct handle of the queue entry to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for successful tail free, otherwise indicated failure. For example the Free may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a30c586b711cfa209da68d97c727a3f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphlfentry_8h.html#a68e60b0ae114451f6f34dde2f0a2a94e">sphLFEntryID_t</a> SPHSinglePCQueueGetEntryTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the entry template for an existing Lock Free Single Producer Single Consumer Queue. This template is used later to mark an allocated entry complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the entry template for this queue or 0 if not a valid SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a1241c61422534e4f6ab37c454a6e3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed the get may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a42f22f8c49b31eeb7ddadd2d88889e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirectSpin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed, spin until data is ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get id the queue is not actually a SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a273b8483e82ccb040661fed44f860189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextCompleteDirectSpinPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next completed queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the application specific data inserted by the produced thread. If the specified queue is empty or the next queue is not yet completed, spin until data is ready. While spinning use appropriate arch specific instructions to free up core resources for other threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get id the queue is not actually a SPHSinglePCQueue_t. </dd></dl>

</div>
</div>
<a class="anchor" id="a5702403a993f0e6923007b63b2377526"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sphmultipcqueue_8h.html#a4d08a6f74d96b695afefd03854839b83">__C__</a> <a class="el" href="sphdirectpcqueue_8h.html#a206f641019c26a3569dcfd8bbdc56377">SPHLFEntryDirect_t</a> SPHSinglePCQueueGetNextEntryDirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sphsinglepcqueue_8h.html#af9363971fb3b8f26e861ea3259556381">SPHSinglePCQueue_t</a>&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the consumer to get the next allocated queue entry from the specified single producer single consumer queue. </p>
<p>Returns an direct entry handle which allows the application to access the entry allocated by the produced thread. If the specified queue is empty or the next queue is not yet allocated the get may fail. Returning a entry does not mean the the producer has completed the entry and the consumer wait/spin (SPHLFEntryDirectIsComplete) for the entry to become complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Handle of a producer consumer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Direct Handle of the initialized logger entry, or 0 (NULL) if the get failed. For example the Get may fail if the queue is empty or the next tail entry is not yet allocated. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 03:14:09 for Shared Persistent Heap Data Environment Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
